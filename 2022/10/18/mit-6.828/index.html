

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/basketball.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="bollcode">
  <meta name="keywords" content="">
  
    <meta name="description" content="mit 6.828基本 git 如果完成lab之后，开始执行下面 git add –all git commit -m“” git push along-lab labx git checkout -b lab(x+1) origin&#x2F;lab(x+1) git merge labx git add –all git commit -m”” git push along-lab lab(x+1) l">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT-6.828操作系统">
<meta property="og:url" content="http://example.com/2022/10/18/mit-6.828/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="mit 6.828基本 git 如果完成lab之后，开始执行下面 git add –all git commit -m“” git push along-lab labx git checkout -b lab(x+1) origin&#x2F;lab(x+1) git merge labx git add –all git commit -m”” git push along-lab lab(x+1) l">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/mit6.828.jpg">
<meta property="article:published_time" content="2022-10-18T07:41:15.178Z">
<meta property="article:modified_time" content="2023-08-03T14:45:14.497Z">
<meta property="article:author" content="bollcode">
<meta property="article:tag" content="MIT6.828">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/mit6.828.jpg">
  
  
  
  <title>MIT-6.828操作系统 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>bollcode</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MIT-6.828操作系统"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-18 15:41" pubdate>
          2022年10月18日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          102k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          848 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MIT-6.828操作系统</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="mit-6-828"><a href="#mit-6-828" class="headerlink" title="mit 6.828"></a>mit 6.828</h1><p>基本 git</p>
<p>如果完成lab之后，开始执行下面</p>
<p>git add –all</p>
<p>git commit -m“”</p>
<p>git push along-lab labx</p>
<p>git checkout -b lab(x+1) origin/lab(x+1)</p>
<p>git merge labx</p>
<p>git add –all</p>
<p>git commit -m””</p>
<p>git push along-lab lab(x+1)</p>
<h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p><img src="/2022/10/18/mit-6.828/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzAyODkw,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="1-gdb调试"><a href="#1-gdb调试" class="headerlink" title="1. gdb调试"></a>1. gdb调试</h3><blockquote>
<p>第一步：</p>
</blockquote>
<p>在lab文件夹下打开一个终端并执行<code>make qemu-gdb</code></p>
<blockquote>
<p>第二步</p>
</blockquote>
<p>再在lab文件夹下打开一个终端，执行<code>make gdb</code></p>
<p>如果出现了“auto-load safe-path’ 这种错误，那我们执行<code>gdb -iex &quot;set auto-load safe-path /&quot;</code>,</p>
<p>执行完成make gdb 或gdb -iex “set auto-load safe-path /“后，如果出现连接超时现象</p>
<p>大概率是端口错误</p>
<p>我们指定端口重新连接，在gdb下执行这个命令：<code>target remote:26000</code> </p>
<p>然后通过<code>si</code>命令就可以一步步的执行cpu汇编程序了</p>
<p>一个si命令就会执行一步，一步重复si命令就行</p>
<h3 id="2-gdb命令"><a href="#2-gdb命令" class="headerlink" title="2. gdb命令"></a>2. gdb命令</h3><p>b *0x10000c 代表的打断点</p>
<p>si命令是执行下一步</p>
<p>x/nxb 0x100000   这个命令是显示ox100000存储器后的n个字节内容</p>
<h3 id="3-虚拟地址和物理地址"><a href="#3-虚拟地址和物理地址" class="headerlink" title="3. 虚拟地址和物理地址"></a>3. 虚拟地址和物理地址</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/421006318">参考博客</a></p>
<blockquote>
<p>虚拟地址 ： 就是编译器链接之后的程序地址，但是这个地址和实际的物理地址不相等，他会在加载程序和运行程序的时候转换成（映射）实际物理地址</p>
</blockquote>
<blockquote>
<p>物理地址：就是实际的物理地址，对应的就是内存条上的地址</p>
</blockquote>
<blockquote>
<p>如何通过虚拟地址映射到实际的物理地址</p>
</blockquote>
<p>针对于二级目录来讲的</p>
<ol>
<li>将虚拟地址的高10为用作页目录表的索引：找到指定的页表   一个页目录就是占用的一个页的大小即1024个页表项</li>
<li>然后通过指定的页目录项中的内容（指定的页表的起始地址），找到了指定的页表，然后通过高10位后的10位用做页项索引，一个页表也是占用一个页，一个页表可以对应1024个页项</li>
<li>然后通过指定的页表项中的内容（指定的页的其实位置），找到了指定的页，然后根据后12位作为实际地址的索引，这样就将一个虚拟地址映射到了一个实际物理地址</li>
</ol>
<p>【重点】 这个页目录、页表都是在加载程序的时候给确定分配完成的，后面就可以根据这个页目录表和页表就可以根据虚拟地址找到了物理地址，就是存放程序的实际地方。</p>
<p>【看上面的博客的第四节和第五节，就是如何创建页目录表和页表以及如何根据虚拟地址找到物理地址】</p>
<h2 id="lab2-memory-management"><a href="#lab2-memory-management" class="headerlink" title="lab2  memory management"></a>lab2  memory management</h2><h3 id="1-va-list-可变参数原理"><a href="#1-va-list-可变参数原理" class="headerlink" title="1. va_list 可变参数原理"></a>1. va_list 可变参数原理</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ZKR_HN/article/details/99558135">可变参数原理</a></p>
<p>c语言中，函数的参数是从右往左压入栈中的，所以，右边的参数先压入栈，左边的参数后压入栈</p>
<p>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数，而且x86平台内存分配顺序是从高地址到低地址。因此似函数AVEInt(int var1,int<br>var2,…,int varN)内存分配大致上是这样的：(可变参数在中间)</p>
<p><img src="/2022/10/18/mit-6.828/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pLUl9ITg==,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6989917722519797797">https://juejin.cn/post/6989917722519797797</a></p>
<p>【基本命令】<a target="_blank" rel="noopener" href="https://blog.csdn.net/fantasy_wxe/article/details/52198650">https://blog.csdn.net/fantasy_wxe/article/details/52198650</a></p>
<h3 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bakari/p/7858029.html">https://www.cnblogs.com/bakari/p/7858029.html</a></p>
<p>Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p>
<p><img src="/2022/10/18/mit-6.828/431521-20171118213522843-322721697.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>从本质上看，虚拟出的每个虚拟机对应 host 上的一个 Qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 Qemu 进程的一个线程。</p>
<p>Qemu 软件虚拟化实现的思路是采用二进制指令翻译技术，主要是提取 guest 代码，然后将其翻译成 TCG 中间代码，最后再将中间代码翻译成 host 指定架构的代码，如 x86 体系就翻译成其支持的代码形式，ARM 架构同理。</p>
<blockquote>
<p>基本命令</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">https://pdos.csail.mit.edu/6.828/2018/labguide.html</a></p>
<p><code>Qemu包含一个内置的监视器用来观察和修改机器状态，进入monitor模式后，在终端中按下Ctrl-a c运行Qemu， 再次按下Ctrl-a c切换到串口控制台</code></p>
<p><code>info registers</code> 输出所有的寄存器</p>
<p><code>info pg</code> 输出页表关系</p>
<p><code>info mem</code>输出各个内存段的读写权限</p>
<h3 id="GDB基本概念"><a href="#GDB基本概念" class="headerlink" title="GDB基本概念"></a>GDB基本概念</h3><p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lvdongjie/p/8994092.html//">https://www.cnblogs.com/lvdongjie/p/8994092.html//</a> 很详细的一篇博客</strong></p>
<p>GDB是一个强大的命令行调试工具。他是GNU组织发布的一个unix下的程序调试工具。一般来说，GDB主要帮你完成下面四个方面的功能。</p>
<ol>
<li>启动你的程序，可以按照你自定义的要求随心所欲的运行程序</li>
<li>可以让被调试的程序在你所指定的调试的断点处停住（<strong>断点可以是条件表达式</strong>）</li>
<li>当程序被停止时，可以检查此时你的程序发生的事情。</li>
<li>动态的改变你程序的执行环境</li>
</ol>
<blockquote>
<p>基本命令：</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaoshaonian/p/10219680.html">https://www.cnblogs.com/gaoshaonian/p/10219680.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bxf0011/p/14470215.html">https://www.cnblogs.com/bxf0011/p/14470215.html</a></p>
<p><code>i r addr</code> 可以查看这个地址的内容  i r eip cs 查看eip和cs寄存器内容<br><code>x/Ni addr</code> 表示可以查看addr地址开始的N条指令 ， x/6i $cs*16 + $eip 也可以查看实模式下的地址开始的6条指令<br><code>x/Nx addr</code> 表示将地址addr开始的N个字节以16进制显示出来，可以查看地址空间内容</p>
<p><code>info all-registers</code> 显示所有的寄存器信息</p>
<h3 id="elf-命令"><a href="#elf-命令" class="headerlink" title="elf 命令"></a>elf 命令</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yfldyxl/article/details/81566279">https://blog.csdn.net/yfldyxl/article/details/81566279</a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote>
<p>安装qemu–用来仿真x86架构的计算机</p>
</blockquote>
<p>这门课就是采用qemu来模拟一个x86架构的计算机来运行你的xv6操作系统，这个软件也可以和gdb一起搭配使用，这样我们就可以在这个qemu上来一条指令一条指令的调试你的xv6操作系统了</p>
<p>当我们下载完成qemu后，我们需要先编译我们下载的操作系统源码，用来生成能够运行在qemu上的操作系统映像文件，编译完成之后会生成一个obl/kern/kernel.img,这个kernel.img文件就是编译后的操作系统镜像文件，这个文件是操作系统make之后生成的。</p>
<p>然后我们在lab的目录下输入make qemu，此时qemu就开始加载我们的操作系统内核映像文件了</p>
<h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><h4 id="物理地址布局"><a href="#物理地址布局" class="headerlink" title="物理地址布局"></a>物理地址布局</h4><p>PC的物理地址基本内存布局：</p>
<p><img src="/2022/10/18/mit-6.828/image-20230301192502377-16776699035263.png" srcset="/img/loading.gif" lazyload alt="image-20230301192502377"></p>
<p><img src="/2022/10/18/mit-6.828/6818371c053c41309ca53d732effd757tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>第一代PC处理器是16位字长的Intel 8088处理器，这类处理器只能访问1MB的地址空间，即0x00000000-0x000FFFFF。但是这1MB也不是用户都能利用到的，只有低640KB(0x00000000-0x000A0000)的地址空间是用户程序可以使用的（DRAM–动态随机访问内存）。而剩下的384KB的高地址空间则被保留用作其他的目的，比如(0x000A0000-0x000C0000)被用作屏幕显示内容缓冲区，其他的则被非易失性存储器(ROM)所使用，里面会存放一些固件，其中最重要的一部分就是BIOS（存在ROM中），占据了0x000F0000~0x00100000的地址空间。</p>
<blockquote>
<p>Bios做了那么些事情，它的主要工作是检测、初始化一些硬件、<strong>构建中断向量表</strong>、<strong>加载boot loader引导加载操纵系统</strong>等功能，BIOS存在F0000-FFFFF这64kb空间，属于ROM，在出厂的时候就有了，一般不能更改。</p>
<p><strong>当BIOS确定后，操作系统是位于磁盘中的，那么BIOS就会去把第一个磁盘的第一个扇区，这个扇区通常叫做启动区（boot sector）加载到内存中，这个启动区中包括一个非常重要的程序叫做boot loader，它就是专门负责将整个操作系统加载到内存中。</strong></p>
</blockquote>
<h4 id="基本启动流程"><a href="#基本启动流程" class="headerlink" title="基本启动流程"></a>基本启动流程</h4><blockquote>
<p>下面我们使用qemu和gdb探索PC机的启动过程。</p>
<p>**先说一下大概流程：BIOS  –&gt; BootLoader –&gt; 操作系统内核 **</p>
</blockquote>
<ul>
<li>首先我们在lab目录下指行<code>make qemu-gdb</code>，运行qemu（以调试模式启动了机器）</li>
<li>然后在lab下指向<code>gdb</code>指令，然后就可以一步步的控制qemu的内置的指针一步一步的执行指令（gdb是对机器pc而言的，不是对操作系统而言的，操作系统说白了也是一个程序）</li>
</ul>
<p>我们就会得到 <code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code>,这个就是整个PC启动后执行的第一条指令，然后就停在了这里，然后可以通过gdb进行一步一步的执行进行跟踪这个pc如何运行的。</p>
<p>上面这个<code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code>，表示现在PC执行的第一个指令的地址是f000:fff0，代表cs:ip的值，所以真实地址就是cs*16 + ip = ffff0 ,这个就是BIOS程序的入口地址，也就是那1m空间的最高的64b空间，然后执行的指令是<code>ljmp  $0xf000, $0xe05b</code>表示跳转到<code>fe05b</code>,这个地址就是BIOS程序的第一条指令。</p>
<p>为什么第一条指令的地址在ffff0,这是cpu在上电的一瞬间，强制将cs：ip这两个寄存器设置成了<code>f000</code>和<code>fff0</code></p>
<p>因为开机处于实模式，所以要cs*16 + ip才是真正的地址，至于什么是实模式下面再介绍。</p>
<h4 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h4><p>实模式是早期CPU，比如8088处理器的工作模式，这类处理器由于有20根地址线，所以它们能访问1MB的内存空间。但是呢，cpu的寄存器只有16位，如果只用一个寄存器来存储地址，那么只能寻址到0000-FFFF这么多，所以用两个寄存器（段基址寄存器cs 和段内偏移寄存器 ip）来存储地址，然后地址的计算公式是cs*16 + ip</p>
<p>但是CPU也在不断的发展，之后的80286/80386已经具备32位地址总线，能够访问4GB内存空间，为了能够很好的管理这么大的内存空间，保护模式被研发出来。在保护模式下，虽然段值仍然由原来的16位cs寄存器指定，但此时这些寄存器中存放的不再是段基址，而是一个索引。从这个索引，可以找到一个表项，里面存放了段基址等很多属性，这个表项称为段描述符，这个表就称为GDT。</p>
<p>现代处理器都是工作在保护模式下的。但是为了实现向后兼容性，即原来运行在8088处理器上的软件仍旧能在现代处理器上运行，现代的CPU都是在启动时运行于实模式，启动完成后运行于保护模式</p>
<p>BIOS就是PC刚启动时运行的软件，所以它必然工作在实模式下。</p>
<h4 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h4><p>因为现在地址线的个数从20根变成了32根，寻址范围变成了4GB，然后寄存器的位数也变成了32位（寄存器是在cpu中的）。所以通过32位就能够实现4GB的寻址了，为了能够更好的管理这么大的内存空间，就引入了保护模式。</p>
<p>我们先介绍以下几个概念：逻辑地址、虚拟地址、线性地址、物理地址</p>
<ul>
<li>虚拟地址：我们都知道，我们程序员在编写程序的时候，根本不知道以后我们的程序会运行在什么机器上，也不知道这个机器的内存占用情况，所以我们要让程序运行在虚拟地址空间小，也就是说，我们在编写程序时指令出现的地址不一定就是机器上的物理内存地址。这样操作是为了让程序员在编程的时候不用直接操作实际物理地址，因为我们也不知道内存地址的占用情况。所以以后这个程序指令存在哪个物理地址空间由操作系统决定，程序中的地址要访问哪个物理地址由操作系统来确定。这个就是从虚拟地址到物理地址之间的转换</li>
<li>逻辑地址：程序员编写时看到的是虚拟地址，但是并不是直接把虚拟地址直接写入到这个指令中的，基本都是偏移量，逻辑地址由两部分组成，一个是段选择子，一个是段内偏移量，分别存在cs/ds/ss/es和ip中，采用哪个段选择子一般都是在指令中隐含的，程序员只需要指明段内偏移量，然后分段管理机构将这个逻辑地址转换成<strong>线性地址</strong>（其实就是虚拟地址），。如果机器没有开启分页机制，那么这个线性地址就是实际的物理地址。但是如果开启了分页机制，那么就会将这个线性地址转换成物理地址。</li>
</ul>
<p><img src="/2022/10/18/mit-6.828/809277-20160109142207371-383459687.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>那么在保护模式下，我们怎么进行寻址的呢？</p>
</blockquote>
<p><strong>GTD</strong></p>
<p>首先在计算机中存在两个表一个是GDT和LDT。分别就全局段描述符表，和本地段描述符表。GDT是全局可见的，他维护了很多段描述符（程序段、数据段、栈段），每个描述符包含了某个段的起始地址，占用多大空间等信息</p>
<p><img src="/2022/10/18/mit-6.828/809277-20160109143519184-1430449279.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们从图中可以看到，无论是GDT，还是LDT。每一个表项都包括三个字段：（这三个元素的空间分配总共64字节但是分配的很细碎）</p>
<p><img src="/2022/10/18/mit-6.828/8560837bbb6e40659359df8b88acbac6tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>　　Base : 32位，代表这个程序的这个段的基地址。</p>
<p>　　Limit : 20位，代表这个程序的这个段的大小。</p>
<p>　　Flags ：12位，代表这个程序的这个段的访问权限。</p>
<p>每一个GDT Entry结构如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gdt_entry</span> &#123;<br>  uint16 limit_low;<br>  uint16 base_low;<br>  uint8  base_middle;<br>  uint8  access;<br>  uint8  attributes;<br>  uint8  base_high;<br>&#125; __attribute__((packed));<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gdt_entry</span> <span class="hljs-type">gdt_entry_t</span>;<br><br></code></pre></td></tr></table></figure>



<p>当程序中给出逻辑地址 segment:offset时，他并不是像实模式那样，用segment的值作为段基址。而是把这个segment的值作为一个selector，代表这个段的段表项在GDT/LDT表的索引。比如你当前要访问的地址是segment:offset = 0x01:0x0000ffff，此时由于每个段表项的长度为8，所以此时应该取出地址8处的段表项。然后首先根据Flags字段来判断是否可以访问这个段的内容，这样做是为了能够实现进程间地址的保护。如果能访问，则把Base字段的内容取出，直接与offset相加，就得到线性地址(linear address)了。之后就是要根据是否有分页机构来进行地址转换了。</p>
<p>保护模式还是要比实模式的工作方式灵活许多，可以在以下几个方面看出来：</p>
<ol>
<li>实模式下段基地址必须是16的整数倍，保护模式下段基地址可以是4GB空间内的任意一个地址。</li>
<li>实模式下段的长度是65536B，但是保护模式下段的长度也是可以达到4GB的。</li>
<li> 保护模式下可以对内存的访问多加一层保护，但是实模式没有</li>
</ol>
<blockquote>
<p><strong>GDT表的地址存在GDTR寄存器中，由lgdt指令进行加载</strong>，这个寄存器共48位，前十六位表示GDT界限，后32位存储GDT地址，GDT只能容纳65536/8 = 8192个段描述符</p>
<p>段选择子是存在各个CS\DS\SS\ES等寄存器中，表示在GDT中的索引，其中寄存器的后13位才是真正的索引值，前3位表示TI字段和RPL字段。</p>
</blockquote>
<blockquote>
<p>总结：</p>
</blockquote>
<p><img src="/2022/10/18/mit-6.828/50ab3e5466814b8ba07d7bccc580430etplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" srcset="/img/loading.gif" lazyload alt="image-20210730181710510"></p>
<h4 id="cpu模型"><a href="#cpu模型" class="headerlink" title="cpu模型"></a>cpu模型</h4><p><img src="/2022/10/18/mit-6.828/image-20230305215350922.png" srcset="/img/loading.gif" lazyload alt="image-20230305215350922"></p>
<h3 id="逐步分析启动流程"><a href="#逐步分析启动流程" class="headerlink" title="逐步分析启动流程"></a>逐步分析启动流程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41761478/article/details/101102354">https://blog.csdn.net/weixin_41761478/article/details/101102354</a></p>
<p><img src="/2022/10/18/mit-6.828/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzAyODkw,size_16,color_FFFFFF,t_70-167791316370135.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="首先进入BIOS程序"><a href="#首先进入BIOS程序" class="headerlink" title="首先进入BIOS程序"></a>首先进入BIOS程序</h4><p>当上电之后，cs：ip被强制设成f000：fff0 这个就是BIOS的入口程序地址，在这里会指向跳转命令，跳转到真正的BIOS程序中。</p>
<p>先简单介绍以下BIOS会做哪些事情：</p>
<ul>
<li><p>BIOS的操作就是在控制，初始化，检测各种底层的设备，比如时钟，GDTR寄存器。（开启保护模式又关闭了）</p>
</li>
<li><p>以及设置BIOS自身的中断向量表。</p>
</li>
<li><p>但是作为PC启动后运行的第一段程序，<strong>它最重要的功能是把操作系统从磁盘中导入内存，然后再把控制权转交给操作系统。</strong></p>
</li>
<li><p>所以BIOS在运行的最后会去检测可以从当前系统的哪个设备中找到操作系统，通常来说是我们的磁盘。也有可能是U盘等等。当BIOS确定了，操作系统位于磁盘中，那么它就会把这个磁盘的第一个扇区，通常把它叫做启动区（boot sector）先加载到内存中，这个启动区中包括一个非常重要的程序–<strong>boot loader，</strong>它会负责完成整个操作系统从磁盘导入内存的工作，以及一些其他的非常重要的配置工作。最后操作系统才会开始运行。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-number">1.</span> <span class="hljs-number">0xffff0</span>:  ljmp $<span class="hljs-number">0xf000</span>, $<span class="hljs-number">0xe05b</span>    跳转到 <span class="hljs-number">0xf000</span>*<span class="hljs-number">16</span> + <span class="hljs-number">0xe05b</span>地方去<br>   <span class="hljs-number">2.</span> <span class="hljs-number">0xfe05b</span>: cmpl $<span class="hljs-number">0x0</span>, $cs:<span class="hljs-number">0x6ac8</span><br>   <span class="hljs-number">3.</span> <span class="hljs-number">0xfe062</span>:  jne  <span class="hljs-number">0xfd2e1</span><br>    <span class="hljs-number">4.</span> <span class="hljs-number">0xfe066</span>:  xor  %dx, %dx <span class="hljs-comment">//将寄存器清零</span><br>    <span class="hljs-number">5.</span> <span class="hljs-number">0xfe068</span>:  mov  %dx %ss<br>    <span class="hljs-number">6.</span> <span class="hljs-number">0xfe06a</span>:  mov  $<span class="hljs-number">0x7000</span>, %esp<br>    <span class="hljs-number">7.</span> <span class="hljs-number">0xfe070</span>:  mov  $<span class="hljs-number">0xf34d2</span>, %edx<br>    <span class="hljs-number">8.</span> <span class="hljs-number">0xfe076</span>:  jmp  <span class="hljs-number">0xfd15c</span>  <span class="hljs-comment">// 绝对跳转至下一条指令</span><br>    <span class="hljs-number">9.</span> <span class="hljs-number">0xfd15c</span>:  mov  %eax, %ecx<br>        <br>    <span class="hljs-number">10.</span> <span class="hljs-number">0xfd15f</span>:  cli  <span class="hljs-comment">//关闭中断指令。这个比较好理解，启动时的操作是比较关键的，所以肯定是不能被中断的。这个关中断指令用于关闭那些可以屏蔽的中断。比如大部分硬件中断。cli表示clear Interrupt，作用是将EFLAGS标志寄存器的IF置为0。EFLAGS标志寄存器有32位，不同位代表不同标志，</span><br>       <span class="hljs-comment">// 其中IF表示中断使能标志。关于中断：中断对于CPU来说，分为外部中断和内部中断。将 IF标志设置为0，屏蔽的是来自硬件的可屏蔽中断请求。在 IF为0期间，只有CPU外部不可屏蔽中断（NMI）引脚上发来的硬件中断请求能得到响应，其它可屏蔽请求不被响应。启动时的操作是比较关键的，所以肯定是不能被中断的，因此需要这个关中断指令用于关闭那些可以屏蔽的中断</span><br>  <span class="hljs-comment">// 通过 i r eflags 可以查看寄存器值</span><br>    <br>    <span class="hljs-number">11.</span> <span class="hljs-number">0xfd160</span>:  cld <span class="hljs-comment">//设置方向标识位为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为0代表从低地址值变为高地址。</span><br>     <span class="hljs-number">12.</span> <span class="hljs-number">0xfd161</span>:  mov  $<span class="hljs-number">0x8f</span>, %eax  <span class="hljs-comment">// 这三条指令是用来关闭NMI中断的。</span><br>    <span class="hljs-number">13.</span> <span class="hljs-number">0xfd167</span>:  out  %al, $<span class="hljs-number">0x70</span><br>    <span class="hljs-number">14.</span> <span class="hljs-number">0xfd169</span>:  in  $<span class="hljs-number">0x71</span>, %al <br>       <span class="hljs-comment">// 这三个操作中涉及到两个新的指令out, in。这两个操作是用于操作IO端口的</span><br>         <span class="hljs-comment">//in %al, PortAddress    向端口地址为PortAddress的端口写入值，值为al寄存器中的值</span><br>　　 <span class="hljs-comment">//out PortAddres,%al    把端口地址为PortAddress的端口中的值读入寄存器al中</span><br>        <span class="hljs-comment">//CPU与外部设备通讯时，通常是通过访问，修改设备控制器中的寄存器来实现的。那么这些位于设备控制器当中的寄存器也叫做IO端口。为了方便管理，80x86CPU采用IO端口单独编址的方式，即所有设备的端口都被命名到一个IO端口地址空间中。这个空间是独立于内存地址空间的。所以必须采用和访问内存的指令不一样的指令来访问端口。</span><br>        <br><span class="hljs-number">15.</span> <span class="hljs-number">0xfd16b</span>:  in  $<span class="hljs-number">0x92</span>, %al <span class="hljs-comment">// 这三个指令是使能第21根地址线，进入保护模式，但是进入bootloader会重回实模式</span><br><span class="hljs-number">16.</span> <span class="hljs-number">0xfd16d</span>:  or  $<span class="hljs-number">0x2</span>, %al<br><span class="hljs-number">17.</span> <span class="hljs-number">0xfd16f</span>:  out  %al, $<span class="hljs-number">0x92</span><br>    <br>   <span class="hljs-number">18.</span> <span class="hljs-number">0xfd171</span>:  lidtw  %cs:<span class="hljs-number">0x6ab8</span> <span class="hljs-comment">// lidt指令：加载中断向量表寄存器(IDTR)。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器(IDTR)中。</span><br>   <span class="hljs-number">19.</span> <span class="hljs-number">0xfd177</span>:  lgdtw  %cs:<span class="hljs-number">0x6a74</span> <span class="hljs-comment">//把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器中GDTR中。</span><br>       <br><span class="hljs-number">20.</span> <span class="hljs-number">0xfd17d</span>:  mov  %cr0, %eax<br><span class="hljs-number">21.</span> <span class="hljs-number">0xfd180</span>:  or  $<span class="hljs-number">0x1</span>, %eax<br><span class="hljs-number">22.</span> <span class="hljs-number">0xfd184</span>:  mov  %eax, %cr0<br>    <span class="hljs-comment">//计算机中包含CR0~CR3四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位(0bit)置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式之下，后面的boot loader开始的时候也是工作在实模式下，所以这里把它切换为保护模式，显然是自相矛盾。所以只能推测它在检测是否机器能工作在保护模式下。</span><br>    .......<br></code></pre></td></tr></table></figure>

<p>以上我们分析了BIOS程序，知道了他做了哪些事情，关闭中断、加载GDTR\IDTR寄存器、开启保护模式（进入bootloader是实模式）等等操作。</p>
<p><strong>但是BIOS最重要的操作还是将bootloader程序加载到内存（一般是0x7c00处，然后bios执行跳转指令就跳转到了boot loader中），然后跳转到它，并执行它去加载真正的操作系统程序</strong></p>
<blockquote>
<p> <strong>我们在反汇编文件中看的地址都是编译器链接的地址，并不是实际的物理地址，等到后面我们开启分页之后，就是虚拟地址了</strong></p>
<p>可以看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fatsheep9146/p/5220004.html">https://www.cnblogs.com/fatsheep9146/p/5220004.html</a></p>
</blockquote>
<h4 id="进入bootloader程序"><a href="#进入bootloader程序" class="headerlink" title="进入bootloader程序"></a>进入bootloader程序</h4><p>于PC来说，软盘，硬盘都可以被划分为一个个大小为512字节的区域，叫做扇区。一个扇区是一次磁盘操作的最小粒度。每一次读取或者写入操作都必须是一个或多个扇区。</p>
<p><strong>如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区</strong>。</p>
<p>这一部分介绍的boot loader程序就位于这个启动扇区之中。</p>
<p><strong>当BIOS找到一个可以启动的软盘或硬盘后，它就会把这512字节的启动扇区加载到内存地址<code>0x7c00~0x7dff</code>这个区域内。</strong> </p>
<blockquote>
<p><strong>那BIOS是怎么找到这个启动程序的呢？</strong>— BIOS会去加载0盘0扇道1扇区的扇区内容，但是它会先判断这个扇区末尾的两个字是不是魔数0x55和0xaa</p>
</blockquote>
<p>在这个实验中bootloader由两个文件组成，<strong>一个是boot.S汇编文件，一个是main.c C文件</strong>，最终他们都被编译成了一个boot.asm文件</p>
<p>那么bootloader做了哪些事情呢？</p>
<blockquote>
<p>我们下面使用gdb进行一步步的跟踪：我们把断点设置在<code>0x7c00处</code>，这个是BIOS将</p>
</blockquote>
<p>boot.s文件如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;inc/mmu.h&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The BIOS loads this code from the first sector of the hard disk into</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">memory at physical address 0x7c00 and starts executing <span class="hljs-keyword">in</span> real mode</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">with %cs=0 %ip=7c00.</span><br><br>.set PROT_MODE_CSEG, 0x8         # kernel code segment selector<br>.set PROT_MODE_DSEG, 0x10        # kernel data segment selector<br>.set CR0_PE_ON,      0x1         # protected mode enable flag<br><br>.globl start<br>start:<br>  .code16                     # Assemble for 16-bit mode<br>  cli                         # Disable interrupts                                              // 关闭所有中断<br>  cld                         # String operations increment<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Set up the important data segment registers (DS, ES, SS).          //将各种段寄存器清零</span><br>  xorw    %ax,%ax             # Segment number zero<br>  movw    %ax,%ds             # -&gt; Data Segment<br>  movw    %ax,%es             # -&gt; Extra Segment<br>  movw    %ax,%ss             # -&gt; Stack Segment<br><br>下面做的事情就是：<br>1. 打开A20地址线<br>2. 在gdtr寄存器中加载GTD的地址和界限<br>3. 设置cr0寄存器的PE位置为1<br>就进入了保护模式<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Enable A20:</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">  For backwards compatibility with the earliest PCs, physical</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">  address line 20 is tied low, so that addresses higher than</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">  1MB wrap around to zero by default.  This code undoes this.</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">我们可以看到其中的指令包括inb，outb这样的IO端口命令。</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash"> 所以这些指令都是在对外部设备进行操作</span><br>seta20.1:<br>  inb     $0x64,%al               # Wait for not busy<br>  testb   $0x2,%al<br>  jnz     seta20.1<br><br>  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64<br>  outb    %al,$0x64<br><br>seta20.2:<br>  inb     $0x64,%al               # Wait for not busy<br>  testb   $0x2,%al<br>  jnz     seta20.2<br><br>  movb    $0xdf,%al               # 0xdf -&gt; port 0x60         <br>  outb    %al,$0x60<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Switch from real to protected mode, using a bootstrap GDT</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">and segment translation that makes virtual addresses</span> <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">identical to their physical addresses, so that the</span> <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">effective memory map does not change during the switch.</span><br>  lgdt    gdtdesc                                                   # 这个gdtdesc在最下面，占6个字节，正好填充GPTR寄存器<br>  movl    %cr0, %eax                                           #cr0 是控制寄存器，可以用来打开保护模式<br>  orl     $CR0_PE_ON, %eax                                # 这里完成对PE位置1，打开保护模式<br>  movl    %eax, %cr0<br>  <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Jump to next instruction, but <span class="hljs-keyword">in</span> 32-bit code segment.</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Switches processor into 32-bit mode.</span><br>  ljmp    $PROT_MODE_CSEG, $protcseg <br><br>  .code32                     # Assemble for 32-bit mode<br>protcseg:<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Set up the protected-mode data segment registers</span><br>  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector<br>  movw    %ax, %ds                # -&gt; DS: Data Segment<br>  movw    %ax, %es                # -&gt; ES: Extra Segment<br>  movw    %ax, %fs                # -&gt; FS<br>  movw    %ax, %gs                # -&gt; GS<br>  movw    %ax, %ss                # -&gt; SS: Stack Segment<br>  <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Set up the stack pointer and call into C.   //设置栈的栈顶指针，就是0x7c00 ，因为栈是向下拓展的，所以选这个作为栈顶</span><br>  movl    $start, %esp<br>  call bootmain<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">If bootmain returns (it shouldn<span class="hljs-string">&#x27;t), loop.</span></span><br>spin:<br>  jmp spin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Bootstrap GDT</span></span><br>.p2align 2                                # force 4 byte alignment<br>gdt:<br>  SEG_NULL				# null seg                      这个是第0个段描述符，不设置任何东西<br>  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg   在这个位置设置代码段，每个段描述符是8个字节<br>  SEG(STA_W, 0x0, 0xffffffff)	        # data seg  在这个位置设置数据段<br><br>gdtdesc:  // 这个就是GDTR的描述符，共6个字节，2个字节表示gdt界限，4个字节表示gdt表的地址<br>  .word   0x17                            # sizeof(gdt) - 1   在这里放一个字(2字节)，就是gdt大小<br>  .long   gdt                             # address gdt       在这里放一个long字(4字节)，就是gdt的地址  总共占据6字节，<br>                                                               #后面把这个放到了gdtr寄存器中<br><br><br></code></pre></td></tr></table></figure>

<p>在上面<code> lgdt    gdtdesc</code>   经过反汇编是 <code>lgdtw 0x7c64</code></p>
<p><img src="/2022/10/18/mit-6.828/image-20230302200537118-167775873800015.png" srcset="/img/loading.gif" lazyload alt="image-20230302200537118"></p>
<p><img src="/2022/10/18/mit-6.828/image-20230302200603428.png" srcset="/img/loading.gif" lazyload alt="image-20230302200603428"></p>
<p>所以我们可以得到GDT表在哪里？在<code>0x7c4c</code>处,现在一共有3个段描述符，第一个是空的，第二个是code段，第三个是data段，就是上面boot.s文件里的最后面，后面两个段，我们根据段描述符分析，可以看出段基址都是0，段界限呢？</p>
<p><strong>首先我们要清楚，在<em>80386</em>保护模式下，段界限用<em>20</em>位表示，而且段界限可以是以字节为单位或以<em>4K</em>字节为单位。段属性中有一位对此进行定义，把该位成为粒度位，用符号<em>G</em>标记。<em>G=0</em>表示段界限以字节位位单位，于是<em>20</em>位的界限可表示的范围是<em>1</em>字节至<em>1M</em>字节，增量为<em>1</em>字节；<em>G=1</em>表示段界限以<em>4K</em>字节为单位，于是<em>20</em>位的界限可表示的范围是<em>4K</em>字节至<em>4G</em>字节，增量为<em>4K</em>字节。</strong></p>
<p>因为x86没有分段，所以段基址都是0，寻址范围都是4G</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"># Bootstrap GDT<br>.p2align <span class="hljs-number">2</span>                                <span class="hljs-meta"># force 4 byte alignment</span><br>gdt:<br>  SEG_NULL				<span class="hljs-meta"># null seg                      这个是第0个段描述符，不设置任何东西</span><br>  SEG(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)	<span class="hljs-meta"># code seg   在这个位置设置代码段，每个段描述符是8个字节</span><br>  SEG(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)	        <span class="hljs-meta"># data seg  在这个位置设置数据段</span><br><br>gdtdesc:  <span class="hljs-comment">// 这个就是GDTR的描述符，共6个字节，2个字节表示gdt界限，4个字节表示gdt表的地址</span><br>  .word   <span class="hljs-number">0x17</span>                            <span class="hljs-meta"># sizeof(gdt) - 1   在这里放一个字(2字节)，就是gdt大小</span><br>  .<span class="hljs-type">long</span>   gdt                             <span class="hljs-meta"># address gdt       在这里放一个long字(4字节)，就是gdt的地址  总共占据6字节，</span><br>                                                               #后面把这个放到了gdtr寄存器中<br></code></pre></td></tr></table></figure>

<p><strong>然后执行完段描述符设置后，对PE的bit0位置设1，打开保护模式，然后执行ljmp命令，更新cs寄存器的值，跳转程序。</strong>也就是下面这个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"># Jump to next instruction, but in <span class="hljs-number">32</span>-bit code segment.<br># Switches processor into <span class="hljs-number">32</span>-bit mode.<br>ljmp    $PROT_MODE_CSEG, $protcseg <br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>为什么要使用ljmp指令呢？可以看《操作系统真相还原》p172的4.5节</strong></p>
</blockquote>
<p>下面继续执行指令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">protcseg:<br>  # Set up the protected-mode data segment registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector<br>  movw    %ax, %ds                # -&gt; DS: Data Segment<br>  movw    %ax, %es                # -&gt; ES: Extra Segment<br>  movw    %ax, %fs                # -&gt; FS<br>  movw    %ax, %gs                # -&gt; GS<br>  movw    %ax, %ss                # -&gt; SS: Stack Segment<br>  <br>  # Set up the <span class="hljs-built_in">stack</span> pointer and call into C.   <span class="hljs-comment">//设置栈的栈顶指针，就是0x7c00 ，因为栈是向下拓展的，所以选这个作为栈顶</span><br>  movl    $start, %esp<br>  call bootmain<br><br>  # If bootmain <span class="hljs-title function_">returns</span> <span class="hljs-params">(it shouldn<span class="hljs-string">&#x27;t), loop.</span></span><br><span class="hljs-string"><span class="hljs-params">spin:</span></span><br><span class="hljs-string"><span class="hljs-params">  jmp spin</span></span><br></code></pre></td></tr></table></figure>

<p><code>  movl    $start, %esp   call bootmain</code></p>
<p>这两句发生了什么事情：</p>
<p><strong>首先我们要知道esp指针就是指向当前栈的顶端的指针，这个指令就是</strong>设置esp指向0x7c00处<strong>，也就是boot loader程序下面，因为栈是向下扩展的，所以选择这里</strong>，</p>
<p><strong>然后调用main函数，也就是main.c文件中的main函数，至此进入main.c文件</strong>，上面按个栈就是main函数的栈，用来存储一些变量</p>
<blockquote>
<p>接下来我们开始分析main.c函数</p>
</blockquote>
<p>在这之前我们先介绍以下elf文件，这个是文件编译链接之后的文件</p>
<p>elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p>
<p><img src="/2022/10/18/mit-6.828/resize,m_lfit,w_268,limit_1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nirendao/article/details/123883856">https://blog.csdn.net/nirendao/article/details/123883856</a> （elf文件图解）</p>
<ul>
<li>一个 ELF 文件格式的可执行程序的加载运行过程是这样的：<br>通过读取 ELF 头表中的信息了解该可执行程序是否可以运行（版本号，适用的计算机架构等等）<br>通过 ELF 头表中的信息找到程序头表<br>通过读取 ELF 文件中程序头表的信息了解可执行文件中各个段的位置以及加载方式</li>
</ul>
<blockquote>
<p>下面开始分析程序</p>
</blockquote>
<p><strong>内核就是一个elf文件</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELFHDR		((struct Elf *) 0x10000) <span class="hljs-comment">// scratch space</span></span><br><span class="hljs-comment">// read 1st page off disk</span><br><span class="hljs-number">1</span> readseg((<span class="hljs-type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">// read 1st page off disk</span><br>	<span class="hljs-comment">// 512b * 8 = 4kb = 1 page</span><br>	<span class="hljs-comment">//这个完成了将内核文件（ELF格式的文件）的前 4096（1 page）个字节读进到0x10000处</span><br><span class="hljs-comment">// 其实就是将elf header读进了内存，位置是0x10000处</span><br><span class="hljs-comment">// 然后接下来对这个elf header进行分析，获取每个program header</span><br><span class="hljs-comment">// 每个程序头可以知道每个程序的位置和加载方式</span><br><span class="hljs-comment">// 然后把每个program header对应的段加载进来</span><br></code></pre></td></tr></table></figure>

<p><strong>上面这个就是读取了4080字节的磁盘内容到内存中，位置就是0x10000处，这个内容包含了elf header 和program header table</strong></p>
<p>我们用<code>readelf -l kernel</code> 命令可以查看内核elf文件</p>
<p><img src="/2022/10/18/mit-6.828/image-20230302220553389-167776595437619.png" srcset="/img/loading.gif" lazyload alt="image-20230302220553389"></p>
<p>先检查是不是elf文件</p>
<p>然后将<strong>每个program header对应的内核程序</strong>读进来，**==内核程序放在了0x100000上==**</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// is this a valid ELF?                                      先检查是不是elf文件</span><br>	<span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)<br>		<span class="hljs-keyword">goto</span> bad;<br><br>	<span class="hljs-comment">// load each program segment (ignores ph flags)</span><br>	<span class="hljs-comment">//ELFHDR-&gt;e_phoff这个代表的是第一个程序头在elf文件内的偏移量</span><br>	<span class="hljs-comment">//ph此时就代表指向了第一个程序头在内存中的位置</span><br>	ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);<br>	<span class="hljs-comment">//ELFHDR-&gt;e_phnum表示有几个程序头，eph指向最后一个程序头；</span><br>	eph = ph + ELFHDR-&gt;e_phnum;<br>	<span class="hljs-keyword">for</span> (; ph &lt; eph; ph++) &#123;<br>	<span class="hljs-comment">//开始加载每个程序段      也就是内核程序段和数据段等内容</span><br>		<span class="hljs-comment">// p_pa is the load address of this segment (as well</span><br>		<span class="hljs-comment">// as the physical address)</span><br>		<span class="hljs-comment">//ph-&gt;p_offset表示在文件内的偏移字节数，ph-&gt;p_memsz表示在内存中的大小，ph-&gt;p_pa表示在内存中的地址</span><br>		<span class="hljs-comment">// 第一个段 p_pa == 0x100000      p_memsz = 0x7c96 p_offset = 0x1000 正好对应的4096开始，和刚才elf header读进来后面的保持一致 </span><br>		readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);<br>		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ph-&gt;p_memsz - ph-&gt;p_filesz; i++) &#123;<br>			*((<span class="hljs-type">char</span> *) ph-&gt;p_pa + ph-&gt;p_filesz + i) = <span class="hljs-number">0</span>;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><strong>上面将内核程序都读进来了，下面开始进入真正的内核程序了。</strong></p>
<p><strong>接下来就很重要了</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// call the entry point from the ELF header</span><br>	<span class="hljs-comment">// note: does not return!</span><br>	<span class="hljs-comment">//ELFHDR-&gt;e_entry表示程序（内核程序）的入口地址，段的加载地址是0x100000 ,程序的起始地址在0x10000c</span><br>	<span class="hljs-comment">//以上的都是bootloader程序，还没有开启虚拟地址，等下会进入内核程序，进入之后，指令的寻址方式都是采用的虚拟地址，</span><br>	<span class="hljs-comment">//内核程序在编址的时候设置的起始地址是0xf0100000  也就是4G内存下的256M空间</span><br>	((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) (ELFHDR-&gt;e_entry))(); <span class="hljs-comment">// 汇编指令是 call   *0x10018   // *代表取出0x10018中的内容（0x10000c）， call然后跳转</span><br>  <span class="hljs-number">0x10018</span>是在elf header中，这个位置对应的就是第一个程序的入口地址（ELFHDR-&gt;e_entry）<br></code></pre></td></tr></table></figure>

<p><strong>e_entry字段指向的是这个文件的执行入口地址，也就是真正的内核程序，call指令就是跳转过去执行。 自此就把控制权从boot loader转交给了操作系统的内核。</strong></p>
<h4 id="进入真正的内核程序"><a href="#进入真正的内核程序" class="headerlink" title="进入真正的内核程序"></a>进入真正的内核程序</h4><p>我们先看看这个内核程序在哪（上面我们说了在0x100000）,执行下面的指令，发现确实正确，但是我们注意一下，VMA（链接地址）是f0100000这个其实就是编译器链接的地址，<strong>其实可以理解成虚拟地址</strong>，后面的LMA才是真正的物理地址</p>
<p><img src="/2022/10/18/mit-6.828/image-20230303171954183.png" srcset="/img/loading.gif" lazyload alt="image-20230303171954183"></p>
<p><strong>objdump -x obj/kern/kernel</strong>可以查看Program header table</p>
<p><img src="/2022/10/18/mit-6.828/809277-20160225131553240-877979384.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>其中Program Header中列出的是所有被加载到内存中的段的信息，这也是Program Headers Table的表项。每一个表项图中都把这个表项中涉及到的所有字段都列出来了。可见有一些段最后没有被加入到内存之中。在上图中，那些需要被加载到内存的段被标记为LOAD。</p>
<p>我们之前知道了bootloader程序的链接地址和物理地址都是在0x7c00.</p>
<blockquote>
<p>下面我们开始分析真正的内核程序，在entry.S文件中</p>
</blockquote>
<blockquote>
<p><strong>但是我们先了解一下什么是虚拟地址和物理地址以及分页分段概念</strong></p>
</blockquote>
<h5 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h5><p><strong>操作系统内核程序在虚拟地址空间通常会被链接到一个非常高的虚拟地址空间处，比如0xf0100000，目的就是能够让处理器的虚拟地址空间的低地址部分能够被用户利用来进行编程。</strong></p>
<p>但是许多的机器其实并没有能够支持0xf0100000这种地址那么大的物理内存，所以我们不能把内核的0xf0100000虚拟地址映射到物理地址0xf0100000的存储单元处。</p>
<p>　　这就造成了一个问题，在我们编程时，我们应该把操作系统放在高地址处，但是在实际的计算机内存中却没有那么高的地址，这该怎么办？</p>
<p>　　解决方案就是在虚拟地址空间中，我们还是把操作系统放在高地址处0xf0100000，但是在实际的内存中我们把操作系统存放在一个低的物理地址空间处，如0x00100000。那么当用户程序想访问一个操作系统内核的指令时，首先给出的是一个高的虚拟地址，然后计算机中通过某个机构把这个虚拟地址映射为真实的物理地址，这样就解决了上述的问题。那么这种机构通常是通过分段管理，分页管理来实现的。</p>
<blockquote>
<p>分段模式</p>
</blockquote>
<p>分段模式下没有虚拟地址一说，就是每个程序的段基本上都是放在一起的，然后此时进程A和进程B记忆进程C正在内存中运行，这个时候进程C关掉了，就会释放占用的内存，假如在A和B之间，此时D想要进来，但是D的大小比C大就无法利用刚才的内存，只能等待更多的空间，这就造成了浪费。</p>
<p><img src="/2022/10/18/mit-6.828/image-20230303211137237-167784909884623.png" srcset="/img/loading.gif" lazyload alt="image-20230303211137237"></p>
<p>分段模式下如何访问地址的：</p>
<p>首先是先通过段选择子找到段描述符（在GDT中），在段的描述符中存着段基址，然后段基址加上段内偏移地址就能够找到物理地址了</p>
<img src="/2022/10/18/mit-6.828/image-20230303212017076-167784961861625.png" srcset="/img/loading.gif" lazyload alt="image-20230303212017076" style="zoom:50%;">



<blockquote>
<p>分页模式</p>
</blockquote>
<p>通过将内存空间分成一个个的page，每个page是一个4096字节的空间，然后如果加载一个进程，就将这个进程放在不同的分散的各个页当中，然后通过一个页表记录虚拟地址和物理地址的映射关系。</p>
<p><img src="/2022/10/18/mit-6.828/image-20230303215129867-167785149089327.png" srcset="/img/loading.gif" lazyload alt="image-20230303215129867"></p>
<p><strong>在页表中，每个地址大小都是占4个字节，32为，因为每一个页大小是4092字节，所以地址的后12位都是0，这个12位用来作为这个页的访问权限，比如页读写的权限等。</strong></p>
<p><img src="/2022/10/18/mit-6.828/image-20230307133653843.png" srcset="/img/loading.gif" lazyload alt="image-20230307133653843"></p>
<p>那个页表寄存器是CR3寄存器，存着页目录表的地址（物理地址）。</p>
<p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p>
<p>开启分页模式步骤：</p>
<ul>
<li>先准备好页目录表和页表</li>
<li>将页目录表的地址写入到控制寄存器cr3寄存器中</li>
<li>寄存器cr0的PG位置1</li>
</ul>
<blockquote>
<p>每个进程都有自己的页目录表和页表，操作系统也有自己的页目录表和页表</p>
</blockquote>
<h5 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h5><p>位于entry.s文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 取出页目录表的地址，并放进cr3寄存器中 这个时候我们就设定好了页目录表</span><br>	movl	$(RELOC(entry_pgdir)), %eax      <span class="hljs-comment">#  entry_pgdir在0xf0111000</span><br>	movl	%eax, %cr3<br>	<span class="hljs-comment"># Turn on paging. </span><br>	<span class="hljs-comment"># 开启分页模式，这个时候指令的地址都是虚拟地址了，需要进行映射，映射的过程交给MMU来完成，</span><br>	<span class="hljs-comment"># 因为我们已经设置好了页目录表和页表，并把页目录表的地址给了cr03，MMU会自动将寻址时的地址转化为对应的物理地址，然后交给总线去寻址</span><br>	movl	%cr0, %eax  <br>	orl	$(CR0_PE|CR0_PG|CR0_WP), %eax <span class="hljs-comment"># 给寄存器cr0的PG位置置1</span><br>	movl	%eax, %cr0<br><br>	<span class="hljs-comment"># Now paging is enabled, but we&#x27;re still running at a low EIP</span><br>	<span class="hljs-comment"># (why is this okay?).  Jump up above KERNBASE before entering</span><br>	<span class="hljs-comment"># C code.</span><br>	mov	<span class="hljs-variable">$relocated</span>, %eax<br>	jmp	*%eax<br></code></pre></td></tr></table></figure>

<p>页目录表和页表我们已经设置好了，以两个数组设置完成的</p>
<p>获取页目录表的地址，并存入到cr3寄存器中，然后给cr0 PG位置1</p>
<p>这样就开启了正在页表，进入分页模式</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">relocated:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">从这里开始我们就正式进入了分页模式</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">Clear the frame pointer register (EBP)</span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">so that once we get into debugging C code,</span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">stack backtraces will be terminated properly.</span><br>	movl	$0x0,%ebp			# nuke frame pointer  为什么将栈基址设置位0<br><span class="hljs-meta prompt_">	# </span><span class="language-bash">Set the stack pointer</span> <br><span class="hljs-meta prompt_">	# </span><span class="language-bash">通过反汇编我们知道 0xf0110000 是栈顶</span><br>	movl	$(bootstacktop),%esp    # 栈顶地址设置完成<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">从这里我们就进入了C语言代码</span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">now to C code</span><br>	call	i386_init<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">	# </span><span class="language-bash">Should never get here, but <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span> we <span class="hljs-keyword">do</span>, just spin.</span><br>spin:	jmp	spin<br><br><br>.data<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">boot stack</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################################################################</span></span><br>	.p2align	PGSHIFT		# force page alignment<br>	.globl		bootstack<br>bootstack:<br>	.space		KSTKSIZE  # 分配4096字节<br>	.globl		bootstacktop   <br>bootstacktop:<br></code></pre></td></tr></table></figure>

<p>上面是对内核栈的初始化：</p>
<p><strong>内核在哪里初始化它的栈，栈在内存的什么地方？内核是怎样给栈保存空间的？栈初始指针是指向保留区域的哪一端？</strong></p>
<p>在entry.s 的数据段中.space size表示生成size个字节，说明内核给栈保存了KSTKSIZE的空间，由宏定义#define KSTKSIZE (8*PGSIZE)和#define PGSIZE 4096可知该空间大小为32k</p>
<p>由于栈由高地址向低地址生长，所以指针指向高地址0xf0110000那一端</p>
<h5 id="entry-s做了哪些事情"><a href="#entry-s做了哪些事情" class="headerlink" title="entry.s做了哪些事情"></a>entry.s做了哪些事情</h5><ul>
<li><p><strong>开启了分页模式</strong>    #  entry_pgdir在0xf0111000（物理地址0x111000），页表不知道在哪</p>
</li>
<li><p><strong>初始化了内核的栈</strong> # 栈顶的位置在0xf0110000）（物理地址0x110000）</p>
</li>
</ul>
<h4 id="进入init-c"><a href="#进入init-c" class="headerlink" title="进入init.c"></a>进入init.c</h4><blockquote>
<p>首先是初始化一些设备，用来实现printf函数</p>
</blockquote>
<p><img src="/2022/10/18/mit-6.828/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc2MTQ3OA==,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>基本流程：</p>
<p>kern/monitor.c的作用是实现内核与用户的交互。阅读monitor.c，发现它是直接调用printf.c中的cprintf（）来在屏幕上输出，接下来的调用顺序是：cprintf()-&gt;vcprintf（）-&gt;printfmt.c中的vprintfmt（）-&gt;printf.c中的putch()-&gt;console.c中的cputchar()-&gt;cons_putc（）。由注释知最后这个cons_putc()函数的作用是输出一个字符到控制台。</p>
<h5 id="分析方法调用的时候入栈和出栈的流程"><a href="#分析方法调用的时候入栈和出栈的流程" class="headerlink" title="分析方法调用的时候入栈和出栈的流程"></a><strong>分析方法调用的时候入栈和出栈的流程</strong></h5><blockquote>
<p>首先先介绍两个寄存器 esp 和 ebp</p>
</blockquote>
<p><strong>X86堆栈指针寄存器（%esp）</strong>指向的是整个堆栈中正在被使用的部分的最低地址。在这个地址之下的更低的地址空间都是还没有被利用的堆栈空间。当计算机要完成把一个值压入堆栈的动作时，通常它需要先把堆栈指针寄存器中的值减1（有时候是减4，由机器字长决定），然后把需要压入的值存放到当前堆栈指针寄存器所指向的新的内存单元。而从堆栈中弹出一个值的操作，则需要计算机首先从堆栈寄存器所指向的内存单元读取一个数据，然后把堆栈寄存器的值加1（有时候是加4）。在32bit模式下，每一次对堆栈的操作都是以32bit为单位的，所以%esp中的值永远都是可以被4整除的。</p>
<p><strong>而ebp寄存器</strong>则是记录每一个程序的栈帧的相关信息的一个非常重要的寄存器。他可以理解为每一个栈帧的边界，ebp到esp之间的空间就是代表着当前栈帧（这个函数）的占用的空间，用来存放一些临时变量、调用其他函数的参数、以及其他函数执行完后的返回地址等。假如我们想调用一个函数（<strong>会执行call等指令</strong>），那么先做的事情就是将被调用函数的参数从右往左以此压入栈中，然后再压入被调用函数指向完后的返回地址，然后再把自己这个栈帧的ebp内容存放到栈中，然后更新ebp值为esp的值，这样就进入了下一个栈帧，就可以存放被调用函数运行时的局部变量等。</p>
<p>当函数执行完成之后（<strong>会调用ret等指令</strong>），他会将ebp的值传入到esp中（相当于指向ebp指向的地址了，这个ebp指向的地址内容是上一个栈帧的ebp旧值），这样就相当于释放了栈帧，然后再把ebp恢复为原来的</p>
<p>值，这样就恢复了原来函数的栈帧（ebp恢复了），然后再获取返回的地址，让eip寄存器指向原来调用函数的地方继续执行。</p>
<p><img src="/2022/10/18/mit-6.828/809277-20160229215738095-1864590140.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2022/10/18/mit-6.828/lab1_5_gcc%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A82.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>以下是函数执行的细节</strong>：</p>
<blockquote>
<ol>
<li>执行call指令前，<strong>函数调用者</strong>将参数入栈，按照<strong>函数列表从右到左</strong>的顺序入栈</li>
<li>call指令会自动将当前eip入栈，ret指令将自动从栈中弹出该值到eip寄存器</li>
<li><strong>被调用函数</strong>负责：将ebp入栈，esp的值赋给ebp（进入函数时）。所以反汇编一个函数会发现开头两个指令都是<code>push %ebp, mov %esp,%ebp</code>。 将ebp的值赋值给esp，将ebp赋值为原来的值（出函数时）。就是上面那两个青色图，都是由被调用函数负责。</li>
</ol>
</blockquote>
<h5 id="最终内存"><a href="#最终内存" class="headerlink" title="最终内存"></a>最终内存</h5><blockquote>
<p>0xffffffff|4GB<br>———-|32-bit memory mapped devices<br>0xf0110000|bootstacktop<br>0xf0100c04|debuginfo_eip<br>0xf0100b00|cprintf                      ==&gt; 内核代码<br>0xf0100ac9|vcprintf<br>0xf0100883|mon_backtrace<br>0xf01000a6|i386_init<br>0xf0100040|test_backtrace<br>0xf010000c|entry kernel<br>0x00100000|<strong>开始加载内核</strong><br>———-|<br>0x000F0000|BIOS ROM<br>———-|16-bit expansion ROMs<br>0x000C0000|<br>0x000A0000|VGA Display<br>———-|<br>0x00007d6b|<strong>准备将控制权交给内核</strong><br>0x00007c45|调用bootmain                 ==&gt; Low Memory  这里是boot loader引导程序<br>0x00007c2d|处理器切换为32-bit模式<br>0x00007c00|boot开始的位置<br>———-|<br>0x00000000|0</p>
</blockquote>
<p>lab1到这里就基本结束了。</p>
<h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>经历过lab1之后我们的物理内存分配大概是怎么样的？</p>
<p><img src="/2022/10/18/mit-6.828/20160519183449981.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2022/10/18/mit-6.828/image-20230304163216000-167791873698139.png" srcset="/img/loading.gif" lazyload alt="image-20230304163216000"></p>
<blockquote>
<p>本实验要讲述的内容：</p>
</blockquote>
<p>第一个是物理内存管理，就是我们现在找到这个物理内存有多大，然后哪些物理内存是使用过的，哪些内存没有被使用。</p>
<p>第二是实现虚拟内存和物理内存的映射（也就是建立页表映射关系），实现一些函数操作页目录表和页表实现虚拟内存和物理内存之间的映射</p>
<p>第三部分讲的是内核的地址空间，将内核的虚拟地址映射到指定的物理地址上</p>
<h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><blockquote>
<p>空闲的物理内存如何管理的</p>
</blockquote>
<p>本文通过的是一个PageInfo[]数组来记录整个内存空间，（每一个代表一个page，按照顺序逐一对应）每个PageInfo相当于一个链表的节点，通过将代表的空闲的PageInfo给连接到一起构造一个链表，然后链表的头记录在一个特殊的节点上page_free_list，每次想要分配页，就从这个链表上取走一个节点，如果使用完毕，将那个页对应的pageInfo节点插入到这个链表中。</p>
<p>每一个pageInfo的内容是一个指向下一个节点的指针和一个引用该对应页面的个数。这个数组存放在哪里呢？<strong>在内核程序结束后再隔一个页目录表大小的地方</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pages = (<span class="hljs-keyword">struct</span> PageInfo*)boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages);	<span class="hljs-comment">//分配足够大的空间(PGSIZE的倍数)保存pages数组</span><br></code></pre></td></tr></table></figure>

<p>然后我们初始化这个链表使用page_init()函数：</p>
<ul>
<li><strong>就是将basemem空间和extmem空间的空闲的page给构建一个链表</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> i;<br>	<span class="hljs-type">size_t</span> io_hole_start_page = (<span class="hljs-type">size_t</span>)IOPHYSMEM / PGSIZE;<br>	<span class="hljs-type">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;	<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<br>		<span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>			pages[i].pp_ref = <span class="hljs-number">1</span>;<br>			pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= io_hole_start_page &amp;&amp; i &lt; kernel_end_page) &#123;<br>			pages[i].pp_ref = <span class="hljs-number">1</span>;<br>			pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>		&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == MPENTRY_PADDR / PGSIZE) &#123;<br>			<span class="hljs-comment">//之所以在这判断一下，是因为后面多处理器的APs启动时的程序要放在这里，所以要把这里标志使用，防止后面被分配走</span><br>			pages[i].pp_ref = <span class="hljs-number">1</span>;<br>			pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>			pages[i].pp_ref = <span class="hljs-number">0</span>;<br>			pages[i].pp_link = page_free_list;<br>			page_free_list = &amp;pages[i];<br>		&#125;<br>		<br>	&#125;<br></code></pre></td></tr></table></figure>



<h3 id="页目录表和页表设置"><a href="#页目录表和页表设置" class="headerlink" title="页目录表和页表设置"></a>页目录表和页表设置</h3><p>我们在前面已经知道了，我们设置了页目录表entry_pgdir和页表，但是这个页表我们只是映射了从KERNBASE之上的4M空间到物理地址的0-4M空间，这明显是不够的，我们需要重新进行映射。</p>
<p>我们重新申请一个页作为页目录表，<strong>如下,它紧跟在内核程序存放位置之后。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">kern_pgdir = (<span class="hljs-type">pde_t</span> *) boot_alloc(PGSIZE); <span class="hljs-comment">// 这个紧跟着操作系统内核之后，但是返回的是虚拟地址</span><br></code></pre></td></tr></table></figure>



<h4 id="如何完成虚拟地址到内存地址的映射"><a href="#如何完成虚拟地址到内存地址的映射" class="headerlink" title="如何完成虚拟地址到内存地址的映射"></a>如何完成虚拟地址到内存地址的映射</h4><blockquote>
<p><code>struct PageInfo * page_alloc(int alloc_flags)</code></p>
</blockquote>
<p>这个函数主要是从空闲链表中分配一个空闲页</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从空闲链表中拿出一个页并初始化页内容都是&#x27;\0&#x27;</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-keyword">if</span>(page_free_list == <span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>	&#125;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">temp</span>;</span><br>	temp = page_free_list;<br>	page_free_list = page_free_list-&gt;pp_link;<br>	temp-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;<br>		<span class="hljs-comment">//获取虚拟地址?</span><br>		<span class="hljs-type">void</span> *va = page2kva(temp);<br>		<span class="hljs-built_in">memset</span>(va,<span class="hljs-string">&#x27;\0&#x27;</span>,PGSIZE);<br>	&#125;<br>	<span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><code>void page_free(struct PageInfo *pp)</code></p>
</blockquote>
<p><strong>这个方法就是释放某一个页，把这个页对应的pageInfo放入到空闲链表中</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置这个页为空闲页</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br>	<span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br>	<span class="hljs-keyword">if</span>(pp-&gt;pp_link !=<span class="hljs-literal">NULL</span> || pp-&gt;pp_ref !=<span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;page_free() : pp-pp_ref is nonzone or pp-&gt;_link is not NULL&quot;</span>);<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		pp-&gt;pp_link = page_free_list;<br>		page_free_list = pp;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p><code>pte_t * pgdir_walk(pde_t *pgdir, const void *va, int create)</code></p>
</blockquote>
<p>先介绍以下pgdir_walk函数，<strong>这个函数会查找这个va虚拟地址对应的页表（没有页表会创建一个页表），然后返回这个虚拟地址对应的页表项。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这个函数返回的是一个页表项的地址</span><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-type">uint32_t</span> pdx = PDX(va); <span class="hljs-comment">//获取页目录项的索引</span><br>	<span class="hljs-type">uint32_t</span> ptx = PTX(va); <span class="hljs-comment">//获取也表项的索引</span><br><br>	<span class="hljs-type">pde_t</span> *pde;	<span class="hljs-comment">//页目录项指针</span><br>	<span class="hljs-type">pte_t</span> *pte; <span class="hljs-comment">//页表指针</span><br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span> <span class="hljs-comment">//空闲页面指针，如果不存在页表，会申请一个page</span><br><br>	<span class="hljs-comment">//获取页目录项</span><br>	pde = &amp;pgdir[pdx];<br>	<span class="hljs-comment">//每个页表项或者页目录项的低12位是用来做标志位的，PTE_P表示这个项是否存在</span><br>	<span class="hljs-keyword">if</span>((*pde) &amp; PTE_P)&#123;<br>		<span class="hljs-comment">//二级页表存在</span><br>		<span class="hljs-comment">//因为页目录项和页表项中的存的地址都是物理地址，所以需要进行转换成虚拟地址</span><br>		<span class="hljs-comment">//获取页表的地址</span><br>		pte = (KADDR(PTE_ADDR(*pde)));<br>	&#125;<span class="hljs-keyword">else</span>&#123;<br>		<span class="hljs-comment">//二级页表不存在</span><br>		<span class="hljs-keyword">if</span>(create ==<span class="hljs-literal">false</span>)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		&#125;<br>		<span class="hljs-comment">//我们需要申请一个空闲页作为二级页表，并把这个页的地址放进页目录项中</span><br>		pp = page_alloc(ALLOC_ZERO);<br>		<span class="hljs-keyword">if</span>(pp ==<span class="hljs-literal">NULL</span>)&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>		&#125;<br>		<span class="hljs-comment">//pte 表示指向的新申请的页的虚拟地址，并将这个页作为页表，把地址放进页目录表中</span><br>		pte = (<span class="hljs-type">pte_t</span> *)page2kva(pp);<br>		pp-&gt;pp_ref++;<br>		*pde = (PADDR(pte) | PTE_P | PTE_W | PTE_U);  <span class="hljs-comment">// 设置页目录项</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> &amp;pte[ptx];<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)</code></p>
</blockquote>
<p>然后我们就介绍一下这个page_insert函数，这个函数就是将一个物理page映射到一个虚拟页，并将映射关系放在页表中。</p>
<p>主要步骤：</p>
<ul>
<li>先获取这个虚拟地址va对应的页表项，如果这个页表项中没有指定的物理页，那么就把这个物理页的地址插入到这个页表项中</li>
<li>如果有之前对应的物理页地址，那么解除之前的物理页对应关系（<strong>并把那个页面个释放了–先判断页的引用是不是0了，这个和智能指针那一块比较像</strong>），这里调用了page_remove（pgdir，va）<ul>
<li><strong>找到这个虚拟地址对应的之前的页，然后把这页的内容清空</strong></li>
<li><strong>然后把这个页放入到空闲链表中去</strong></li>
</ul>
</li>
<li>然后把要插入的页的地址放进去</li>
<li>权限都别忘记修改了</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个函数就是将一个页指定映射到指定的虚拟地址（或者说找到一个页，这个页用来映射指定的虚拟地址）</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-comment">//先获取这个页表项，看看页表项中是否存在PTE_P</span><br>	<span class="hljs-type">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="hljs-literal">true</span>);<br>	<span class="hljs-keyword">if</span>(pte ==<span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> -E_NO_MEM;<br>	&#125;<br>	<br>	<span class="hljs-keyword">if</span>((*pte) &amp; PTE_P)&#123;<br>		<span class="hljs-comment">//说明这个页存在,先看看是不是和pp表示的同一个页面。如果不是就清除，是的就不清除,改改权限就行</span><br><br>		<span class="hljs-comment">//如果恰好pp这个页面就是此时pte指向的，那么修改一下权限就行了</span><br>		<span class="hljs-keyword">if</span>(PTE_ADDR(*pte) == page2pa(pp))&#123;<br>			pp-&gt;pp_ref--;<br>		&#125;<span class="hljs-keyword">else</span>&#123;<br>			page_remove(pgdir,va);<br>		&#125;<br>		<span class="hljs-comment">// page_remove(pgdir,va);</span><br>	&#125;<br>	<span class="hljs-comment">//说明还没有分配，就将pp代表的页给他</span><br>	*pte = (page2pa(pp) | perm |PTE_P);<br>	pp-&gt;pp_ref++;<br>	pgdir[PDX(va)] |= perm; <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><code>static void  boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</code></p>
</blockquote>
<p>这个方法主要是在页表中物理地址pa和虚拟地址va之间的映射关系，大小是size字节的空间</p>
<p>主要在内核启动的时候，映射了几块地址：</p>
<ol>
<li><p><code>boot_map_region(kern_pgdir,UPAGES,PTSIZE,PADDR(pages),PTE_U);</code>将PADDR(pages)起始的物理内存映射到UPAGES虚拟地址处，<strong>方便内核程序能够直接通过UPAGES虚拟地址就获取到了pages地址内存了，也就是说编写程序的时候我们直接操作UPAGES就相当于操作pages了</strong></p>
</li>
<li><p><code>boot_map_region(kern_pgdir,UENVS,PTSIZE,PADDR(envs),PTE_U);</code></p>
</li>
<li><p><code>boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W);</code></p>
<p>将物理地址PADDR(bootstack)处的物理地址映射到KSTACKTOP-KSTKSIZE虚拟地址处，这个内核栈在物理地址处的位置在entry.s文件中就确定了，然后为了后面能够方便操作这个栈，我们就将虚拟地址KSTACKTOP-KSTKSIZE映射到这个地方，然后直接在程序中使用这个虚拟地址就可以操作栈了</p>
<p><strong>之前我们在entry.s中有一个页表，这个页表将内核栈虚拟地址（0xf0110000）映射到了物理地址（0x110000）处，也就是esp的值就是0xf0110000（经过entry.s的页表转换后就变成了0x110000）了，现在我们重新有了一个页表kern_pgdir，然后为了规定虚拟地址0xf0000000下的虚拟地址空间作为内核栈，但是物理地址还是之前的那个栈，所以就重新设定了虚拟地址和物理地址的关系（因为可能在接下来的编程中对栈的操作（编译后的地址）都是采用的新的虚拟地址，而不是之前的0xf0110000了）</strong></p>
</li>
<li><p><strong><code>boot_map_region(kern_pgdir,KERNBASE,0xffffffff - KERNBASE,0,PTE_W);</code></strong></p>
<p>这个是完成对内核空间的映射，虚拟地址KERNBASE以上的地址都是给内核程序用的，就是编译器会将内核的程序地址都链接到这个地址以上，然后这个地址对应的物理地址是0-0xffffffff - KERNBASE（0-256M）空间。</p>
<blockquote>
<p>【注意】：我们通过npages知道了这个qemu总共的物理内存是128MB，而这个内核程序虚拟地址就占用了256MB，这个为什么，那岂不是连内核用的程序都不够了？</p>
<p>我们要注意，下面这函数虽然是将KERNBASE以上的256MB映射到了物理地址上，但是这个映射关系只是存在了页表中，并没有将对应的pageinfo的ref字段给增加（并没有将空闲链表上的pageinfo都给取下来了），所以这个只是映射了静态的地址关系，主要目的就是方便通过虚拟地址找到一些物理空间，之前使用过的空间，比如kernbase程序，pages等占用 pageinfo都给拿掉了，这个才是维护真正的物理空间（也只有page_insert才会从pageinfo中拿空闲的，然后把物理地址和内存地址的关系放在页表中）。</p>
</blockquote>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个方法是将UTOP上面的区域都映射到了指定的区域，直接定死了</span><br><span class="hljs-comment">// 完成虚拟地址到物理地址的映射（也就是把虚拟地址和物理地址的映射关系存在页表中）</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// Fill this function in</span><br>	<span class="hljs-comment">//获取页表项的地址</span><br>	<span class="hljs-type">pte_t</span> *pte =<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i= i + PGSIZE)&#123;<br>		<span class="hljs-comment">//根据这个虚拟地址，获取页表项地址，如果不存在或者超过了一个页表的大小，会重新创建</span><br>		pte = pgdir_walk(pgdir,(<span class="hljs-type">void</span> *)va,<span class="hljs-literal">true</span>);<br>		<span class="hljs-comment">//给页表项赋映射的地址</span><br>		*pte = (pa|perm|PTE_P); <span class="hljs-comment">//PTE_P表示存在，perm表示访问页面的权限，因为低12位是用来作为标志位的，高20位用来做地址</span><br>		pa += PGSIZE;<br>		va += PGSIZE;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="内存布局与映射关系"><a href="#内存布局与映射关系" class="headerlink" title="内存布局与映射关系"></a>内存布局与映射关系</h4><p>JOS将线性地址空间分为两部分，由定义在inc/memlayout.h中的ULIM分割。ULIM以上的部分用户没有权限访问，内核有读写权限。</p>
<p><img src="/2022/10/18/mit-6.828/lab2_5_lab2%E5%90%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84.png" srcset="/img/loading.gif" lazyload alt="内核虚拟地址空间到物理地址空间映射"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.提供管理物理内存的函数和数据结构：</p>
<p><img src="/2022/10/18/mit-6.828/lab2_7_%E6%80%BB%E7%BB%93_%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="JOS物理内存管理"></p>
<p>2.提供一个页表完成对虚拟地址和物理地址之间的映射</p>
<p><img src="/2022/10/18/mit-6.828/lab2_8_%E6%80%BB%E7%BB%93_%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0.png" srcset="/img/loading.gif" lazyload alt="JOS页表管理"></p>
<p>3.映射内核的线性地址空间到物理地址空间</p>
<p><img src="/2022/10/18/mit-6.828/lab2_5_lab2%E5%90%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84-167801655399147.png" srcset="/img/loading.gif" lazyload alt="JOS内核线性地址空间按"></p>
<blockquote>
<p><strong>最终：现在我们可以直接使用UPAGES这个虚拟地址直接访问pages数组，使用UVPT访问内核页目录表，使用KSTACKTOP访问内核栈。</strong></p>
</blockquote>
<h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="User-Environments"><a href="#User-Environments" class="headerlink" title="User Environments"></a>User Environments</h3><p>这里的environment相当于unix中的进程的概念。</p>
<p>Jos使用ENV数据结构记录用户环境，这个lab3先支持一个用户环境，接下来会实现多用户环境，以及用户环境之间的。</p>
<p>内核维护了三个全局变量：</p>
<ol>
<li>struct Env *envs = NULL;  这个表示所有的用户进程</li>
<li>struct Env * curenv = NULL; 指向当前的用户进程</li>
<li>static struct Env *env_free_list  指向空闲的用户环境（和pages数组一样）</li>
</ol>
<p>和lab2管理物理页的思路一样，envs指向一个ENV结构的数组，curenv指向当前正在运行的环境， env_free_list指向一个ENV结构的链表，保存未在运行的环境。</p>
<blockquote>
<p>envs数组空间的分配和pages数组空间的分配在一起的，紧跟在pages数组的后面，然后将内核虚拟地址的UENVS映射到envs，方便后面操作。</p>
<p><code>envs = (struct Env*)boot_alloc(sizeof(struct Env) * NENV); </code></p>
<p><code>memset(envs, 0, sizeof(struct Env) * NENV);</code></p>
<p><code>boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</code></p>
</blockquote>
<p>ENV结构定义在inc/env.h中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span>	<span class="hljs-comment">// Saved registers // 用来保存当进程切换时进程的状态信息，方便后面恢复</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_link</span>;</span>		<span class="hljs-comment">// Next free Env</span><br>	<span class="hljs-type">envid_t</span> env_id;			<span class="hljs-comment">// Unique environment identifier</span><br>	<span class="hljs-type">envid_t</span> env_parent_id;		<span class="hljs-comment">// env_id of this env&#x27;s parent</span><br>	<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnvType</span> <span class="hljs-title">env_type</span>;</span>		<span class="hljs-comment">// Indicates special system environments</span><br>	<span class="hljs-type">unsigned</span> env_status;		<span class="hljs-comment">// Status of the environment  </span><br>	<span class="hljs-type">uint32_t</span> env_runs;		<span class="hljs-comment">// Number of times environment has run</span><br>	<span class="hljs-type">int</span> env_cpunum;			<span class="hljs-comment">// The CPU that the env is running on</span><br><br>	<span class="hljs-comment">// Address space</span><br>	<span class="hljs-type">pde_t</span> *env_pgdir;		<span class="hljs-comment">// Kernel virtual address of page dir</span><br><br>	<span class="hljs-comment">// Exception handling</span><br>	<span class="hljs-type">void</span> *env_pgfault_upcall;	<span class="hljs-comment">// Page fault upcall entry point</span><br><br>	<span class="hljs-comment">// Lab 4 IPC</span><br>	<span class="hljs-comment">//当进程使用env_ipc_recv函数等待信息时，会将这个成员设置为1，然后堵塞等待；当一个进程向它发消息解除堵塞后，发送进程将此成员修改为0。</span><br>	<span class="hljs-type">bool</span> env_ipc_recving;		<span class="hljs-comment">// Env is blocked receiving  </span><br>	<span class="hljs-comment">//如果进程要接受消息并且是传送页，保存页映射的地址，且该地址&lt;=UTOP</span><br>	<span class="hljs-type">void</span> *env_ipc_dstva;		<span class="hljs-comment">// VA at which to map received page</span><br>	<span class="hljs-comment">//若等待消息的进程接收到消息，发送方将接收方此成员设置为消息值。</span><br>	<span class="hljs-type">uint32_t</span> env_ipc_value;		<span class="hljs-comment">// Data value sent to us</span><br>	<br>	<span class="hljs-type">envid_t</span> env_ipc_from;		<span class="hljs-comment">// envid of the sender</span><br>	<span class="hljs-comment">//如果进程要接收消息并且传送页，那么发送方发送页之后将传送的页权限赋给这个成员。</span><br>	<span class="hljs-type">int</span> env_ipc_perm;		<span class="hljs-comment">// Perm of page mapping received</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="内存空间映射"><a href="#内存空间映射" class="headerlink" title="内存空间映射"></a>内存空间映射</h3><p><img src="/2022/10/18/mit-6.828/image-20230306113621738.png" srcset="/img/loading.gif" lazyload alt="image-20230306113621738"></p>
<h3 id="进程创建和释放过程"><a href="#进程创建和释放过程" class="headerlink" title="进程创建和释放过程"></a>进程创建和释放过程</h3><blockquote>
<p>env_init():这个方法用来初始化这个envs链表，并初始化GDT描述符表段选择子</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// Set up envs array</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	env_free_list = <span class="hljs-literal">NULL</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;	<span class="hljs-comment">//前插法构建链表</span><br>		envs[i].env_id = <span class="hljs-number">0</span>;<br>		envs[i].env_link = env_free_list;<br>		env_free_list = &amp;envs[i];<br>	&#125;<br>	<span class="hljs-comment">// Per-CPU part of the initialization</span><br>	env_init_percpu();<br>&#125;<br><br><span class="hljs-comment">// Load GDT and segment descriptors.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	lgdt(&amp;gdt_pd);<br>	<span class="hljs-comment">// The kernel never uses GS or FS, so we leave those set to</span><br>	<span class="hljs-comment">// the user data segment.</span><br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%gs&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_UD|<span class="hljs-number">3</span>))</span>;<br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%fs&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_UD|<span class="hljs-number">3</span>))</span>;<br>	<span class="hljs-comment">// The kernel does use ES, DS, and SS.  We&#x27;ll change between</span><br>	<span class="hljs-comment">// the kernel and user data segments as needed.</span><br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%es&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_KD))</span>;<br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%ds&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_KD))</span>;<br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%ss&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_KD))</span>;<br>	<span class="hljs-comment">// Load the kernel text segment into CS.</span><br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;ljmp %0,$1f\n 1:\n&quot;</span> : : <span class="hljs-string">&quot;i&quot;</span> (GD_KT))</span>;<br>	<span class="hljs-comment">// For good measure, clear the local descriptor table (LDT),</span><br>	<span class="hljs-comment">// since we don&#x27;t use it.</span><br>	lldt(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>初始化和创建env_free_list很简单，我们来分析一下env_init_percpu这个函数。</li>
<li>内核运行到这里，还没有加载过GDT。在内核还未加载到内存之前，boot.S于进入保护模式前加载过一次GDT，那个表中只安装了代码段和数据段两个段描述符。</li>
<li>boot.S中通过ljmp跳转指令使cs的索引值指向代码段描述符，并将选择子ds、es、fs、gs和ss的索引值均设置为指向数据段描述符，至此这些段选择子均不曾被更改过。</li>
<li>现在我们要创建进程，而原先的GDT中并没有<strong>特权级为3</strong>的数据段和代码段描述符，所以我们必须加载一个新的GDT。</li>
<li>env_init_percpu使用内联汇编语句，我们可以回头参考一下课程网站上的相关资料。简而言之，env_init_percpu重新加载了GDT，并设置了各个段选择子。注意，这里做的指示初始化的工作，并没有真正进入用户环境。</li>
<li>因此函数只将fs、gs指向了用户的数据段描述符（？），其余寄存器仍然指向内核的段描述符，等到准备进入用户环境时才会更改其余段选择子。另外，JOS不使用局部描述符表LDT。</li>
</ul>
<blockquote>
<p>关于特权级问题，我们待会再来补充</p>
</blockquote>
<blockquote>
<p>env_setuo_vm(): <strong>这个是为了给这个进程申请一个页目录表，然后将内核的页目录表的内容复制过来，然后再把UVPT虚拟地址对应的物理地址设置为当前进程的页目录表地址</strong></p>
<ul>
<li>为什么直接把UVPT对应的页目录项设置为页目录表的物理地址，因为UVPT = 0xef400000</li>
<li>中间10位和后12位都是0，页目录表又充当了页表，并且获取了页表的第0项，就是页目录表的地址。</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize the kernel virtual memory layout for environment e.</span><br><span class="hljs-comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span><br><span class="hljs-comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span><br><span class="hljs-comment">// Do NOT (yet) map anything into the user portion</span><br><span class="hljs-comment">// of the environment&#x27;s virtual address space.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span><br><span class="hljs-comment">//	-E_NO_MEM if page directory or table could not be allocated.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-type">int</span> i;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br><br>	<span class="hljs-comment">// Allocate a page for the page directory</span><br>	<span class="hljs-comment">//申请一个页表当作用户进程的页目录表</span><br>	<span class="hljs-keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))<br>		<span class="hljs-keyword">return</span> -E_NO_MEM;<br><br>	<span class="hljs-comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hint:</span><br>	<span class="hljs-comment">//    - The VA space of all envs is identical above UTOP</span><br>	<span class="hljs-comment">//	(except at UVPT, which we&#x27;ve set below).</span><br>	<span class="hljs-comment">//	See inc/memlayout.h for permissions and layout.</span><br>	<span class="hljs-comment">//	Can you use kern_pgdir as a template?  Hint: Yes.</span><br>	<span class="hljs-comment">//	(Make sure you got the permissions right in Lab 2.)</span><br>	<span class="hljs-comment">//    - The initial VA below UTOP is empty.</span><br>	<span class="hljs-comment">//    - You do not need to make any more calls to page_alloc.</span><br>	<span class="hljs-comment">//    - Note: In general, pp_ref is not maintained for</span><br>	<span class="hljs-comment">//	physical pages mapped only above UTOP, but env_pgdir</span><br>	<span class="hljs-comment">//	is an exception -- you need to increment env_pgdir&#x27;s</span><br>	<span class="hljs-comment">//	pp_ref for env_free to work correctly.</span><br>	<span class="hljs-comment">//    - The functions in kern/pmap.h are handy.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-comment">//确定用户页目录表的虚拟地址</span><br>	e-&gt;env_pgdir = (<span class="hljs-type">pde_t</span> *)page2kva(p);<br><br><br>	<span class="hljs-comment">//将UTOP以下的虚拟地址对应的页目录项都赋值0</span><br>	<span class="hljs-comment">// for(int i=0;i&lt;PDX(UTOP);i++)&#123;</span><br>	<span class="hljs-comment">// 	e-&gt;env_pgdir[i] = 0;</span><br>	<span class="hljs-comment">// &#125;</span><br><br>	<span class="hljs-comment">//所有进程的内核虚拟空间，都会被映射到之前操作系统程序的内核虚拟空间映射到的地方，</span><br>	<span class="hljs-comment">//其实就是将内核的页目录表的UTOP对应的页目录项复制到各个用户进程的页目录表的相同的位置，这样，当用户进程访问自己的内核虚拟地址的时候</span><br>	<span class="hljs-comment">//就会被映射到实际的内核程序的存储的物理地址</span><br><br>	<span class="hljs-comment">//将UTOP之上的虚拟地址的页目录项设置为内核页目录表相同的页目录项的值</span><br>	<span class="hljs-built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);<br>	p-&gt;pp_ref++;<br>	<span class="hljs-comment">// UVPT maps the env&#x27;s own page table read-only.</span><br>	<span class="hljs-comment">// Permissions: kernel R, user R</span><br>	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>region_alloc(): 内存申请，为进程e申请len长度的内存，并将虚拟地址va和物理地址pa的对应关系放在e的页表中。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocate len bytes of physical memory for environment env,</span><br><span class="hljs-comment">// and map it at virtual address va in the environment&#x27;s address space.</span><br><span class="hljs-comment">// Does not zero or otherwise initialize the mapped pages in any way.</span><br><span class="hljs-comment">// Pages should be writable by user and kernel.</span><br><span class="hljs-comment">// Panic if any allocation attempt fails.</span><br><span class="hljs-comment">// 完成用户程序的虚拟地址和物理地址的映射，也就是设置好了env_pgdir</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">region_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-comment">// (But only if you need it for load_icode.)</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hint: It is easier to use region_alloc if the caller can pass</span><br>	<span class="hljs-comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span><br>	<span class="hljs-comment">//   You should round va down, and round (va + len) up.</span><br>	<span class="hljs-comment">//   (Watch out for corner-cases!)</span><br>	<span class="hljs-comment">//向下取整，找到va所在的页的起始虚拟地址</span><br>	<span class="hljs-type">void</span> *start = (<span class="hljs-type">void</span> *)ROUNDDOWN((<span class="hljs-type">uint32_t</span>)va,PGSIZE);<br>	<span class="hljs-type">void</span> *end = (<span class="hljs-type">void</span> *)ROUNDUP((<span class="hljs-type">uint32_t</span>)(va) + len,PGSIZE);<br><br>	<span class="hljs-comment">//开始找空闲页进行映射</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br>	<span class="hljs-type">void</span> *i;<br>	<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(i = start;i&lt;end;i += PGSIZE)&#123;<br>		<span class="hljs-comment">//从空闲链表中拿出一个页出来</span><br>		pp = page_alloc(<span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span>(pp ==<span class="hljs-literal">NULL</span>)&#123;<br>			panic(<span class="hljs-string">&quot;PageInfo allocation is failed&quot;</span>);<br>		&#125;<br>		<span class="hljs-comment">//将指定的虚拟地址 i 和指定的物理地址进行映射</span><br>		r = page_insert(e-&gt;env_pgdir,pp,i,PTE_W | PTE_U);<br>		<span class="hljs-keyword">if</span>(r!=<span class="hljs-number">0</span>)&#123;<br>			panic(<span class="hljs-string">&quot;region alloc failed&quot;</span>);<br>		&#125;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>load_icode() :  将env的elf文件加载到内存中，</p>
<p>通过读取elf文件的elf header 和 program header table 将各个段读进来（先分配物理内存空间，然后将内容加载到指定的物理空间，这个时候使用的是memset和memove函数，因为在申请内存空间的时候，就将e的页表设置完成了，所以当我们操作mem这种函数时，要将内核的页表切换成e的页表，这样才能正确找到虚拟地址对应的物理地址）</p>
<p>最后加载完成之后，要为这个e分配一个栈物理内存（在物理空间选择对应的大小）然后映射到虚拟地址USTACKTOP -PGSIZE，供给这个进程使用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Set up the initial program binary, stack, and processor flags</span><br><span class="hljs-comment">// for a user process.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function loads all loadable segments from the ELF binary image</span><br><span class="hljs-comment">// into the environment&#x27;s user memory, starting at the appropriate</span><br><span class="hljs-comment">// virtual addresses indicated in the ELF program header.</span><br><span class="hljs-comment">// At the same time it clears to zero any portions of these segments</span><br><span class="hljs-comment">// that are marked in the program header as being mapped</span><br><span class="hljs-comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// All this is very similar to what our boot loader does, except the boot</span><br><span class="hljs-comment">// loader also needs to read the code from disk.  Take a look at</span><br><span class="hljs-comment">// boot/main.c to get ideas.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// load_icode panics if it encounters problems.</span><br><span class="hljs-comment">//  - How might load_icode fail?  What might be wrong with the given input?</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">uint8_t</span> *binary)</span><br>&#123;<br>	<span class="hljs-comment">// Hints:</span><br>	<span class="hljs-comment">//  Load each program segment into virtual memory</span><br>	<span class="hljs-comment">//  at the address specified in the ELF segment header.</span><br>	<span class="hljs-comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span><br>	<span class="hljs-comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span><br>	<span class="hljs-comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span><br>	<span class="hljs-comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span><br>	<span class="hljs-comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span><br>	<span class="hljs-comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span><br>	<span class="hljs-comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span><br>	<span class="hljs-comment">//  Use functions from the previous lab to allocate and map pages.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  All page protection bits should be user read/write for now.</span><br>	<span class="hljs-comment">//  ELF segments are not necessarily page-aligned, but you can</span><br>	<span class="hljs-comment">//  assume for this function that no two segments will touch</span><br>	<span class="hljs-comment">//  the same virtual page.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  You may find a function like region_alloc useful.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  Loading the segments is much simpler if you can move data</span><br>	<span class="hljs-comment">//  directly into the virtual addresses stored in the ELF binary.</span><br>	<span class="hljs-comment">//  So which page directory should be in force during</span><br>	<span class="hljs-comment">//  this function?</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">//  You must also do something with the program&#x27;s entry point,</span><br>	<span class="hljs-comment">//  to make sure that the environment starts executing there.</span><br>	<span class="hljs-comment">//  What?  (See env_run() and env_pop_tf() below.)</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>,*<span class="hljs-title">eph</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> *<span class="hljs-title">header</span> =</span> (<span class="hljs-keyword">struct</span> Elf *)binary; <br><br><br>	<span class="hljs-keyword">if</span>(header-&gt;e_magic !=ELF_MAGIC)&#123;<br>		panic(<span class="hljs-string">&quot;load_icode faild: the binary is not elf&quot;</span>);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(header-&gt;e_entry == <span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;load_icode failed : the elf can&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-comment">//第一个程序头的地址</span><br>	ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) (header) + header-&gt;e_phoff); <br>	<span class="hljs-comment">//最后一个程序头的截至地址</span><br>	eph = ph + header-&gt;e_phnum;<br><br>	lcr3(PADDR(e-&gt;env_pgdir));   <span class="hljs-comment">//load user pgdir，这句话很关键，因为memmove和memset方法必须使用这个页表来转换地址，</span><br>	<span class="hljs-comment">//但是现在所有运行的代码都是内核代码，位于0x100000上面</span><br><br>	<span class="hljs-comment">//完成代码段虚拟地址和物理地址的分配映射，以及将代码加载到指定的物理地址去</span><br>	<span class="hljs-keyword">for</span>(; ph &lt; eph; ph++)&#123;<br>		<span class="hljs-keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;<br>			<br>			<span class="hljs-keyword">if</span>(ph-&gt;p_filesz &gt; ph-&gt;p_memsz)&#123;<br>				panic(<span class="hljs-string">&quot;load_icode failed : p_memsz &lt; p_filesz&quot;</span>);<br>			&#125;<br>			<span class="hljs-comment">//ph-&gt;p_va表示本段在内存中的起始虚拟地址地址</span><br>			<span class="hljs-comment">//将这个代码段给映射到指定的物理地址空间，并填充对应的页表</span><br>			region_alloc(e,(<span class="hljs-type">void</span> *)ph-&gt;p_va,ph-&gt;p_memsz);<br>			<span class="hljs-comment">//将binary内存中的代码段加载到空闲页面的物理地址中</span><br>			<span class="hljs-comment">//因为上面将代码段的起始虚拟地址映射到了指定的物理地址，所以要将代码段复制到指定的物理地址去，这样在后面运行代码的时候，才能保证一致</span><br>			memmove((<span class="hljs-type">void</span> *)ph-&gt;p_va,binary + ph-&gt;p_offset,ph-&gt;p_filesz);<br>			<span class="hljs-comment">//因为一般内存中的代码段大小大于在文件中的大小，所以多余的地方补0</span><br>			<span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class="hljs-number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);<br>		&#125;<br>	&#125;<br>	lcr3(PADDR(kern_pgdir)); <span class="hljs-comment">//将进程的程序加载到指定的位置后，要改回来内核的页表，因为现在运行的还是内核的程序</span><br>	<span class="hljs-comment">//设置这个程序入口地址</span><br>	e-&gt;env_tf.tf_eip = header-&gt;e_entry;<br>	<span class="hljs-comment">// Now map one page for the program&#x27;s initial stack</span><br>	<span class="hljs-comment">// at virtual address USTACKTOP - PGSIZE.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-comment">//为用户进程分配栈空间（也就是完成用户栈虚拟地址到物理地址的分配和映射）不知道分配到哪了</span><br>	region_alloc(e,(<span class="hljs-type">void</span> *)(USTACKTOP -PGSIZE),PGSIZE);<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>env_creat() : 创建进程</p>
<p>先从env_free_list中获取一个env记录当前进程，然后加载elf文件，调用前面的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocates a new env with env_alloc, loads the named elf</span><br><span class="hljs-comment">// binary into it with load_icode, and sets its env_type.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">// The new env&#x27;s parent ID is set to 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>	<span class="hljs-type">int</span> r;<br>	<span class="hljs-keyword">if</span> ((r = env_alloc(&amp;e, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)) &#123;<br>		panic(<span class="hljs-string">&quot;create env failed\n&quot;</span>);<br>	&#125;<br><br>	load_icode(e, binary);<br>	e-&gt;env_type = type;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>env_run() 这个函数就是启动一个进程，怎么才算启动一个进程呢？</p>
<ul>
<li><p>将curenv指针指向这个进程e</p>
</li>
<li><p>设置这个进程的状态为ENV_RUNNING</p>
</li>
<li><p>然后加载这个进程的有页目录表到cr3寄存器中</p>
</li>
<li><p><strong>然后恢复之前保存的env进程环境</strong>（保存在env的Trapframe属性中）</p>
<p>我们看看Trapframe结构：都是保存的寄存器的值，和运行上下文环境信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">tf_regs</span>;</span><br>	<span class="hljs-type">uint16_t</span> tf_es;<br>	<span class="hljs-type">uint16_t</span> tf_padding1;<br>	<span class="hljs-type">uint16_t</span> tf_ds;<br>	<span class="hljs-type">uint16_t</span> tf_padding2;<br>	<span class="hljs-type">uint32_t</span> tf_trapno;<br>	<span class="hljs-comment">//下面这些是由硬件cpu压入到栈中的，上面的那些我们需要自己去压入，也就是要保护的环境</span><br>	<span class="hljs-comment">/* below here defined by x86 hardware */</span><br>	<span class="hljs-type">uint32_t</span> tf_err;<br>	<span class="hljs-type">uintptr_t</span> tf_eip;<br>	<span class="hljs-type">uint16_t</span> tf_cs;<br>	<span class="hljs-type">uint16_t</span> tf_padding3;<br>	<span class="hljs-type">uint32_t</span> tf_eflags;<br>	<span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br>	<span class="hljs-type">uintptr_t</span> tf_esp;<br>	<span class="hljs-type">uint16_t</span> tf_ss;<br>	<span class="hljs-type">uint16_t</span> tf_padding4;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br>	<span class="hljs-comment">//	   1. Set the current environment (if any) back to</span><br>	<span class="hljs-comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br>	<span class="hljs-comment">//	      what other states it can be in),</span><br>	<span class="hljs-comment">//	   2. Set &#x27;curenv&#x27; to the new environment,</span><br>	<span class="hljs-comment">//	   3. Set its status to ENV_RUNNING,</span><br>	<span class="hljs-comment">//	   4. Update its &#x27;env_runs&#x27; counter,</span><br>	<span class="hljs-comment">//	   5. Use lcr3() to switch to its address space.</span><br>	<span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br>	<span class="hljs-comment">//	   registers and drop into user mode in the</span><br>	<span class="hljs-comment">//	   environment.</span><br><br>	<span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br>	<span class="hljs-comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span><br>	<span class="hljs-comment">//	and make sure you have set the relevant parts of</span><br>	<span class="hljs-comment">//	e-&gt;env_tf to sensible values.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">if</span>(curenv !=<span class="hljs-literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<br>		curenv-&gt;env_status = ENV_RUNNABLE;<br>	&#125;<br>	curenv = e;<br>	curenv-&gt;env_status = ENV_RUNNING;<br>	curenv-&gt;env_runs++;<br>	<span class="hljs-comment">//将这进程的页目录表加载到cr3寄存器中</span><br>	lcr3(PADDR(curenv-&gt;env_pgdir));<br>	<span class="hljs-comment">//进入用户环境后，将内核锁释放掉</span><br>	unlock_kernel();<br>	<span class="hljs-comment">//进入用户环境</span><br>	<span class="hljs-comment">//这个函数将之前设置的e-&gt;env_tf-&gt;tf_eip弹出到eip寄存器中，这样就完成了程序的转换了。</span><br>	env_pop_tf(&amp;(e-&gt;env_tf));<br>	<span class="hljs-comment">// panic(&quot;env_run not yet implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>对于这个env_pop_tf(&amp;(e-&gt;env_tf));这个函数十分重要，要想理解这个函数，我们必须弄清楚在切换线程的时候，cpu为我们做了什么，应保存哪些寄存器的值，保存的顺序是什么？</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Restores the register values in the Trapframe with the &#x27;iret&#x27; instruction.</span><br><span class="hljs-comment">// This exits the kernel and starts executing some environment&#x27;s code.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function does not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_pop_tf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">		<span class="hljs-string">&quot;\tmovl %0,%%esp\n&quot;</span>				<span class="hljs-comment">//将%esp指向tf地址处</span></span><br><span class="hljs-params">		<span class="hljs-string">&quot;\tpopal\n&quot;</span>						<span class="hljs-comment">//弹出Trapframe结构中的tf_regs值到通用寄存器</span></span><br><span class="hljs-params">		<span class="hljs-string">&quot;\tpopl %%es\n&quot;</span>					<span class="hljs-comment">//弹出Trapframe结构中的tf_es值到%es寄存器</span></span><br><span class="hljs-params">		<span class="hljs-string">&quot;\tpopl %%ds\n&quot;</span>					<span class="hljs-comment">//弹出Trapframe结构中的tf_ds值到%ds寄存器</span></span><br><span class="hljs-params">		<span class="hljs-string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="hljs-comment">/* skip tf_trapno and tf_errcode */</span></span><br><span class="hljs-params">		<span class="hljs-string">&quot;\tiret\n&quot;</span>						<span class="hljs-comment">//中断返回指令，具体动作如下：从Trapframe结构中依次弹出tf_eip,tf_cs,tf_eflags,tf_esp,tf_ss到相应寄存器</span></span><br><span class="hljs-params">		: : <span class="hljs-string">&quot;g&quot;</span> (tf) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>	panic(<span class="hljs-string">&quot;iret failed&quot;</span>);  <span class="hljs-comment">/* mostly to placate the compiler */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>上述就是基本的进程管理和创建过程：</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">env_create() <span class="hljs-comment">// 创建进程</span><br>    --&gt;env_alloc()  <span class="hljs-comment">// 申请空间为进程创建一个页表，并维护一个env</span><br>        --&gt;env_setup_vm()<br>    --&gt;load_icode() <span class="hljs-comment">// 加载elf文件,申请空间，加载elf段</span><br>        --&gt;region_alloc()<br>env_run()  <span class="hljs-comment">// 运行进程</span><br></code></pre></td></tr></table></figure>



<h3 id="进程的通信和创建子进程"><a href="#进程的通信和创建子进程" class="headerlink" title="进程的通信和创建子进程"></a>进程的通信和创建子进程</h3><h3 id="linux-的进程如何管理的"><a href="#linux-的进程如何管理的" class="headerlink" title="linux 的进程如何管理的"></a>linux 的进程如何管理的</h3><h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><p>总共分为了4（0，1，2，3）个特权级 ，0级特权最高，<strong>特权级的检查都是依靠CPU来完成的</strong></p>
<p>CPL表示当前cpu所处的特权级别</p>
<p>DPL一般是在描述符中，用来表示被访问的段的特权级</p>
<p>RPL表示请求特权级别，一般在<strong>选择子的低两位表示</strong></p>
<p>当发生call ，jmp，int等指令的时候，cpu会自动的进行特权级的检查，来判断这些指令有没有权利去访问目标指令。call指令可以实现是低特权级向高特权级访问，jmp只能平级访问。</p>
<p>我们主要还是在意中断时候的特权级别转换。也就是从用户态转换到内核态。</p>
<ul>
<li><strong>如果是int指令触发的中断，cpu需要进行特权级检查，这个检查分为两个，一个是CPL特权必须大于中断描述符中的DPL（作为一个跳板），另一个是CPL必须小于要访问的目标段描述符中的DPL。只有这样才能继续往下运行。所以我们在设置中断描述符表的时候，一定要把系统调用的中断描述符和断点的中断描述符DPL位设置为3，因为这两个中断是可以通过int来实现的。而其他的中断描述符的DPL设置为0，防止用户通过int指令来访问。</strong></li>
<li>如果是外界产生的中断，那么不需要检查中断描述符的DPL，只需要检查CPL特权级小于目标段描述符的DPL。</li>
</ul>
<h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p>TSS这个是用来表示每个任务的状态的，但是一般都只是采用了它的SS0和ESP0这两个字段，这个是配合CPU来使用的，用来保存内核的栈地址，当进入内核态的时候，会将esp和ss寄存器赋值为TSS的SS0和ESP0寄存器的值，表示内核的栈。我们来举个进入中断时的步骤：</p>
<p>假如我们执行了int的系统调用中断，</p>
<ul>
<li>cpu首先进行特权级检查，检查中断门描述符的DPL特权级是不是小于CPL，检查目标代码段的DPL代表的特权级是不是大于CPL特权级，如果这两个检查通过，就继续往下，如果不通过会触发general protection exception </li>
<li><strong>然后cpu将TSS中的内核的栈地址SS0和ESP0放入到cpu的ss和esp寄存器中，然后将用户态的旧的ss和esp值要保存到内核栈中（会产生临时空间进行转换），然后再压入eflags寄存器值，以及调用中断时的cs和eip寄存器的值，然后还有可能压入错误码。</strong>这些都是cpu完成的。用来恢复中断返回时的用户态的环境</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">+--------------------+ KSTACKTOP             <br>| <span class="hljs-number">0x00000</span> | old SS   |     <span class="hljs-string">&quot; - 4</span><br><span class="hljs-string">|      old ESP       |     &quot;</span> - <span class="hljs-number">8</span><br>|     old EFLAGS     |     <span class="hljs-string">&quot; - 12</span><br><span class="hljs-string">| 0x00000 | old CS   |     &quot;</span> - <span class="hljs-number">16</span><br>|      old EIP       |     <span class="hljs-string">&quot; - 20</span><br><span class="hljs-string">|     error code     |     &quot;</span> - <span class="hljs-number">24</span> &lt;---- ESP<br>+--------------------+   <br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/10/18/mit-6.828/lab3_5_cpu%E6%A8%A1%E5%9E%8B-16781098671175.png" srcset="/img/loading.gif" lazyload alt="CPU模型"></p>
<h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>中断和异常都是保护控制转换。在Intel体系语义下，中断是一种由处理器之外的异步事件引起的保护控制转换，比如外部设备的通知。异常是由正在执行的代码引起的同步的保护控制转换，比如访问无效内存，或者除以0。<br>为了防止中断发生时，当前运行的代码不会跳转到内核的任意位置执行，x86提供了两种机制：</p>
<ol>
<li><p>中断描述符表：处理器确保异常或中断发生时，只会跳转到由内核定义的代码点处执行。x86允许256种不同的中断或异常进入点，每一个都有一个向量号，从0到255。CPU使用向量号作为IDT的索引，取出一个IDT描述符，根据IDT描述符可以获取中断处理函数cs和eip的值，从而进入中断处理函数执行。</p>
</li>
<li><p>任务状态段(TSS)：当x86异常发生，并且发生了从用户模式到内核模式的转换时，处理器也会进行栈切换。一个叫做task state segment (TSS)的结构指定了栈的位置。TSS是一个很大的数据结构，由于JOS中内核模式就是指权限0，所以处理器只使用TSS结构的ESP0和SS0两个字段来定义内核栈，其它字段不使用。那么内核如何找到这个TSS结构的呢？JOS内核维护了一个<code>static struct Taskstate ts;</code>的变量，然后在trap_init_percpu()函数中，设置TSS选择子（使用ltr指令）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// The example code here sets up the Task State Segment (TSS) and</span><br>	<span class="hljs-comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span><br>	<span class="hljs-comment">// running on other CPUs because each CPU has its own kernel stack.</span><br>	<span class="hljs-comment">// Fix the code so that it works for all CPUs.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Hints:</span><br>	<span class="hljs-comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span><br>	<span class="hljs-comment">//     struct CpuInfo;</span><br>	<span class="hljs-comment">//   - The ID of the current CPU is given by cpunum() or</span><br>	<span class="hljs-comment">//     thiscpu-&gt;cpu_id;</span><br>	<span class="hljs-comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span><br>	<span class="hljs-comment">//     rather than the global &quot;ts&quot; variable;</span><br>	<span class="hljs-comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span><br>	<span class="hljs-comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span><br>	<span class="hljs-comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span><br>	<span class="hljs-comment">//     from doing IO (0 is not the correct value!)</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span><br>	<span class="hljs-comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span><br>	<span class="hljs-comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span><br>	<span class="hljs-comment">// wrong, you may not get a fault until you try to return from</span><br>	<span class="hljs-comment">// user space on that CPU.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// LAB 4: Your code here:</span><br>	thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE); <span class="hljs-comment">// 设置内核栈位置在这TSS结构中，后面要把这个TSS地址放到CPU的寄存器(TR寄存器)中</span><br>    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;<br>	thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate);<br>    <span class="hljs-comment">// Initialize the TSS slot of the gdt.</span><br>    <span class="hljs-comment">// TSS Task State Segment</span><br>    gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-type">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><br>    <span class="hljs-comment">// bottom three bits are special; we leave them 0)</span><br>    ltr(GD_TSS0 + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Segdesc) * cpunum());<br><br>    <span class="hljs-comment">// Load the IDT</span><br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2022/10/18/mit-6.828/lab3_5_cpu%E6%A8%A1%E5%9E%8B.png" srcset="/img/loading.gif" lazyload alt="CPU模型"></p>
</li>
</ol>
<h4 id="初始化中断描述符表"><a href="#初始化中断描述符表" class="headerlink" title="初始化中断描述符表"></a>初始化中断描述符表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Interrupt descriptor table.  (Must be built at run time because</span><br><span class="hljs-comment"> * shifted function addresses can&#x27;t be represented in relocation records.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gatedesc</span> <span class="hljs-title">idt</span>[256] =</span> &#123; &#123; <span class="hljs-number">0</span> &#125; &#125;; <span class="hljs-comment">// 运行时分配内存.bss中</span><br><br><span class="hljs-comment">/*初始化IDT中断描述符表*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">//全局描述表</span><br>	<span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segdesc</span> <span class="hljs-title">gdt</span>[];</span>        <br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-comment">//这些函数都是在trapentry.S中定义的，也就是所谓的trapHandler</span><br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th0</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th1</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th3</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th4</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th5</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th6</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th7</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th8</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th9</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th10</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th11</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th12</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th13</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th14</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th16</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">th_syscall</span><span class="hljs-params">()</span>;<br><br>	<span class="hljs-type">void</span> <span class="hljs-title function_">timer_handler</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">kbd_handler</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">serial_handler</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">spurious_handler</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">ide_handler</span><span class="hljs-params">()</span>;<br>	<span class="hljs-type">void</span> <span class="hljs-title function_">error_handler</span><span class="hljs-params">()</span>;<br>	<span class="hljs-comment">//下面就是初始化idt表，段选择子都是内核代码段，因为这些函数都是定在内核态的，这里dpl哦有些设置为0，是因为就是在</span><br>	SETGATE(idt[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, GD_KT, th0, <span class="hljs-number">0</span>);		<span class="hljs-comment">//格式如下：SETGATE(gate, istrap, sel, off, dpl)，定义在inc/mmu.h中</span><br>	SETGATE(idt[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, GD_KT, th1, <span class="hljs-number">0</span>);  <span class="hljs-comment">//设置idt[1]，段选择子为内核代码段，段内偏移为th1</span><br>	SETGATE(idt[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>, GD_KT, th3, <span class="hljs-number">3</span>);<br>	SETGATE(idt[<span class="hljs-number">4</span>], <span class="hljs-number">0</span>, GD_KT, th4, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">5</span>], <span class="hljs-number">0</span>, GD_KT, th5, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">6</span>], <span class="hljs-number">0</span>, GD_KT, th6, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">7</span>], <span class="hljs-number">0</span>, GD_KT, th7, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">8</span>], <span class="hljs-number">0</span>, GD_KT, th8, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">9</span>], <span class="hljs-number">0</span>, GD_KT, th9, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">10</span>], <span class="hljs-number">0</span>, GD_KT, th10, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">11</span>], <span class="hljs-number">0</span>, GD_KT, th11, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">12</span>], <span class="hljs-number">0</span>, GD_KT, th12, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">13</span>], <span class="hljs-number">0</span>, GD_KT, th13, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">14</span>], <span class="hljs-number">0</span>, GD_KT, th14, <span class="hljs-number">0</span>);<br>	SETGATE(idt[<span class="hljs-number">16</span>], <span class="hljs-number">0</span>, GD_KT, th16, <span class="hljs-number">0</span>);<br><br>	SETGATE(idt[T_SYSCALL], <span class="hljs-number">0</span>, GD_KT, th_syscall, <span class="hljs-number">3</span>);		<span class="hljs-comment">//为什么门的DPL要定义为3</span><br>															<span class="hljs-comment">//因为门相当于跳板，用户使用系统调用的时候，肯定要门的特权级低于用户级，只能为3    </span><br>	<span class="hljs-comment">// IRQ</span><br>	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],    <span class="hljs-number">0</span>, GD_KT, timer_handler, <span class="hljs-number">0</span>);<br>	SETGATE(idt[IRQ_OFFSET + IRQ_KBD],      <span class="hljs-number">0</span>, GD_KT, kbd_handler,     <span class="hljs-number">0</span>);<br>	SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],   <span class="hljs-number">0</span>, GD_KT, serial_handler,  <span class="hljs-number">0</span>);<br>	SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="hljs-number">0</span>, GD_KT, spurious_handler, <span class="hljs-number">0</span>);<br>	SETGATE(idt[IRQ_OFFSET + IRQ_IDE],      <span class="hljs-number">0</span>, GD_KT, ide_handler,     <span class="hljs-number">0</span>);<br>	SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],    <span class="hljs-number">0</span>, GD_KT, error_handler,   <span class="hljs-number">0</span>);<br>	<span class="hljs-comment">// Per-CPU setup </span><br>	trap_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数加载了中断描述符表，记录了中断号对应的函数地址，并设置了系统调用和断点的中断门特权级为3，供给int指令使用。</p>
<blockquote>
<p>trapentry.s文件定义了一些所有的中断处理函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* See COPYRIGHT for copyright information. */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/mmu.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/memlayout.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/trap.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;kern/picirq.h&gt;</span></span><br><br><br>###################################################################<br><span class="hljs-meta"># exceptions/interrupts</span><br>###################################################################<br><br><span class="hljs-comment">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="hljs-comment"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="hljs-comment"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * You shouldn&#x27;t call a TRAPHANDLER function from C, but you may</span><br><span class="hljs-comment"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="hljs-comment"> * during IDT setup).  You can declare the function with</span><br><span class="hljs-comment"> *   void NAME();</span><br><span class="hljs-comment"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER(name, num)						\</span><br><span class="hljs-meta">	.globl name;		<span class="hljs-comment">/* define global symbol for &#x27;name&#x27; */</span>	\</span><br><span class="hljs-meta">	.type name, @function;	<span class="hljs-comment">/* symbol type is function */</span>		\</span><br><span class="hljs-meta">	.align 2;		<span class="hljs-comment">/* align function definition */</span>		\</span><br><span class="hljs-meta">	name:			<span class="hljs-comment">/* function starts here */</span>		\</span><br><span class="hljs-meta">	pushl $(num);	<span class="hljs-comment">/* 压入中断号*/</span>					\</span><br><span class="hljs-meta">	jmp _alltraps</span><br><br><span class="hljs-comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="hljs-comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="hljs-comment"> * format in either case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER_NOEC(name, num)					\</span><br><span class="hljs-meta">	.globl name;							\</span><br><span class="hljs-meta">	.type name, @function;						\</span><br><span class="hljs-meta">	.align 2;							\</span><br><span class="hljs-meta">	name:								\</span><br><span class="hljs-meta">	pushl $0;							\</span><br><span class="hljs-meta">	pushl $(num);							\</span><br><span class="hljs-meta">	jmp _alltraps</span><br><br>.text<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="hljs-comment"> * 这里我们相当于定义了一堆异常或中断处理函数，可以根据名字来进行调用</span><br><span class="hljs-comment"> */</span><br> <br>TRAPHANDLER_NOEC(th0, <span class="hljs-number">0</span>)<br>	TRAPHANDLER_NOEC(th1, <span class="hljs-number">1</span>)<br>	TRAPHANDLER_NOEC(th3, <span class="hljs-number">3</span>)<br>	TRAPHANDLER_NOEC(th4, <span class="hljs-number">4</span>)<br>	TRAPHANDLER_NOEC(th5, <span class="hljs-number">5</span>)<br>	TRAPHANDLER_NOEC(th6, <span class="hljs-number">6</span>)<br>	TRAPHANDLER_NOEC(th7, <span class="hljs-number">7</span>)<br>	TRAPHANDLER(th8, <span class="hljs-number">8</span>)<br>	TRAPHANDLER_NOEC(th9, <span class="hljs-number">9</span>)<br>	TRAPHANDLER(th10, <span class="hljs-number">10</span>)<br>	TRAPHANDLER(th11, <span class="hljs-number">11</span>)<br>	TRAPHANDLER(th12, <span class="hljs-number">12</span>)<br>	TRAPHANDLER(th13, <span class="hljs-number">13</span>)<br>	TRAPHANDLER(th14, <span class="hljs-number">14</span>)<br>	TRAPHANDLER_NOEC(th16, <span class="hljs-number">16</span>)<br>	<span class="hljs-comment">//将系统调用的对应的程序名和中断号配置好</span><br>	TRAPHANDLER_NOEC(th_syscall, T_SYSCALL)<br><br>	<span class="hljs-comment">//外部中断处理函数  IRQS</span><br>TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);<br>TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);<br>TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);<br>TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);<br>TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);<br>TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for _alltraps</span><br><span class="hljs-comment"> * 这里是上面中断处理函数调用的实际处理函数，调用的时候，都在栈中压入了参数num，也就是中断号</span><br><span class="hljs-comment"> * ds和es的压入都是根据Trapframe结构顺序压入的</span><br><span class="hljs-comment"> * pushal就是将8个通用寄存器压入到栈中</span><br><span class="hljs-comment"> */</span><br>.globl _alltraps<br>_alltraps:<br>	pushl %ds;<br>	pushl %es;<br>	pushal;<br>	movw $GD_KD, %ax;<br>	movw %ax, %ds;<br>	movw %ax, %es;<br>	pushl %esp;       <span class="hljs-comment">//压入trap()的参数tf,%esp指向Trapframe结构的起始地址（这里是将栈中的这段连续的内存当成了Trapframe）</span><br>	call trap;		  <span class="hljs-comment">// 调用trap函数</span><br><br></code></pre></td></tr></table></figure>

<p>在中断处理函数中，我们可以看到，它首先在内核栈中压入了中断号，然后压入ds和es寄存器值，然后压入了8个基本寄存器,然后又将es和ds都设置成内核的段的值。<strong>tf_ss，tf_esp，tf_eflags，tf_cs，tf_eip，tf_err在中断发生时由处理器压入，所以现在只需要压入剩下寄存器（%ds,%es,通用寄存器）</strong>这个就是Trapframe数据结构，因为下面要调用<code>trap(struct Trapframe *tf)</code>,所以上面最后一把pushl %esp;就是压入了这个tf的指针。<strong>值得关注的时这个trap函数没有返回，那么是怎么退出中断和恢复env环境的呢？他是通过调用env_run(curenv)来实现的进程的恢复。</strong></p>
<blockquote>
<p>trap(struct Trapframe *tf)函数： 这个函数就是来处理中断事件的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在_alltraps中我们调用了这个trap函数，处理异常或中断事件</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-comment">// The environment may have set DF and some versions</span><br>	<span class="hljs-comment">// of GCC rely on DF being clear</span><br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cld&quot;</span> ::: <span class="hljs-string">&quot;cc&quot;</span>)</span>; <span class="hljs-comment">//cld指令功能: 将标志寄存器flag的方向标志位df清零</span><br><br>	<span class="hljs-comment">// Halt the CPU if some other CPU has called panic()</span><br>	<span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> *panicstr;<br>	<span class="hljs-keyword">if</span> (panicstr)<br>		<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;hlt&quot;</span>)</span>;<br><br>	<span class="hljs-comment">// Re-acqurie the big kernel lock if we were halted in</span><br>	<span class="hljs-comment">// sched_yield()</span><br>	<span class="hljs-keyword">if</span> (xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED) == CPU_HALTED)<br>		lock_kernel();<br>	<span class="hljs-comment">// Check that interrupts are disabled.  If this assertion</span><br>	<span class="hljs-comment">// fails, DO NOT be tempted to fix it by inserting a &quot;cli&quot; in</span><br>	<span class="hljs-comment">// the interrupt path.</span><br>	assert(!(read_eflags() &amp; FL_IF));<br>	<span class="hljs-comment">// cprintf(&quot;this trap num ========%x&quot;,tf-&gt;tf_trapno);</span><br>	<span class="hljs-comment">// cprintf(&quot; this tf-&gt;tf_cs = %x&quot;,tf-&gt;tf_cs);</span><br>	<span class="hljs-comment">// cprintf(&quot;Incoming TRAP frame at %p\n&quot;, tf);</span><br>	<span class="hljs-comment">//查看产生中断或异常的程序的特权级</span><br><br>	<span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span>) &#123;<br>		<span class="hljs-comment">// Trapped from user mode.</span><br>		<span class="hljs-comment">// Acquire the big kernel lock before doing any</span><br>		<span class="hljs-comment">// serious kernel work.</span><br>		<span class="hljs-comment">// LAB 4: Your code here.</span><br>		lock_kernel();<br>		assert(curenv);<br><br>		<span class="hljs-comment">// Garbage collect if current enviroment is a zombie</span><br>		<span class="hljs-keyword">if</span> (curenv-&gt;env_status == ENV_DYING) &#123;<br>			env_free(curenv);<br>			curenv = <span class="hljs-literal">NULL</span>;<br>			sched_yield();<br>		&#125;<br><br>		<span class="hljs-comment">// Copy trap frame (which is currently on the stack)</span><br>		<span class="hljs-comment">// into &#x27;curenv-&gt;env_tf&#x27;, so that running the environment</span><br>		<span class="hljs-comment">// will restart at the trap point.</span><br>		curenv-&gt;env_tf = *tf;<span class="hljs-comment">// 这一步是将刚才压入到栈的Trapframe复制到正在运行的env上，也就是那个env的运行环境。</span><br>		<span class="hljs-comment">// The trapframe on the stack should be ignored from here on.</span><br>		tf = &amp;curenv-&gt;env_tf;<br>	&#125;<br><br>	<span class="hljs-comment">// Record that tf is the last real trapframe so</span><br>	<span class="hljs-comment">// print_trapframe can print some additional information.</span><br>	last_tf = tf;<br><br>	<span class="hljs-comment">// Dispatch based on what type of trap occurred</span><br>	trap_dispatch(tf);<br><br>	<span class="hljs-comment">// If we made it to this point, then no other environment was</span><br>	<span class="hljs-comment">// scheduled, so we should return to the current environment</span><br>	<span class="hljs-comment">// if doing so makes sense.</span><br>	<span class="hljs-comment">// 这一步很关键</span><br>	<span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)<br>		env_run(curenv);<br>	<span class="hljs-keyword">else</span><br>		sched_yield();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>这个函数，会先判断这个中断是不是来自用户态的，然后将那个进程的env中的tf赋值为刚才压入到内核栈的tf结构，这是为了后续恢复env的重要步骤</strong></p>
<p>然后使用dispatch（tf）函数来执行具体的动作，主要是根据tf中的中断号来进行判断。</p>
<blockquote>
<p><strong>我比较疑惑的是异常是如何进来的？或者其他的中断是怎么进来的除了断点和系统调用？</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据中断号来执行相应的中断处理程序</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">trap_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-comment">// Handle processor exceptions.</span><br>	<span class="hljs-comment">//通过他的中断向量号，来确定中断处理函数</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br><br><br>	<span class="hljs-comment">// Handle spurious interrupts</span><br>	<span class="hljs-comment">// The hardware sometimes raises these because of noise on the</span><br>	<span class="hljs-comment">// IRQ line or other reasons. We don&#x27;t care.</span><br>	<span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) &#123;<br>		cprintf(<span class="hljs-string">&quot;Spurious interrupt on irq 7\n&quot;</span>);<br>		print_trapframe(tf);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span><br>	<span class="hljs-comment">// interrupt using lapic_eoi() before calling the scheduler!</span><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br><br>	<span class="hljs-comment">// Handle keyboard and serial interrupts.</span><br>	<span class="hljs-comment">// LAB 5: Your code here.</span><br><br>	<span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br><br><br>	<span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD) &#123;<br>                lapic_eoi();<br>    			kbd_intr();<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>	<span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL) &#123;<br>			lapic_eoi();<br>    		serial_intr();<br>			<span class="hljs-keyword">return</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">switch</span>(tf-&gt;tf_trapno)&#123;<br>		<span class="hljs-keyword">case</span> T_PGFLT:<br>			page_fault_handler(tf);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> T_BRKPT:<br>			monitor(tf);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> T_SYSCALL:<br>			tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <span class="hljs-comment">//这个是系统调用号，下面的都是参数</span><br>					tf-&gt;tf_regs.reg_edx,<br>					tf-&gt;tf_regs.reg_ecx,<br>					tf-&gt;tf_regs.reg_ebx,<br>					tf-&gt;tf_regs.reg_edi,<br>					tf-&gt;tf_regs.reg_esi);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:<br>			lapic_eoi();  <span class="hljs-comment">//设置中断响应</span><br>			sched_yield(); <span class="hljs-comment">//进程调度</span><br>			<span class="hljs-keyword">return</span>;<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br>			print_trapframe(tf);<br>			<span class="hljs-keyword">if</span> (tf-&gt;tf_cs == GD_KT)<br>				panic(<span class="hljs-string">&quot;unhandled trap in kernel&quot;</span>);<br>			<span class="hljs-keyword">else</span> &#123;<br>				env_destroy(curenv);<br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<p><strong>在trap（）函数最后的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)<br>		env_run(curenv);<br>	<span class="hljs-keyword">else</span><br>		sched_yield();<br></code></pre></td></tr></table></figure>

<p>就是用来恢复env进程的。让我们看看env_run()函数做了什么？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br>	<span class="hljs-comment">//	   1. Set the current environment (if any) back to</span><br>	<span class="hljs-comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br>	<span class="hljs-comment">//	      what other states it can be in),</span><br>	<span class="hljs-comment">//	   2. Set &#x27;curenv&#x27; to the new environment,</span><br>	<span class="hljs-comment">//	   3. Set its status to ENV_RUNNING,</span><br>	<span class="hljs-comment">//	   4. Update its &#x27;env_runs&#x27; counter,</span><br>	<span class="hljs-comment">//	   5. Use lcr3() to switch to its address space.</span><br>	<span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br>	<span class="hljs-comment">//	   registers and drop into user mode in the</span><br>	<span class="hljs-comment">//	   environment.</span><br><br>	<span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br>	<span class="hljs-comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span><br>	<span class="hljs-comment">//	and make sure you have set the relevant parts of</span><br>	<span class="hljs-comment">//	e-&gt;env_tf to sensible values.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">if</span>(curenv !=<span class="hljs-literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<br>		curenv-&gt;env_status = ENV_RUNNABLE;<br>	&#125;<br>	curenv = e;<br>	curenv-&gt;env_status = ENV_RUNNING;<br>	curenv-&gt;env_runs++;<br>	<span class="hljs-comment">//将这进程的页目录表加载到cr3寄存器中</span><br>	lcr3(PADDR(curenv-&gt;env_pgdir));<br>	<span class="hljs-comment">//进入用户环境后，将内核锁释放掉</span><br>	unlock_kernel();<br>	<span class="hljs-comment">//进入用户环境</span><br>	<span class="hljs-comment">//这个函数将之前设置的e-&gt;env_tf-&gt;tf_eip弹出到eip寄存器中，这样就完成了程序的转换了。</span><br>	env_pop_tf(&amp;(e-&gt;env_tf));<br>	<span class="hljs-comment">// panic(&quot;env_run not yet implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>最后的env_pop_tf(&amp;(e-&gt;env_tf));十分的关键，这个就是实现从中断中返回，然后恢复用户态环境。</strong></p>
<p><strong>将存储在内核栈的tf结构依次的pop出来，其中iret指令就是中断返回，他就是int指令的逆过程，都是由cpu来完成。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个是退出内核状态，恢复在Trapframe中存储的值到各个寄存器中</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_pop_tf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-comment">// Record the CPU we are running on for user-space debugging</span><br>	curenv-&gt;env_cpunum = cpunum();<br><br>	<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">		 <span class="hljs-string">&quot;\t movl %0, %%esp\n&quot;</span>       <span class="hljs-comment">/* %0对应后面的tf，这里是将tf这个地址值赋给%esp */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t popal\n&quot;</span>                <span class="hljs-comment">/* 按*/</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t popl %%es\n&quot;</span>            <span class="hljs-comment">/* 弹出值到%es */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t popl %%ds\n&quot;</span>            <span class="hljs-comment">/* 弹出值到%ds */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t addl $0x8, %%esp\n&quot;</span>     <span class="hljs-comment">/* 跳过tf_trapno 和 tf_errcode */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t iret\n&quot;</span>                 <span class="hljs-comment">/* 从中断返回，将栈中存储数据弹出到eip, cs, eflags寄存器中 */</span></span><br><span class="hljs-params">        : : <span class="hljs-string">&quot;g&quot;</span>(tf) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;    <span class="hljs-comment">/* “g”表示将输入变量tf放入eax，ebx，ecx，edx之一,或作为内存变量 */</span><br>                                    <span class="hljs-comment">/* 告诉编译器在执行期间会发生内存变动，以防止错误的代码优化 */</span><br>	panic(<span class="hljs-string">&quot;iret failed&quot;</span>);  <span class="hljs-comment">/* mostly to placate the compiler */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="系统调用system-call"><a href="#系统调用system-call" class="headerlink" title="系统调用system call"></a>系统调用system call</h3><p><strong>这是trapdispatch函数中的关于系统调用的入口</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_SYSCALL:<br>			tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <span class="hljs-comment">//这个是系统调用号，下面的都是参数</span><br>					tf-&gt;tf_regs.reg_edx,<br>					tf-&gt;tf_regs.reg_ecx,<br>					tf-&gt;tf_regs.reg_ebx,<br>					tf-&gt;tf_regs.reg_edi,<br>					tf-&gt;tf_regs.reg_esi);<br>			<span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure>

<p><strong>这几个寄存器存储的是系统调用号和系统调用的参数。</strong></p>
<blockquote>
<p>如何实现系统调用</p>
</blockquote>
<p>JOS使用int指令实现系统调用，使用0x30作为中断号。应用使用寄存器传递系统调用号和参数。系统调用号保存在%eax，五个参数依次保存在%edx, %ecx, %ebx, %edi, %esi中。返回值保存在%eax中。</p>
<p>我们前面都设置完成了IDT表，并且在trapdispatch()函数中也设置了。最后跳转到这里：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个syscall是内核的方法</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br>	<span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br>	<span class="hljs-comment">// Return any appropriate return value.</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-type">int32_t</span> ret;<br>	<span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br>	<span class="hljs-keyword">switch</span> (syscallno) &#123;<br>		<span class="hljs-keyword">case</span> SYS_cputs:<br>			sys_cputs((<span class="hljs-type">char</span> *)a1,(<span class="hljs-type">size_t</span>)a2);<br>			ret =<span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_cgetc:<br>			ret = sys_cgetc();<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_env_destroy:<br>			ret = sys_env_destroy((<span class="hljs-type">envid_t</span>)a1);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_getenvid:<br>			ret = sys_getenvid();<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_yield:  <span class="hljs-comment">//进程唤醒</span><br>			ret =<span class="hljs-number">0</span>;<br>			sys_yield();<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_exofork:  <span class="hljs-comment">//创建进程</span><br>			ret = sys_exofork();<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_env_set_status:<br>			ret = sys_env_set_status((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">int</span>)a2);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_page_alloc:<br>			ret = sys_page_alloc((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">void</span> *)a2, (<span class="hljs-type">int</span>)a3);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_page_map:<br>			ret = sys_page_map((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">void</span> *)a2,<br>	     (<span class="hljs-type">envid_t</span>)a3, (<span class="hljs-type">void</span> *)a4, (<span class="hljs-type">int</span>)a5);<br>			<span class="hljs-keyword">break</span>;<br>		<span class="hljs-keyword">case</span> SYS_page_unmap:<br>			ret = sys_page_unmap((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">void</span> *)a2);<br>			<span class="hljs-keyword">break</span>; <br>		<span class="hljs-keyword">case</span> SYS_env_set_pgfault_upcall:<br>			<span class="hljs-keyword">return</span> sys_env_set_pgfault_upcall((<span class="hljs-type">envid_t</span>) a1, (<span class="hljs-type">void</span> *) a2);<br>		<span class="hljs-keyword">case</span> SYS_ipc_recv:<br>			<span class="hljs-keyword">return</span> sys_ipc_recv((<span class="hljs-type">void</span> *)a1);<br>		<span class="hljs-keyword">case</span> SYS_ipc_try_send:<br>			<span class="hljs-keyword">return</span> sys_ipc_try_send((<span class="hljs-type">envid_t</span>)a1,(<span class="hljs-type">uint32_t</span>)a2,(<span class="hljs-type">void</span> *)a3,(<span class="hljs-type">int</span>)a4);<br>		<span class="hljs-keyword">case</span> SYS_env_set_trapframe:<br>			<span class="hljs-keyword">return</span> sys_env_set_trapframe((<span class="hljs-type">envid_t</span>)a1,(<span class="hljs-keyword">struct</span> Trapframe *)a2);<br>		<span class="hljs-keyword">default</span>:<br>			<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	<span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p>现在回顾一下系统调用的完成流程：以user/hello.c为例，其中调用了cprintf()，注意这是lib/print.c中的cprintf，该cprintf()最终会调用lib/syscall.c中的sys_cputs()，sys_cputs()又会调用lib/syscall.c中的syscall()，该函数将系统调用号放入%eax寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令int 0x30，发生中断后，去IDT中查找中断处理函数，最终会走到kern/trap.c的trap_dispatch()中，我们根据中断号0x30，又会调用kern/syscall.c中的syscall()函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用kern/print.c中的cprintf()函数，该函数最终调用kern/console.c中的cputchar()将字符串打印到控制台。当trap_dispatch()返回后，trap()会调用<code>env_run(curenv);</code>，该函数前面讲过，会将curenv-&gt;env_tf结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。</p>
<h3 id="如何开启用户进程的？"><a href="#如何开启用户进程的？" class="headerlink" title="如何开启用户进程的？"></a>如何开启用户进程的？</h3><p>用户程序真正开始运行的地方是在lib/entry.S文件中。该文件中，首先会进行一些设置，然后就会调用lib/libmain.c 文件中的 libmain() 函数。你首先要修改一下 libmain() 函数，使它能够初始化全局指针 thisenv ，让它指向当前用户环境的 Env 结构体。</p>
<p>　　　　然后 libmain() 函数就会调用 umain，这个 umain 程序恰好是 user/hello.c 中被调用的函数。在之前的实验中我们发现，hello.c程序只会打印 “hello, world” 这句话，然后就会报出 page fault 异常，原因就是 thisenv-&gt;env_id 这条语句。现在你已经正确初始化了这个 thisenv的值，再次运行就应该不会报错了。</p>
<blockquote>
<p><strong>我们要清楚的一点是这个libmain函数是操作系统提供的库函数，应该是直接给用户进程使用的，也就是这个libmain.c函数以及entry.s文件的代码最终在用户的elf文件中体现的，我们只需要设置tf中的cs和eip就行（这个对应的就是==_start==）</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">libmain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	<span class="hljs-comment">// set thisenv to point at our Env structure in envs[].</span><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-type">envid_t</span> envid = sys_getenvid();<br>	thisenv = envs + ENVX(envid);      <span class="hljs-comment">//获取Env结构指针</span><br><br>	<span class="hljs-comment">// save the name of the program so that panic() can use it</span><br>	<span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span>)<br>		binaryname = argv[<span class="hljs-number">0</span>];<br><br>	<span class="hljs-comment">// call user main routine</span><br>	umain(argc, argv);<br><br>	<span class="hljs-comment">// exit gracefully</span><br>	<span class="hljs-built_in">exit</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>user/hello.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">umain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	cprintf(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>	cprintf(<span class="hljs-string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);  <span class="hljs-comment">//现在我们已经初始化了thisenv变量了，所以可以打印处来了O(∩_∩)O</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>我们看一下这个hello.asm文件,截取了一部分</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs asm">obj/user/hello.debug：     文件格式 elf32-i386<br><br><br>Disassembly of section .text:<br><br>00800020 &lt;_start&gt;:<br>// starts us running when we are initially loaded into a new environment.<br>.text<br>.globl _start<br>_start:<br>	// See if we were started with arguments on the stack<br>	cmpl $USTACKTOP, %esp<br>  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp<br>	jne args_exist<br>  800026:	75 04                	jne    80002c &lt;args_exist&gt;<br><br>	// If not, push dummy argc/argv arguments.<br>	// This happens when we are loaded by the kernel,<br>	// because the kernel does not know about passing arguments.<br>	pushl $0<br>  800028:	6a 00                	push   $0x0<br>	pushl $0<br>  80002a:	6a 00                	push   $0x0<br><br>0080002c &lt;args_exist&gt;:<br><br>args_exist:<br>	call libmain<br>  80002c:	e8 2d 00 00 00       	call   80005e &lt;libmain&gt;<br>1:	jmp 1b<br>  800031:	eb fe                	jmp    800031 &lt;args_exist+0x5&gt;<br><br>00800033 &lt;umain&gt;:<br>// hello, world<br>#include &lt;inc/lib.h&gt;<br><br>void<br>umain(int argc, char **argv)<br>&#123;<br>  800033:	55                   	push   %ebp<br>  800034:	89 e5                	mov    %esp,%ebp<br>  800036:	83 ec 14             	sub    $0x14,%esp<br>	cprintf(&quot;hello, world\n&quot;);<br>  800039:	68 80 1d 80 00       	push   $0x801d80<br>  80003e:	e8 10 01 00 00       	call   800153 &lt;cprintf&gt;<br>	cprintf(&quot;i am environment %08x\n&quot;, thisenv-&gt;env_id);<br>  800043:	a1 00 40 80 00       	mov    0x804000,%eax<br>  800048:	8b 40 48             	mov    0x48(%eax),%eax<br>  80004b:	83 c4 08             	add    $0x8,%esp<br>  80004e:	50                   	push   %eax<br>  80004f:	68 8e 1d 80 00       	push   $0x801d8e<br>  800054:	e8 fa 00 00 00       	call   800153 &lt;cprintf&gt;<br>&#125;<br>  800059:	83 c4 10             	add    $0x10,%esp<br>  80005c:	c9                   	leave  <br>  80005d:	c3                   	ret    <br><br>0080005e &lt;libmain&gt;:<br>const volatile struct Env *thisenv;<br>const char *binaryname = &quot;&lt;unknown&gt;&quot;;<br><br>void<br>libmain(int argc, char **argv)<br>&#123;<br>  80005e:	55                   	push   %ebp<br>  80005f:	89 e5                	mov    %esp,%ebp<br>  800061:	56                   	push   %esi<br>  800062:	53                   	push   %ebx<br>  800063:	8b 5d 08             	mov    0x8(%ebp),%ebx<br>  800066:	8b 75 0c             	mov    0xc(%ebp),%esi<br>	// set thisenv to point at our Env structure in envs[].<br>	// LAB 3: Your code here.<br>	thisenv = &amp;envs[ENVX(sys_getenvid())]; //获取这个Env的结构指针<br>  800069:	e8 7d 0a 00 00       	call<br></code></pre></td></tr></table></figure>

<p>*<strong>我们可以看到就是先进入<code>_start</code>处（对应的就是elf中的入口地址也就是tf中设置的eip值，在创建进程的时候，会将tf的eip属性给设置为elf的入口地址，也就是 <code>_start</code>）</strong></p>
<blockquote>
<p>如何进入进程的？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br>	<span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br>	<span class="hljs-comment">//	   1. Set the current environment (if any) back to</span><br>	<span class="hljs-comment">//	      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br>	<span class="hljs-comment">//	      what other states it can be in),</span><br>	<span class="hljs-comment">//	   2. Set &#x27;curenv&#x27; to the new environment,</span><br>	<span class="hljs-comment">//	   3. Set its status to ENV_RUNNING,</span><br>	<span class="hljs-comment">//	   4. Update its &#x27;env_runs&#x27; counter,</span><br>	<span class="hljs-comment">//	   5. Use lcr3() to switch to its address space.</span><br>	<span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br>	<span class="hljs-comment">//	   registers and drop into user mode in the</span><br>	<span class="hljs-comment">//	   environment.</span><br><br>	<span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br>	<span class="hljs-comment">//	e-&gt;env_tf.  Go back through the code you wrote above</span><br>	<span class="hljs-comment">//	and make sure you have set the relevant parts of</span><br>	<span class="hljs-comment">//	e-&gt;env_tf to sensible values.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	<span class="hljs-keyword">if</span>(curenv !=<span class="hljs-literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<br>		curenv-&gt;env_status = ENV_RUNNABLE;<br>	&#125;<br>	curenv = e;<br>	curenv-&gt;env_status = ENV_RUNNING;<br>	curenv-&gt;env_runs++;<br>	<span class="hljs-comment">//将这进程的页目录表加载到cr3寄存器中</span><br>	lcr3(PADDR(curenv-&gt;env_pgdir));<br>	<span class="hljs-comment">//进入用户环境后，将内核锁释放掉</span><br>	unlock_kernel();<br>	<span class="hljs-comment">//进入用户环境</span><br>	<span class="hljs-comment">//这个函数将之前设置的e-&gt;env_tf-&gt;tf_eip弹出到eip寄存器中，这样就完成了程序的转换了。</span><br>	<span class="hljs-comment">//这个也是开始运行这个env的入口</span><br>	env_pop_tf(&amp;(e-&gt;env_tf)); <span class="hljs-comment">//这个是env中的tf地址，不是内核栈的那个tf，这个很重要</span><br>	<span class="hljs-comment">// panic(&quot;env_run not yet implemented&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>先页表转换，将eip地址设置为之前设置的tf中的eip，也就是程序入口地址（_start处）。</strong></p>
</blockquote>
<h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><blockquote>
<p><strong>在页表的每一个项的低12位为标志位，这个就是标志着对应内存的一些权限</strong></p>
</blockquote>
<p><img src="/2022/10/18/mit-6.828/image-20230307133719177.png" srcset="/img/loading.gif" lazyload alt="image-20230307133719177"></p>
<p>内存保护是操作系统的非常重要的一项功能，它可以防止由于用户程序崩溃对操作系统带来的破坏与影响。</p>
<p>操作系统依赖处理器的来实现内存保护。当程序试图访问无效地址或没有访问权限时，处理器在当前指令停住，引发中断进入内核。如果内核能够修复，则在刚才的指令处继续执行，否则程序将无法接着运行。系统调用也为内存保护带来了问题。大部分系统调用接口让用户程序传递一个指针参数给内核。这些指针指向的是用户缓冲区。通过这种方式，系统调用在执行时就可以解引用这些指针。但是这里有两个问题：</p>
<ol>
<li>在内核中的page fault要比在用户程序中的page fault更严重。如果内核在操作自己的数据结构时出现 page faults，这是一个内核的bug，而且异常处理程序会中断整个内核。但是当内核在解引用由用户程序传递来的指针时，它需要一种方法去记录此时出现的任何page faults都是由用户程序带来的。</li>
<li>内核通常比用户程序有着更高的内存访问权限。用户程序很有可能要传递一个指针给系统调用，这个指针指向的内存区域是内核可以进行读写的，但是用户程序不能。此时内核必须小心的去解析这个指针，否则的话内核的重要信息很有可能被泄露。</li>
</ol>
<blockquote>
<p>所以对于pageFault，我们主要分两种情况</p>
<ul>
<li><p>在内核模式发生的pagefault，直接panic</p>
</li>
<li><p>在用户模式下的pagefault，我们看看这个用户模式是否有权限访问这个这个虚拟地址空间</p>
<ul>
<li><strong>如果没有权限，那么直接给这个env给终止了。使用user_mem_check()函数来判断</strong></li>
<li><strong>如果有权限，那么我们接下来处理这个异常：这个在lab3中没有实现</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p>首先是判断是内核情况下的pagefault</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">//内核态发生缺页中断直接panic</span><br>	panic(<span class="hljs-string">&quot;page_fault_handler():page fault in kernel mode!\n&quot;</span>);<br><br></code></pre></td></tr></table></figure>

<p>再判断用户是不是有访问权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">user_mem_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 3: Your code here.</span><br>	cprintf(<span class="hljs-string">&quot;user_mem_check va: %x, len: %x\n&quot;</span>, va, len);<br>	<span class="hljs-type">uint32_t</span> begin = (<span class="hljs-type">uint32_t</span>) ROUNDDOWN(va, PGSIZE); <br>	<span class="hljs-type">uint32_t</span> end = (<span class="hljs-type">uint32_t</span>) ROUNDUP(va+len, PGSIZE);<br>	<span class="hljs-type">uint32_t</span> i;<br>	<span class="hljs-keyword">for</span> (i = (<span class="hljs-type">uint32_t</span>)begin; i &lt; end; i += PGSIZE) &#123;<br>		<span class="hljs-type">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, (<span class="hljs-type">void</span>*)i, <span class="hljs-number">0</span>);<br>		<span class="hljs-keyword">if</span> ((i &gt;= ULIM) || !pte || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm)) &#123;        <span class="hljs-comment">//具体检测规则</span><br>			user_mem_check_addr = (i &lt; (<span class="hljs-type">uint32_t</span>)va ? (<span class="hljs-type">uint32_t</span>)va : i);                <span class="hljs-comment">//记录无效的那个线性地址</span><br>			<span class="hljs-keyword">return</span> -E_FAULT;<br>		&#125;<br>	&#125;<br>	cprintf(<span class="hljs-string">&quot;user_mem_check success va: %x, len: %x\n&quot;</span>, va, len);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Checks that environment &#x27;env&#x27; is allowed to access the range</span><br><span class="hljs-comment">// of memory [va, va+len) with permissions &#x27;perm | PTE_U | PTE_P&#x27;.</span><br><span class="hljs-comment">// If it can, then the function simply returns.</span><br><span class="hljs-comment">// If it cannot, &#x27;env&#x27; is destroyed and, if env is the current</span><br><span class="hljs-comment">// environment, this function will not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">user_mem_assert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="hljs-number">0</span>) &#123;<br>		cprintf(<span class="hljs-string">&quot;[%08x] user_mem_check assertion failure for &quot;</span><br>			<span class="hljs-string">&quot;va %08x\n&quot;</span>, env-&gt;env_id, user_mem_check_addr);<br>		env_destroy(env);	<span class="hljs-comment">// may not return</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/10/18/mit-6.828/image-20230307151155518.png" srcset="/img/loading.gif" lazyload alt="image-20230307151155518"></p>
<p><img src="/2022/10/18/mit-6.828/image-20230307151246298.png" srcset="/img/loading.gif" lazyload alt="image-20230307151246298"></p>
<p><img src="/2022/10/18/mit-6.828/image-20230307151307331.png" srcset="/img/loading.gif" lazyload alt="image-20230307151307331"></p>
<h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>这个实验内容比较多，但是也是围绕进程来说的，主要有以下内容：</p>
<ol>
<li>采取多处理器模式，因为现在处理器一般都是多核的，这样每个cpu能够同时运行不同的进程，提升系统的并发性。但是采取多个cpu，就会导致可能会出现多个cpu使用内核程序的可能，所以为了解决这个cpu同时访问内核程序，这里也介绍了锁机制，本实验实现的是spinlock。</li>
<li>实现了进程调度算法</li>
<li>实现了写时拷贝fork（进程的创建）</li>
<li>实现了进程间的通信（IPC）</li>
</ol>
<h3 id="实现多处理器和协同式多任务"><a href="#实现多处理器和协同式多任务" class="headerlink" title="实现多处理器和协同式多任务"></a>实现多处理器和协同式多任务</h3><p>主要是实现jos支持多个cpu，以及实现系统调用允许普通的进程创建新的进程，实现协作式进程调度</p>
<h4 id="支持多处理器"><a href="#支持多处理器" class="headerlink" title="支持多处理器"></a>支持多处理器</h4><p>jos将支持”symmetric multiprocessing” (SMP)，这是一种所有CPU共享系统资源的多处理器模式。在启动阶段这些cpu将会被分为两类：</p>
<ol>
<li>BSP（bootstrap processor）:这个cpu服务初始化系统和启动操作系统</li>
<li>AP（application processor）： 操作系统启动后将由BSP来引导激活。</li>
</ol>
<p>在SMP模式中，每个cpu都有一个对应的local APIC单元，用来传递中断信号等，LAPIC是在CPU中的，但是LAPIC的寄存器被硬链接到内存空间的物理地址0xFE000000上，也就是通过操作这个物理地址就相当于操作了LAPIC寄存器了。cpu访问都是通过虚拟地址的，所以我们将这个物理地址映射到MMIOBASE虚拟地址处，编码时操作这个虚拟地址就相当于操作0xFE000000物理地址，就相当于操作LAPIC单元了。</p>
<p>因此下面我们首先将mmiobase映射到物理地址FE000000处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">mmio_map_region</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> base = MMIOBASE;<br><br>	size = ROUNDUP(pa+size, PGSIZE);<br>	pa = ROUNDDOWN(pa, PGSIZE);<br>	size -= pa;<br>	<span class="hljs-keyword">if</span> (base+size &gt;= MMIOLIM) panic(<span class="hljs-string">&quot;not enough memory&quot;</span>);<br>	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD|PTE_PWT|PTE_W);<br>	base += size;<br>	<span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*) (base - size);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="每个cpu包含哪些东西"><a href="#每个cpu包含哪些东西" class="headerlink" title="每个cpu包含哪些东西"></a>每个cpu包含哪些东西</h4><p><img src="/2022/10/18/mit-6.828/image-20230307213810307.png" srcset="/img/loading.gif" lazyload alt="image-20230307213810307"></p>
<ol>
<li>各种寄存器，cs，esp，eip，gdtr，idtr，cr3（内核页目录表）等等</li>
<li>TSS选择器寄存器，在jos中每个cpu还有一个TSS，用来存储对应的内核栈空间地址。</li>
<li>每个cpu都有自己独立的内核栈空间，jos分配了<code>percpu_kstacks[NCPU][KSTKSIZE]</code>一个数组8*32768大小的空间作为内核栈（<strong>这个地方应该是在内核的.data中或者.bss中，不再是之前的那个单个cpu的内核栈了，所以我们需要在内核的页表中重新映射这块申请的物理空间和虚拟地址KSTACKTOP以下的PTSIZE大小</strong>）。对应的虚拟地址是KSTCKTOP下的空间，CPU 1的内核栈将从CPU 0栈后面KSTKGAP字节处开始，以此类推。</li>
<li>进程结构指针：每个CPU都会独立运行一个进程的代码，所以需要Env指针。</li>
</ol>
<h4 id="启动其他的cpu（AP）"><a href="#启动其他的cpu（AP）" class="headerlink" title="启动其他的cpu（AP）"></a>启动其他的cpu（AP）</h4><h5 id="先收集AP信息"><a href="#先收集AP信息" class="headerlink" title="先收集AP信息"></a>先收集AP信息</h5><p>在启动其他的AP之前，BSP需要收集多处理器的信息，比如有多少个cpu，每个cpu对应的LAPIC的物理地址和LAPIC ID。我们可以在inti.c文件中的i386_init()中的mp_init()函数，这个函数就是用来收集所有的ap信息。这些信息都是保存在BIOS中的mp configuration table中，读取每个cpu的信息，然后初始化cpu[]数组，ncpu个数，bootcpu（指向BSP对应的cpuinfo结构）</p>
<blockquote>
<p>cpuinfo结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> &#123;</span><br>	<span class="hljs-type">uint8_t</span> cpu_id;                 <span class="hljs-comment">// Local APIC ID; index into cpus[] below</span><br>	<span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> cpu_status;   <span class="hljs-comment">// The status of the CPU</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">cpu_env</span>;</span>            <span class="hljs-comment">// The currently-running environment.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Taskstate</span> <span class="hljs-title">cpu_ts</span>;</span>        <span class="hljs-comment">// Used by x86 to find stack for interrupt</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>以及其他的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialized in mpconfig.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> <span class="hljs-title">cpus</span>[<span class="hljs-title">NCPU</span>];</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> ncpu;                    <span class="hljs-comment">// Total number of CPUs in the system</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> *<span class="hljs-title">bootcpu</span>;</span>     <span class="hljs-comment">// The boot-strap processor (BSP)</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">physaddr_t</span> lapicaddr;        <span class="hljs-comment">// Physical MMIO address of the local APIC </span><br><br><span class="hljs-comment">// Per-CPU kernel stacks</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> percpu_kstacks[NCPU][KSTKSIZE];<br></code></pre></td></tr></table></figure>


</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*这个函数就是用来获取处理器信息的，有多少个cpu，每个cpu对应的LAPIC ID 和每个cpu对应的LAPIC的MMIO地址</span><br><span class="hljs-comment">* 这些信息从bios中的mp configuration table 中读取的，</span><br><span class="hljs-comment">* 然后将信息存在cpus数组中，每一个元素类型就是CpuInfo类型的结构</span><br><span class="hljs-comment">* bootcpu 就是指向的保存BSP处理器信息的CpuInfo结构</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 所以这个函数就是读取bios中的处理器信息，并初始化cpus信息。后面BSP根据这个cpus数组挨个启动每个APs(在boot_abs()函数启动)</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 每个AP启动完成之后，就会执行kern/mpentry.S中的代码，然后再跳转到mp_main()函数，为当前处理器AP设置GDT,TSS等</span><br><span class="hljs-comment">* 最后将cpus[]数组中对应CpuInfo结构类型元素的cpu_status属性设置为CPU_STARTED(代表已经启动了)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mp</span> *<span class="hljs-title">mp</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mpconf</span> *<span class="hljs-title">conf</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mpproc</span> *<span class="hljs-title">proc</span>;</span><br>	<span class="hljs-type">uint8_t</span> *p;<br>	<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br><br>	bootcpu = &amp;cpus[<span class="hljs-number">0</span>];<br>	<span class="hljs-keyword">if</span> ((conf = mpconfig(&amp;mp)) == <span class="hljs-number">0</span>)<br>		<span class="hljs-keyword">return</span>;<br>	ismp = <span class="hljs-number">1</span>;<br>	lapicaddr = conf-&gt;lapicaddr;<br><br>	<span class="hljs-keyword">for</span> (p = conf-&gt;entries, i = <span class="hljs-number">0</span>; i &lt; conf-&gt;entry; i++) &#123;<br>		<span class="hljs-keyword">switch</span> (*p) &#123;<br>		<span class="hljs-keyword">case</span> MPPROC:<br>			proc = (<span class="hljs-keyword">struct</span> mpproc *)p;<br>			<span class="hljs-keyword">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)<br>				bootcpu = &amp;cpus[ncpu];<br>			<span class="hljs-keyword">if</span> (ncpu &lt; NCPU) &#123;<br>				cpus[ncpu].cpu_id = ncpu;<br>				ncpu++;<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>				cprintf(<span class="hljs-string">&quot;SMP: too many CPUs, CPU %d disabled\n&quot;</span>,<br>					proc-&gt;apicid);<br>			&#125;<br>			p += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mpproc);<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">case</span> MPBUS:<br>		<span class="hljs-keyword">case</span> MPIOAPIC:<br>		<span class="hljs-keyword">case</span> MPIOINTR:<br>		<span class="hljs-keyword">case</span> MPLINTR:<br>			p += <span class="hljs-number">8</span>;<br>			<span class="hljs-keyword">continue</span>;<br>		<span class="hljs-keyword">default</span>:<br>			cprintf(<span class="hljs-string">&quot;mpinit: unknown config type %x\n&quot;</span>, *p);<br>			ismp = <span class="hljs-number">0</span>;<br>			i = conf-&gt;entry;<br>		&#125;<br>	&#125;<br><br>	bootcpu-&gt;cpu_status = CPU_STARTED;<br>	<span class="hljs-keyword">if</span> (!ismp) &#123;<br>		<span class="hljs-comment">// Didn&#x27;t like what we found; fall back to no MP.</span><br>		ncpu = <span class="hljs-number">1</span>;<br>		lapicaddr = <span class="hljs-number">0</span>;<br>		cprintf(<span class="hljs-string">&quot;SMP: configuration not found, SMP disabled\n&quot;</span>);<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	cprintf(<span class="hljs-string">&quot;SMP: CPU %d found %d CPU(s)\n&quot;</span>, bootcpu-&gt;cpu_id,  ncpu);<br><br>	<span class="hljs-keyword">if</span> (mp-&gt;imcrp) &#123;<br>		<span class="hljs-comment">// [MP 3.2.6.1] If the hardware implements PIC mode,</span><br>		<span class="hljs-comment">// switch to getting interrupts from the LAPIC.</span><br>		cprintf(<span class="hljs-string">&quot;SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n&quot;</span>);<br>		outb(<span class="hljs-number">0x22</span>, <span class="hljs-number">0x70</span>);   <span class="hljs-comment">// Select IMCR</span><br>		outb(<span class="hljs-number">0x23</span>, inb(<span class="hljs-number">0x23</span>) | <span class="hljs-number">1</span>);  <span class="hljs-comment">// Mask external interrupts.</span><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="启动各个AP"><a href="#启动各个AP" class="headerlink" title="启动各个AP"></a>启动各个AP</h5><blockquote>
<p>每个cpu都有自己独立的内核栈空间，jos分配了<code>percpu_kstacks[NCPU][KSTKSIZE]</code>一个数组8*32768大小的空间作为内核栈（<strong>这个地方应该是在内核的.data中或者.bss中，不再是之前的那个单个cpu的内核栈了，所以我们需要在内核的页表中重新映射这块申请的物理空间和虚拟地址KSTACKTOP以下的PTSIZE大小</strong>）。对应的虚拟地址是KSTCKTOP下的空间，CPU 1的内核栈将从CPU 0栈后面KSTKGAP字节处开始，以此类推。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init_mp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span><br>	<span class="hljs-comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span><br>	<span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><br>	<span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><br>	<span class="hljs-comment">// mem_init:</span><br>	<span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><br>	<span class="hljs-comment">//          -- backed by physical memory</span><br>	<span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><br>	<span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><br>	<span class="hljs-comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span><br>	<span class="hljs-comment">//             Known as a &quot;guard page&quot;.</span><br>	<span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// LAB 4: Your code here:</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>		boot_map_region(kern_pgdir, <br>			KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP), <br>			KSTKSIZE, <br>			PADDR(percpu_kstacks[i]), <br>			PTE_W);<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>处理器启动：</p>
<p>调用的是boot_aps();我们可以看到，在这段程序中，我们会将位于mpentry.s文件程序地址给复制到0x7000处，然后再设置cpu的cs和ip的地址为0x7000处（被启动的cpu此时处于实模式）然后cpu就开始从0x7000处执行程序了，这个程序包括mpentry.s以及位于init.c文件中的mp_main()函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Start the non-boot (AP) processors.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_aps</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mpentry_start[], mpentry_end[];<br>	<span class="hljs-type">void</span> *code;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> *<span class="hljs-title">c</span>;</span><br><br>	<span class="hljs-comment">// Write entry code to unused memory at MPENTRY_PADDR</span><br>	code = KADDR(MPENTRY_PADDR);<br>	<span class="hljs-comment">//mpentry_start和mpentry_end是编译器导出符号，代表这段代码在内存（虚拟地址）中的起止位置</span><br>	<span class="hljs-comment">//接着把代码复制到MPENTRY_PADDR处,这个代码就是mpentry.S文件</span><br>	memmove(code, mpentry_start, mpentry_end - mpentry_start);<br><br>	<span class="hljs-comment">// Boot each AP one at a time</span><br>	<span class="hljs-keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;<br>		<span class="hljs-keyword">if</span> (c == cpus + cpunum())  <span class="hljs-comment">// We&#x27;ve started already.</span><br>			<span class="hljs-keyword">continue</span>;<br><br>		<span class="hljs-comment">// Tell mpentry.S what stack to use </span><br>		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;<br>		<span class="hljs-comment">// Start the CPU at mpentry_start</span><br>		lapic_startap(c-&gt;cpu_id, PADDR(code));<br>		<span class="hljs-comment">// Wait for the CPU to finish some basic setup in mp_main()</span><br>		<span class="hljs-keyword">while</span>(c-&gt;cpu_status != CPU_STARTED)<br>			;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





<blockquote>
<p>mpentry.s文件：这个文件的动作，</p>
<ul>
<li>我们可以看到它开启了分页模式，将kern_pgdir设置到cr3中，进入保护模式了，因此后面也是采用页表进行地址装换。</li>
<li>设置了这个cpu的内核栈esp</li>
<li>跳转到mp_main()函数</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* See COPYRIGHT for copyright information. */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/mmu.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/memlayout.h&gt;</span></span><br>###################################################################<br><span class="hljs-meta"># entry point for APs</span><br>###################################################################<br># Each non-boot <span class="hljs-title function_">CPU</span> <span class="hljs-params">(<span class="hljs-string">&quot;AP&quot;</span>)</span> is started up in response to a STARTUP<br># IPI from the boot CPU.  Section B.4.2 of the Multi-Processor<br># Specification says that the AP will start in real mode with CS:IP<br><span class="hljs-meta"># set to XY00:0000, where XY is an 8-bit value sent with the</span><br># STARTUP. Thus this code must start at a 4096-byte boundary.<br>#<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RELOC(x) ((x) - KERNBASE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span><br><br>.<span class="hljs-built_in">set</span> PROT_MODE_CSEG, 0x8	<span class="hljs-meta"># kernel code segment selector</span><br>.<span class="hljs-built_in">set</span> PROT_MODE_DSEG, 0x10	<span class="hljs-meta"># kernel data segment selector</span><br><br># 这里我们就是启动每一个cpu时候对cpu的初始化动作，设置cpu的一些寄存器，比如<span class="hljs-title function_">cr3</span><span class="hljs-params">(kern_pgdir)</span>/<span class="hljs-title function_">gdtr</span><span class="hljs-params">(GDT)</span>/<span class="hljs-title function_">tr</span><span class="hljs-params">(TSS)</span>/等，以及开启分页模式等等<br>.code16           <br>.globl mpentry_start     <br>mpentry_start:<br>	cli            <br>	xorw    %ax, %ax<br>	movw    %ax, %ds<br>	movw    %ax, %es<br>	movw    %ax, %ss<br><br>	lgdt    <span class="hljs-title function_">MPBOOTPHYS</span><span class="hljs-params">(gdtdesc)</span><br>	movl    %cr0, %eax<br>	orl     $CR0_PE, %eax<br>	movl    %eax, %cr0<br><br>	ljmpl   $<span class="hljs-params">(PROT_MODE_CSEG)</span>, $<span class="hljs-params">(MPBOOTPHYS(start32))</span><br><br>.code32<br>start32:<br>	movw    $<span class="hljs-params">(PROT_MODE_DSEG)</span>, %ax<br>	movw    %ax, %ds<br>	movw    %ax, %es<br>	movw    %ax, %ss<br>	movw    $0, %ax<br>	movw    %ax, %fs<br>	movw    %ax, %gs<br><br>	# Set up initial page table. We cannot use kern_pgdir yet because<br>	<span class="hljs-meta"># we are still running at a low EIP.</span><br>	movl    $<span class="hljs-params">(RELOC(entry_pgdir))</span>, %eax<br>	movl    %eax, %cr3<br>	# Turn on paging.<br>	movl    %cr0, %eax<br>	orl     $<span class="hljs-params">(CR0_PE|CR0_PG|CR0_WP)</span>, %eax<br>	movl    %eax, %cr0<br><br>	# Switch to the per-cpu <span class="hljs-built_in">stack</span> allocated in <span class="hljs-title function_">boot_aps</span><span class="hljs-params">()</span><br>	# 设置每个cpu的栈空间，位于KSTACKTOP下面，每个cpu的栈空间中间隔着一定的空间作为栈保护空间，因此我们还需要在页表中完成这个映射关系<br>	movl    mpentry_kstack, %esp  <br>	movl    $0x0, %ebp       <span class="hljs-meta"># nuke frame pointer</span><br><br>	# Call <span class="hljs-title function_">mp_main</span><span class="hljs-params">()</span>.  <span class="hljs-params">(Exercise <span class="hljs-keyword">for</span> the reader: why the indirect call?)</span><br>	movl    $mp_main, %eax<br>	call    *%eax<br><br>	# If mp_main <span class="hljs-title function_">returns</span> <span class="hljs-params">(it shouldn<span class="hljs-string">&#x27;t), loop.</span></span><br><span class="hljs-string"><span class="hljs-params">spin:</span></span><br><span class="hljs-string"><span class="hljs-params">	jmp     spin</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params"># Bootstrap GDT</span></span><br><span class="hljs-string"><span class="hljs-params">.p2align 2					# force 4 byte alignment</span></span><br><span class="hljs-string"><span class="hljs-params">gdt:</span></span><br><span class="hljs-string"><span class="hljs-params">	SEG_NULL				# null seg</span></span><br><span class="hljs-string"><span class="hljs-params">	SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg</span></span><br><span class="hljs-string"><span class="hljs-params">	SEG(STA_W, 0x0, 0xffffffff)		# data seg</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params">gdtdesc:</span></span><br><span class="hljs-string"><span class="hljs-params">	.word   0x17				# sizeof(gdt) - 1</span></span><br><span class="hljs-string"><span class="hljs-params">	.long   MPBOOTPHYS(gdt)			# address gdt</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params">.globl mpentry_end</span></span><br><span class="hljs-string"><span class="hljs-params">mpentry_end:</span></span><br><span class="hljs-string"><span class="hljs-params">	nop</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>mp_main():这个函数的动作</p>
<ul>
<li>加载cr3寄存器值为kern_pgdir</li>
<li>初始化LAPIC</li>
<li>加载GDTR寄存器</li>
<li>每个cpu都有自己的TSS描述符和对应的TSS结构，然后将栈存入到TSS的ss0和esp0中</li>
<li>然后执行一个env</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Setup code for APs  //这个函数调用在mpentry.S中，会初始化每个cpu的寄存器，页目录表地址，gdtr寄存器，idtr，tr等</span><br><span class="hljs-comment">// 我们需要注意的是，在进入mpentry.s后，就相当于多个cpu开始执行内核代码了，这就会导致资源竞争的问题，比如空间竞争等。</span><br><span class="hljs-comment">// 所以我们需要使用锁来将多个cpu进行同步</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// We are in high EIP now, safe to switch to kern_pgdir </span><br>	lcr3(PADDR(kern_pgdir));<br>	cprintf(<span class="hljs-string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());<br><br>	lapic_init();<br>	env_init_percpu();<br>	trap_init_percpu();<br>	xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="hljs-comment">// tell boot_aps() we&#x27;re up</span><br><br>	<span class="hljs-comment">// Now that we have finished some basic setup, call sched_yield()</span><br>	<span class="hljs-comment">// to start running processes on this CPU.  But make sure that</span><br>	<span class="hljs-comment">// only one CPU can enter the scheduler at a time!</span><br>	<span class="hljs-comment">//</span><br>	<span class="hljs-comment">// Your code here:</span><br>	lock_kernel();<br><br>	<span class="hljs-comment">//这里每个cpu最开始的时候会运行这个函数，以获取一个env进行运行，所以必须要获取锁，envs属于各个cpu的公共资源，所以需要加锁</span><br>	<span class="hljs-comment">//并不是所有cpu陷入内核都需要锁？因为每个cpu都有自己的栈空间，所以不是可以同时两个cpu陷入内核态</span><br>	sched_yield();<br>	<span class="hljs-comment">// // Remove this after you finish Exercise 6</span><br>	<span class="hljs-comment">// for (;;);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>现在我们知道了会有多个cpu会去访问内核代码，从而导致分配内存空间等等操作，这样就会出现竞争资源的现象，还会出现资源错乱的现象，因此我们需要将各个cpu访问内核代码时同步，也就是上锁。</p>
<p>这里是采用了一个全局的大锁，当进程从用户态进入内核态的时候就必须先获取这个锁，退出内核的时候释放锁。这样才会保证只有一个cpu访问内核代码，从而实现一个cpu来操作共享资源。这样就会出先当一个cpu指向内核代码的时候，另个cpu想要执行内核代码必须等待。</p>
<h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>jos采用的是自旋锁，什么是自旋锁呢？就是去请求锁的时候，如果请求不到，会一直尝试请求，直到获取到锁，这个会导致cpu一直处于工作状态，锁的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>	<span class="hljs-type">unsigned</span> locked;       <span class="hljs-comment">// Is the lock held?</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>我们来看看实现自旋锁的原理，根据我们上面对自旋锁的描述，就是不断的循环去请求：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span><br><span class="hljs-number">2</span> acquire(<span class="hljs-keyword">struct</span> spinlock *lk)<br><span class="hljs-number">3</span> &#123;<br><span class="hljs-number">4</span>    <span class="hljs-keyword">for</span>(;;) &#123;<br><span class="hljs-number">5</span>      <span class="hljs-keyword">if</span>(!lk-&gt;locked) &#123;<br><span class="hljs-number">6</span>          lk-&gt;locked = <span class="hljs-number">1</span>;<br><span class="hljs-number">7</span>          <span class="hljs-keyword">break</span>;<br><span class="hljs-number">8</span>      &#125;<br><span class="hljs-number">9</span>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>但是这个代码还是会出现问题的，假如执行到第5行时进入了if语句，但是还没有将locked改为1，另一个cpu也检测到了locked为0，也进入到了if语句，这样就导致了两个cpu同时获取到了锁，那和没加锁有什么区别。所以上述的代码不行，我们需要接触硬件的特点来进行加锁和解锁。</p>
<p>在kern/spinlock.c文件中，提供了上锁和解锁的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>	<span class="hljs-comment">// The xchg is atomic.</span><br>	<span class="hljs-comment">// It also serializes, so that reads after acquire are not</span><br>	<span class="hljs-comment">// reordered before it. </span><br>	<span class="hljs-keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)			<span class="hljs-comment">//原理见：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf  chapter 4</span><br>		<span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;pause&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">spin_unlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br>	<span class="hljs-comment">// The xchg instruction is atomic (i.e. uses the &quot;lock&quot; prefix) with</span><br>	<span class="hljs-comment">// respect to any other instruction which references the same memory.</span><br>	<span class="hljs-comment">// x86 CPUs will not reorder loads/stores across locked instructions</span><br>	<span class="hljs-comment">// (vol 3, 8.2.2). Because xchg() is implemented using asm volatile,</span><br>	<span class="hljs-comment">// gcc will not reorder C statements across the xchg.</span><br>	xchg(&amp;lk-&gt;locked, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span><br><span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> newval)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> result;<br>    <span class="hljs-comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock; xchgl %0, %1&quot;</span></span><br><span class="hljs-params">         : <span class="hljs-string">&quot;+m&quot;</span> (*addr), <span class="hljs-string">&quot;=a&quot;</span> (result)</span><br><span class="hljs-params">         : <span class="hljs-string">&quot;1&quot;</span> (newval)</span><br><span class="hljs-params">         : <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><strong>这里使用了xchgl指令，它可以一步完成两个地址内容之间的交换</strong></p>
<p><code>while (xchg(&amp;lk-&gt;locked, 1) != 0)</code>这个会将全局变量lk-&gt;locked和1交换，如果交互回来的值为0，说明上锁成功，如果交换回来的值为1，说明已经被别的cpu给上锁。这个指令相当于前面第5步和第6步的结合了，这里只需要一步，所以不会出现共同拥有锁的现象了。解锁操作很简单就是<code>xchg(&amp;lk-&gt;locked, 0);</code>和0交换就行了。</p>
<p>在上面我们看到在获取锁失败后，会使用pause指令，这个指令相当于一个延迟的noop空指令一样，主要是为了减少cpu的消耗。</p>
<h5 id="在哪里上锁"><a href="#在哪里上锁" class="headerlink" title="在哪里上锁"></a>在哪里上锁</h5><p>有了获取锁和释放锁的函数，我们看下哪些地方需要加锁，和释放锁：</p>
<ol>
<li>i386_init()中，BSP唤醒其它AP前需要获取内核锁。</li>
<li>mp_main()中，AP需要在执行sched_yield()前获取内核锁。</li>
<li>trap()中，需要获取内核锁，因为这是用户态进入内核的唯一入口。</li>
<li>env_run()中，需要释放内核锁，因为该函数使用iret指令，从内核返回用户态。</li>
</ol>
<p><strong>对于3和4是因为只能有一个cpu可以进入内核态，对于1和2来说，因为每个cpu都可以调度env，但是一个env只能运行在一个cpu上，因此在调度的时候，我们要加锁，保证只有一个cpu在调度env，防止一个env被多个cpu同时选择。</strong></p>
<h3 id="进程调度–-轮询调度算法"><a href="#进程调度–-轮询调度算法" class="headerlink" title="进程调度– 轮询调度算法"></a>进程调度– 轮询调度算法</h3><p>这个是实现将cpu调度和运行用户进程，一个进程同时只能在一个cpu上运行。目前采用的是抢占式的轮询调度算法，让进程主动的让出cpu给下一个进程使用。通过sched_yield()函数，当前cpu会在envs数组中选择一个离自己索引后面最近的RUNNABLE一个env去运行，全局变量curenv可以获取这个cpu正在运行的env。</p>
<ul>
<li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li>
<li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><br><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br><br>	<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">int</span> next;<br>	<span class="hljs-keyword">if</span> (curenv) &#123;<br>		start = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<br>	&#125;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NENV; i++) &#123;		<br>		next = (start + i) % NENV;<br>		<span class="hljs-comment">//遍历所有的env数组，选择一个RUNNABLE的去运行</span><br>		<span class="hljs-keyword">if</span> (envs[next].env_status == ENV_RUNNABLE) &#123;<br>			env_run(&amp;envs[next]); <span class="hljs-comment">// 运行这个进程，具体做法就是恢复这个进程的tf，并加载这个进程的页表</span><br>		&#125;<br>	&#125;<br>		<span class="hljs-comment">// //这里保证的是如果上面没有找到可执行的env，那就继续执行自己，</span><br>		<span class="hljs-comment">// 但是这个时候要看一下这个env运行的cpu是不是就是此cpu，不能一个env运行在不同的cpu上</span><br>	<span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;<br>		env_run(curenv);<br>	&#125;<br><br>	<span class="hljs-comment">// sched_halt never returns</span><br>	sched_halt();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="创建进程的系统调用fork"><a href="#创建进程的系统调用fork" class="headerlink" title="创建进程的系统调用fork"></a>创建进程的系统调用fork</h3><p>现在jos可以同时运行多个进程了，且处理器之间可以在多个进程之间切换。不过现在运行的进程都是由内核创建的，用户进程自己无法创建额外的进程。也就是说，我们马上就要实现fork这个系统调用了，这个fork是用来干嘛的？</p>
<blockquote>
<p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。</p>
<p><strong>上面的话通俗理解就是:</strong> fork是复制进程的函数，程序一开始就会产生一个进程，当这个进程(代码)执行到fork()时，fork就会复制一份原来的进程即就是创建一个新进程,我们称子进程，而原来的进程我们称为父进程，此时父子进程是共存的，他们一起向下执行代码。</p>
</blockquote>
<p>jos将fork函数作为一个用户函数来实现，而非系统调用。只不过fork里面还是会调用系统调用，只不过这样做，我们就可以实现不同形式的fork函数了。</p>
<blockquote>
<p>我们需要实现以下的系统调用：</p>
</blockquote>
<ul>
<li><p>sys_exofork()</p>
<p>这个系统调用是用来创建一个新的进程，申请一个env和页目录表，并把这个进程设置为不可运行状态，tf结构和父进程一致，在父进程的sys_exofork()函数中返回1，而在子进程中返回0（这个非常关键）</p>
</li>
<li><p>sys_env_set_status:</p>
<p>给一个进程设置成ENV_RUNNABLE 或者ENV_NOT_RUNNABLE</p>
</li>
<li><p>sys_page_alloc：为特定进程分配一个物理页，然后映射指定的虚拟地址到该物理页，比如映射异常栈空间</p>
</li>
<li><p>sys_page_map:</p>
<p>这个相当于拷贝页表，使得两个进程（父子）有相同的页表结构。</p>
</li>
<li><p>sys_page_unmap:</p>
<p>解除页映射关系。本质上就是修改进程的页目录表和页表</p>
</li>
</ul>
<blockquote>
<p>接下来我们就先实现这些系统调用：</p>
</blockquote>
<h4 id="sys-exofork-void"><a href="#sys-exofork-void" class="headerlink" title="sys_exofork(void)"></a>sys_exofork(void)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建一个新的env，并返回子进程的id</span><br><span class="hljs-type">static</span> <span class="hljs-type">envid_t</span><br><span class="hljs-title function_">sys_exofork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// Create the new environment with env_alloc(), from kern/env.c.</span><br>	<span class="hljs-comment">// It should be left as env_alloc created it, except that</span><br>	<span class="hljs-comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span><br>	<span class="hljs-comment">// from the current environment -- but tweaked so sys_exofork</span><br>	<span class="hljs-comment">// will appear to return 0.</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-type">int</span> ret;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>	<span class="hljs-comment">//在envs中获取一个env，并申请一个页表给新的env，初始化这个env的页表地址等</span><br>	ret = env_alloc(&amp;env,sys_getenvid());<br>	<span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>	<span class="hljs-comment">//设置这个env的状态 为不可运行</span><br>	env-&gt;env_status = ENV_NOT_RUNNABLE;<br>	<span class="hljs-comment">//设置父进程的Trapflame为子进程的tf，比如eip，esp等子进程的tf中的eip指向父进程调用int时的下一个指令，就是return ret</span><br>	env-&gt;env_tf = curenv-&gt;env_tf;<br>	env-&gt;env_tf.tf_regs.reg_eax =<span class="hljs-number">0</span>;<span class="hljs-comment">//新的进程从sys_exofork()的返回值应该为0</span><br>	<span class="hljs-comment">//创建完成返回子进程的id</span><br>	<span class="hljs-keyword">return</span> env-&gt;env_id;<br>	<span class="hljs-comment">// panic(&quot;sys_exofork not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数实现了申请一个新的env结构，并将他的tf设置成父进程的tf，并这个env申请一个页目录表，这里面有一个很重要<code>env-&gt;env_tf.tf_regs.reg_eax =0</code>这个是将子进程的tf中的eax寄存器设置为0，这个也是后面保证在子进程执行完sys_exofork()函数后获得为0，用来区分子进程和父进程，因为父进程会返回子进程id.</p>
<p>我们来解释一下子进程返回0，父进程返回子进程id：</p>
<p>在父进程中，我们使用fork函数，来创建一个子进程，这个时候会触发中断，然后进入这个sys_exofork中，然后创建了子进程，这个时候并没有立刻运行子进程，而是设置为不可运行，然后就返回了，返回的为子进程id，<strong>然后继续执行接下来父进程fork函数里的程序</strong>。子进程后面会被cpu调度执行，因为fork函数是创建的子进程启动后执行的第一条语句就是当时父进程进入中断的后的一条语句，也就是将eax寄存器中的值放到ret中，然后返回到fork函数，<strong>子进程是不需要继续执行fork函数剩下的部分的</strong>，所以就判断是不是0，然后直接退出这个fork函数，继续执行接下来的父进程的程序。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">envid_t</span> envid = sys_exofork(); <span class="hljs-comment">//系统调用，只是简单创建一个Env结构，并返回子进程id复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立</span><br>	<span class="hljs-keyword">if</span>(envid ==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//子进程走这里</span><br>		<span class="hljs-comment">// 子进程是怎么启动的？就是被正常调度起来的，然后调度到它之后，执行env_run，然后通过tf恢复eip，esp，等等寄存器，直接开始执行sys_exofork（这个是lib里面的）里面的int后面那条语句</span><br>		<span class="hljs-comment">// 然后进入这里了。</span><br>		thisenv = &amp;envs[ENVX(sys_getenvid())]; <span class="hljs-comment">//获取这个env结构</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>这个才能实现真正的fork函数。</p>
<h4 id="sys-env-set-status"><a href="#sys-env-set-status" class="headerlink" title="sys_env_set_status"></a>sys_env_set_status</h4><p>这个函数是给某个env的状态设置为对应的status</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将envid对应的进程状态设置成status  ENV_NOT_RUNNABLE或者ENV_RUNNABLE</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_env_set_status</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">int</span> status)</span><br>&#123;<br>	<span class="hljs-comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span><br>	<span class="hljs-comment">// envid to a struct Env.</span><br>	<span class="hljs-comment">// You should set envid2env&#x27;s third argument to 1, which will</span><br>	<span class="hljs-comment">// check whether the current environment has permission to set</span><br>	<span class="hljs-comment">// envid&#x27;s status.</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-keyword">if</span>(status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_RUNNABLE)<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>	<span class="hljs-type">int</span> ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span> )&#123;<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>	env-&gt;env_status = status;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="sys-page-alloc"><a href="#sys-page-alloc" class="headerlink" title="sys_page_alloc"></a>sys_page_alloc</h4><p>这个函数是给某个进程申请一个页，并在页表中完成映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//给某个进程申请一个页，并在页表中建立完成页表映射，这个虚拟地址va从哪里来的？</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_page_alloc</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// Hint: This function is a wrapper around page_alloc() and</span><br>	<span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><br>	<span class="hljs-comment">//   Most of the new code you write should be to check the</span><br>	<span class="hljs-comment">//   parameters for correctness.</span><br>	<span class="hljs-comment">//   If page_insert() fails, remember to free the page you</span><br>	<span class="hljs-comment">//   allocated!</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>	<span class="hljs-type">int</span> ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">return</span> -E_BAD_ENV;<br>	&#125;<br>	<span class="hljs-comment">//判断虚拟地址是否超过UTOP，判断地址是否是页对齐的</span><br>	<span class="hljs-keyword">if</span>((va &gt;= (<span class="hljs-type">void</span> *)UTOP) ||(ROUNDDOWN(va, PGSIZE) != va))<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	<span class="hljs-type">int</span> flag = PTE_U | PTE_P;<br>	<span class="hljs-comment">//判断权限是否正常</span><br>	<span class="hljs-keyword">if</span>((perm &amp; flag) != flag) <span class="hljs-keyword">return</span> E_INVAL;<br>	<span class="hljs-comment">//申请一页内存</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> =</span> page_alloc(<span class="hljs-number">1</span>);<br>	<span class="hljs-comment">//判断页面是否申请成功</span><br>	<span class="hljs-keyword">if</span>(!pg) <span class="hljs-keyword">return</span> -E_NO_MEM;<br>	<span class="hljs-comment">//插入到自己的页表中,也就是做好虚拟地址和物理地址的映射</span><br>	ret = page_insert(env-&gt;env_pgdir,pg,va,perm);<br>	<span class="hljs-keyword">if</span>(ret)&#123;<br>		<span class="hljs-comment">//进入这里表示建立映射失败，需要将刚才申请的页给释放掉</span><br>		page_free(pg);<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="sys-page-map"><a href="#sys-page-map" class="headerlink" title="sys_page_map"></a>sys_page_map</h4><p>这个函数是将源srcenv的虚拟地址srcva对应的物理页 给映射到目的dstenv的虚拟地址dstva上去。</p>
<p>也就是这两个进程的srcva和dstva都在各自的进程中映射到了相同的物理页上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_page_map</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> srcenvid, <span class="hljs-type">void</span> *srcva,</span><br><span class="hljs-params">	     <span class="hljs-type">envid_t</span> dstenvid, <span class="hljs-type">void</span> *dstva, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// Hint: This function is a wrapper around page_lookup() and</span><br>	<span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><br>	<span class="hljs-comment">//   Again, most of the new code you write should be to check the</span><br>	<span class="hljs-comment">//   parameters for correctness.</span><br>	<span class="hljs-comment">//   Use the third argument to page_lookup() to</span><br>	<span class="hljs-comment">//   check the current permissions on the page.</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">se</span>, *<span class="hljs-title">de</span>;</span><br>	<span class="hljs-type">int</span> ret = envid2env(srcenvid,&amp;se,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span>(ret) <span class="hljs-keyword">return</span> ret;<br>	ret = envid2env(dstenvid,&amp;de,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span>(ret) <span class="hljs-keyword">return</span> ret;<br>	<span class="hljs-comment">//判断虚拟地址是否超过了UTOP，判断srcva和dstva是否是页对其的</span><br>	<span class="hljs-keyword">if</span>(srcva &gt;=(<span class="hljs-type">void</span> *)UTOP || dstva &gt;= (<span class="hljs-type">void</span> *)UTOP ||<br>		ROUNDDOWN(srcva,PGSIZE) != srcva|| ROUNDDOWN(dstva,PGSIZE) !=dstva)&#123;<br>			<span class="hljs-keyword">return</span> -E_INVAL;<br>		&#125;<br>	<span class="hljs-type">pte_t</span> *pte;<br>	<span class="hljs-comment">//这个函数是返回虚拟地址srcva对应的实际物理页，保存在pte指向的地址中</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> =</span> page_lookup(se-&gt;env_pgdir,srcva,&amp;pte);<br>	<span class="hljs-comment">//这个是判断src进程对应的虚拟地址是否有物理页存在（是否完成映射，因为后面要将dst的虚拟地址映射到这个物理地址）</span><br>	<span class="hljs-keyword">if</span>(!pg)&#123;<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	<span class="hljs-type">int</span> flag = PTE_U|PTE_P;<br>	<span class="hljs-comment">//判断权限是否正确</span><br>	<span class="hljs-keyword">if</span>((perm &amp; flag) !=flag) <span class="hljs-keyword">return</span> -E_INVAL;<br>	<span class="hljs-comment">//判断这个页面是否可写，srcva对应的页面一般read_only</span><br>	<span class="hljs-comment">//将子进程的页表中的对应的父进程的页的权限都改成只读的（权限设置在页表项的低12位）----这个很重要，因为这样在子进程想要修改父进程的页的时候，就会触发pagefault</span><br>	<span class="hljs-keyword">if</span>((*pte &amp; PTE_W) == <span class="hljs-number">0</span> &amp;&amp; (perm &amp; PTE_W)) <span class="hljs-keyword">return</span> -E_INVAL;<br><br>	<span class="hljs-comment">//经过上面的一些列判断后，我们将de进程的虚拟地址dstva映射到srcva对应的物理地址去</span><br>	ret = page_insert(de-&gt;env_pgdir,pg,dstva,perm);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// panic(&quot;sys_page_map not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="sys-page-unmap"><a href="#sys-page-unmap" class="headerlink" title="sys_page_unmap"></a>sys_page_unmap</h4><p>这个函数用来将一个进程的va对应的物理页关系给删除掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_page_unmap</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">void</span> *va)</span><br>&#123;<br>	<span class="hljs-comment">// Hint: This function is a wrapper around page_remove().</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>	<span class="hljs-type">int</span> ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span>(ret)&#123;<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(va &gt;= (<span class="hljs-type">void</span> *)UTOP || ROUNDDOWN(va,PGSIZE) != va)&#123;<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	page_remove(env-&gt;env_pgdir,va);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// panic(&quot;sys_page_unmap not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Copy-On-Write-写时拷贝"><a href="#Copy-On-Write-写时拷贝" class="headerlink" title="Copy On Write 写时拷贝"></a>Copy On Write 写时拷贝</h4><p>实现fork的方式有很多种，一种是将父进程的内容全部都copy一遍，这样的话子进程和父进程就能够做到进程隔离，但是这个十分的浪费时间和空间。</p>
<p>另一个方式就是写时拷贝的技术，这个方式就是父进程在创建子进程的时候，只会讲自己的页目录和页表复制给子进程，这样父进程和子进程既可以访问相同的内容。只有当一方指向写操作时，才会复制这一目录页。这样既能够做到地址空间的隔离，又能省区大量的拷贝</p>
<h5 id="用户级别页异常"><a href="#用户级别页异常" class="headerlink" title="用户级别页异常"></a>用户级别页异常</h5><p>这里实现了，我们可以在用户级别来处理由用户进程产生的page_fault，那我们需要注册页错误处理函数，需要实现一个sys_env_set_pgfault_upcall()系统调用提供支持。这个系统调用是在内核态操作某个env结构，然后将这个env结构中的页错误处理函数指针指向我们提供的统一页错误处理函数入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个函数是设置用户自己的pagefault处理函数，这个func就是_pgfault_upcall，就是缺页中断的总入口，位于pfentry.S文件中</span><br><span class="hljs-comment">//也就是这个函数设置进程缺页异常的入口</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_env_set_pgfault_upcall</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">void</span> *func)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>	<span class="hljs-type">int</span> ret;<br>	ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br>	<span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span> )&#123;<br>		<span class="hljs-keyword">return</span> -E_BAD_ENV;<br>	&#125;<br>	<span class="hljs-comment">//这个是执行用户进程自己的处理函数,所以设置成用户提供的函数func</span><br>	<span class="hljs-comment">//最后就是在这里设置了用户缺页入口程序</span><br>	env-&gt;env_pgfault_upcall = func;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h5 id="page-fault-handler"><a href="#page-fault-handler" class="headerlink" title="page_fault_handler"></a>page_fault_handler</h5><p>这个函数就是在cpu发生页错误的时候，就会触发中断，从而进入trap（），然后调用这个page_fault_handler函数，处理页错误。我们上面说了我们会把页错误处理交给用户操作，那么如何实现的呢？</p>
<p>首先我们先介绍以下异常栈：就是用户进程执行异常函数的时候所使用的栈，这个栈的虚拟地址为UXSTACKTOP，<strong>也就是当正在处于用户态的程序发生页错误，会进入内核态，然后在内核中设置env的一些esp和eip之后重启这个进程，让他运行页错误处理程序，使用的栈是异常栈。</strong></p>
<p><strong>那么如何从异常栈继续恢复到原来的栈，我们这里维护了一个UTrapframe结构，它就是用来保存发生页错误时的esp和eip等寄存器的值。然后在用户页错误处理完成之后，恢复错误之前的esp和eip值。这个不需要再进入到内核态。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UTrapframe</span> &#123;</span><br>	<span class="hljs-comment">/* information about the fault */</span><br>	<span class="hljs-type">uint32_t</span> utf_fault_va;	<span class="hljs-comment">/* va for T_PGFLT, 0 otherwise */</span><br>	<span class="hljs-type">uint32_t</span> utf_err;<br>	<span class="hljs-comment">/* trap-time return state */</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">utf_regs</span>;</span><br>	<span class="hljs-type">uintptr_t</span> utf_eip;<br>	<span class="hljs-type">uint32_t</span> utf_eflags;<br>	<span class="hljs-comment">/* the trap-time stack to return to */</span><br>	<span class="hljs-type">uintptr_t</span> utf_esp;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure>

<blockquote>
<p>page_fault_handler()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个tf是在内核栈中的，保存了一些进程进入中断时的一些信息</span><br><span class="hljs-comment">//这个函数时页面异常处理程序，好像是通过UTrapframe进行直接中断返回，而不是从Tramframe回去的（这一点需要关注）</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>	<span class="hljs-type">uint32_t</span> fault_va;<br><br>	<span class="hljs-comment">// Read processor&#x27;s CR2 register to find the faulting address</span><br>	<span class="hljs-comment">//cr2寄存器是用来存储发生page fault 时的线性地址</span><br>	fault_va = rcr2();<br>	<span class="hljs-comment">// panic(&quot;page_fault in kernel mode, fault address %d\n&quot;, fault_va);</span><br>	<span class="hljs-comment">// Handle kernel-mode page faults.</span><br><br>	<span class="hljs-comment">// LAB 3: Your code here. //这个是判断是不是内核程序发生的页错误</span><br>	<span class="hljs-keyword">if</span>((tf-&gt;tf_cs &amp; <span class="hljs-number">0x3</span>) == <span class="hljs-number">0</span>) &#123;<br>        panic(<span class="hljs-string">&quot;page_fault in kernel mode, fault address %d\n&quot;</span>, fault_va);<br>    &#125;<br>	<span class="hljs-comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span><br>	<span class="hljs-comment">// the page fault happened in user mode.</span><br><br>	<br>	<span class="hljs-comment">// Hints:</span><br>	<span class="hljs-comment">//   user_mem_assert() and env_run() are useful here.</span><br>	<span class="hljs-comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span><br>	<span class="hljs-comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UTrapframe</span> *<span class="hljs-title">utf</span>;</span><br>	<span class="hljs-keyword">if</span>(curenv-&gt;env_pgfault_upcall)&#123;<br>		<span class="hljs-comment">//这一步是判断是不是之前已经在异常栈中了，（也就是上面说的递归陷入了）</span><br>		<span class="hljs-comment">//如果之前没有在异常栈中，那么UTrapframe结构从UXSTACKTOP这里开始</span><br>		<span class="hljs-comment">//如果之前在异常栈中，那么就紧接着一个UTrapframe 再加一字节空位 开始</span><br>		<span class="hljs-comment">//也就是这里的stacktop位置</span><br>		<span class="hljs-keyword">if</span> (UXSTACKTOP - PGSIZE &lt;= tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt;= UXSTACKTOP - <span class="hljs-number">1</span>)<br>            utf = (<span class="hljs-keyword">struct</span> UTrapframe *)(tf-&gt;tf_esp - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UTrapframe) - <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">else</span><br>            utf = (<span class="hljs-keyword">struct</span> UTrapframe *)(UXSTACKTOP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UTrapframe));<br>		user_mem_assert(curenv, (<span class="hljs-type">void</span> *)utf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UTrapframe), PTE_U | PTE_W);<br>		<br>		<span class="hljs-comment">//初始化这个异常栈，直接从这里回去了用户模式(虽然是内核态，但是这个页表依然是env的页表，因为只有在env进程切换的时候才会更新cr3,每个env页表都复制了内核的页表)，这个utf就是为了恢复回到发生异常时候的环境，</span><br>                 <span class="hljs-comment">// 所以要用tf中的值来初始化utf</span><br>		utf-&gt;utf_fault_va = fault_va;<br>		utf-&gt;utf_err = tf-&gt;tf_err;<br>		utf-&gt;utf_regs = tf-&gt;tf_regs;<br>		utf-&gt;utf_eflags = tf-&gt;tf_eflags;<br>		utf-&gt;utf_eip = tf-&gt;tf_eip;   <span class="hljs-comment">//这个tf_eip应该是用户程序发生中断时的eip</span><br>		utf-&gt;utf_esp = tf-&gt;tf_esp;   <span class="hljs-comment">//这个tf_esp应该是用户的用户栈esp          ////UXSTACKTOP栈上需要保存发生缺页异常时的%esp和%eip</span><br><br>		<span class="hljs-comment">//设置进程eip指向页异常用户处理程序，当从内核态返回到用户态的时候，直接执行异常处理程序，使用的栈是异常栈，不过这个映射都是在env的页表中</span><br>		tf-&gt;tf_eip = (<span class="hljs-type">uint32_t</span>)curenv-&gt;env_pgfault_upcall;  <span class="hljs-comment">//这个会在执行env_pop_tf这个函数的时候，开开始执行这个函数，在pfentry.S文件</span><br>		<span class="hljs-comment">//使用的栈就是UXSTACKTOP，从utf下面开始，</span><br>		tf-&gt;tf_esp = (<span class="hljs-type">uint32_t</span>)utf;<br>		<span class="hljs-comment">//回到用户模式，经过一系列的pop，记忆最后的iret命令，到了env_pgfault_upcall这里，并且此时栈变成了异常栈utf（并不是用户栈，所以这里完成了从内核栈-&gt;异常栈的转换）</span><br>		env_run(curenv); <span class="hljs-comment">//此时的栈还是内核栈，后面env_pop_tf的pop都是pop的Trapframe结构，然后完成内核栈-&gt;异常栈，并执行pgfault_upcall函数(在用户模式下执行异常处理程序，使用的栈是异常栈)</span><br>	&#125;<br>	<span class="hljs-comment">// Destroy the environment that caused the fault.</span><br>	cprintf(<span class="hljs-string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,<br>		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);<br>	print_trapframe(tf);<br>	env_destroy(curenv);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>当发生页错误的时候，进入到内核态进入这个函数，这个函数将utf压入到异常栈的地方UXSTACKTOP处，然后设置tf的esp为异常栈处之下的一个UTrapframe处，然后将tf-&gt;eip设置为env_pgfault_upcall这个地址处的函数，也就是pfentry.S文件中的那个函数，之前都设置好了，然后env_run(curenv);这个时候就会回到用户态然后开始指向页错误处理函数，并使用异常栈。</strong></p>
<p>现在我们就将目光转到<code>pfentry.S</code>文件，这个是内核提供的库函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 现在都是在用户态下运行程序</span><br>.text<br>.globl _pgfault_upcall  <span class="hljs-comment">//这个函数是从异常栈转换为用户栈，执行env_run()函数的时候，有一个env_pop_tf()函数将eip设置成这个函数入口，栈变成异常栈</span><br>_pgfault_upcall:        <span class="hljs-comment">//1. 现在我们是在异常栈下，并且是用户态</span><br>	<span class="hljs-comment">// Call the C page fault handler.</span><br>	pushl %esp			<span class="hljs-comment">// function argument: pointer to UTF</span><br>	movl _pgfault_handler, %eax   <span class="hljs-comment">//这个_pgfault_handler函数就是用户自定义的函数，也是实际的缺页异常处理函数</span><br>	call *%eax           <span class="hljs-comment">//调用页处理函数</span><br>	addl $<span class="hljs-number">4</span>, %esp			<span class="hljs-comment">// pop function argument</span><br>	<br>        <br>	<span class="hljs-comment">//下面就是从异常栈切换到用户栈</span><br><br>	<span class="hljs-comment">//参考这个https://blog.csdn.net/wysiwygo/article/details/104459969</span><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	movl <span class="hljs-number">48</span>(%esp), %ebp<br>    subl $<span class="hljs-number">4</span>, %ebp<br>    movl %ebp, <span class="hljs-number">48</span>(%esp) <span class="hljs-comment">// 前面三步就是完成旧的esp-4，为了放旧的eip</span><br>    movl <span class="hljs-number">40</span>(%esp), %eax <span class="hljs-comment">// 将旧的eip放到旧的esp-4处，为了后面使用ret指令</span><br>    movl %eax, (%ebp)<br><br><br>	<span class="hljs-comment">// Restore the trap-time registers.  After you do this, you</span><br>	<span class="hljs-comment">// can no longer modify any general-purpose registers.</span><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	addl $<span class="hljs-number">8</span>,%esp<br>	popal<br>	<span class="hljs-comment">// Restore eflags from the stack.  After you do this, you can</span><br>	<span class="hljs-comment">// no longer use arithmetic operations or anything else that</span><br>	<span class="hljs-comment">// modifies eflags.</span><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	addl $<span class="hljs-number">4</span>,%esp<br>	popfl<br>	<span class="hljs-comment">// Switch back to the adjusted trap-time stack.</span><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	popl %esp <span class="hljs-comment">//现在这个esp中指向的就是旧的esp-4的位置，这里存放的是旧的eip</span><br>	<span class="hljs-comment">// Return to re-execute the instruction that faulted.</span><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	ret  <span class="hljs-comment">//这里十分巧妙， ret会读取esp指向的第一个内容， 也就是我们前面写入的旧的eip（也就是异常发生的位置），（ret相当于pop %eip，会自动将esp+0x4）</span><br><br></code></pre></td></tr></table></figure>

<p>可以看到会调用_pgfault_handler函数，这个函数就是真正的页错误处理函数，它是一个全局变量，前面在</p>
<p><code>sys_env_set_pgfault_upcall(envid_t envid, void *func)</code>这个函数中进行设置的。然后处理完页错误之后，接下来就是恢复进程继续执行之前发生页错误地方的程序，并将esp指向原来的栈。怎么恢复呢？</p>
<p>我们都知道在异常栈我们压入了一个UTrapframe结构，保存了之前的esp和eip，现在esp指向异常栈，我们可以先将utf中的esp（旧esp）减4，用来存储旧的eip，然后将旧的eip存在旧栈中，然后让esp指向旧esp-4</p>
<p>的地方，然后执行ret指令，就会跳转到eip处指令，并恢复esp。</p>
<blockquote>
<p>那个函数完成的异常处理函数注册的？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参数是一个函数指针，这个函数的参数是个UTrapframe  这个传入的参数就是在pfentry.S中的_pgfault_handler()函数</span><br><span class="hljs-comment">//这个函数在用户程序中调用</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">set_pgfault_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> (*handler)(<span class="hljs-keyword">struct</span> UTrapframe *utf))</span><br>&#123;<br>	<span class="hljs-type">int</span> r;<br><br>	<span class="hljs-keyword">if</span> (_pgfault_handler == <span class="hljs-number">0</span>) &#123;<br>		<span class="hljs-comment">// First time through!</span><br>		<span class="hljs-comment">// LAB 4: Your code here.</span><br>		<span class="hljs-comment">//分配一个异常栈</span><br>		<span class="hljs-comment">// First time through!</span><br>		<span class="hljs-comment">//如果是第一次进入这个函数，那么我们先申请一个异常页作为我们的异常栈</span><br>		<span class="hljs-keyword">if</span> ((r = sys_page_alloc(thisenv-&gt;env_id, (<span class="hljs-type">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="hljs-number">0</span>)<br>			panic(<span class="hljs-string">&quot;set_pgfault_handler: %e&quot;</span>, r);<br>			<span class="hljs-comment">//申请完成异常页之后，我们设置这个env的缺页异常处理函数入口，也就是pfentry.S中的那个函数（他会去调用真正的缺页处理函数--也就是上面那个参数handler）</span><br>		sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall);<br>		<span class="hljs-comment">// if(r&lt;0)&#123;</span><br>		<span class="hljs-comment">// 	panic(&quot;set_pgfault_handler: sys_env_set_pgfault_upcall() failed&quot;);</span><br>		<span class="hljs-comment">// &#125;</span><br>	&#125;<br>	<span class="hljs-comment">// Save handler pointer for assembly to call.</span><br>	<span class="hljs-comment">//真正处理缺页异常的函数</span><br>	_pgfault_handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>整理以下这个页错误处理过程</strong></p>
</blockquote>
<ol>
<li><p>发生异常前，用户已经向内核注册自定义的页面处理程序，并为自己的异常栈分配一页物理页面</p>
</li>
<li><p>用户态发生页面错误，走正常的中断处理程序，陷入内核态切换到内核栈、进入<code>trap()</code></p>
</li>
<li><p>根据中断号发现是页面错误，调用<code>page_fault_handler()</code>进行处理</p>
</li>
<li><p>检测trap frame的<code>tf_cs</code>发现是用户态发生的错误</p>
</li>
<li><p>判断是否有用户自定义页面异常处理程序：如果没有，销毁环境</p>
</li>
<li><p>如果有，准备转向用户态处理异常：</p>
<ul>
<li><p>检查tf_esp，若在[UXSTACKTOP-PGSIZE, UXSTACKTOP)范围内说明是在用户的页面处理程序内发生了异常，则将当前的栈指针视为栈顶，压栈前检查栈是否越界：利用user_mem_assert()，根据memlayout.h所示USTACKTOP到UXSTACKTOP-PGSIZE之间有一段Empty Memory，用户无权读写。先压入4个空字节再压入UTrapframe结构的各寄存器参数</p>
</li>
<li><p>如果不在，则将<code>UXSTACKTOP</code>视为栈顶，压入<code>UTrapframe</code>结构，<strong>保存env-&gt;tf中的eip和esp</strong></p>
</li>
<li><p>设置当前用户栈指针<code>tf-&gt;tf_esp</code>指向异常栈压入<code>UTrapframe</code>后的栈顶</p>
</li>
<li><p>设置当前用户下一条执行代码<code>tf-&gt;tf_eip</code>为用户异常处理程序<code>env_pgfault_upcall</code></p>
</li>
</ul>
</li>
</ol>
<p>最后重启这个env，就会去执行页错误处理程序去了，执行完之后就会恢复原来的状态。</p>
<p><img src="/2022/10/18/mit-6.828/lab4_4_%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" srcset="/img/loading.gif" lazyload alt="JOS缺页异常处理逻辑"></p>
<h5 id="实现写时拷贝的fork"><a href="#实现写时拷贝的fork" class="headerlink" title="实现写时拷贝的fork"></a>实现写时拷贝的fork</h5><p>我们先分析一下fork的流程：</p>
<ol>
<li>首先我们先调用**set_pgfault_handler()**，将pgfault()设置为页面错误处理函数以及设置父进程env的页错误处理函数入口地址</li>
<li>然后父进程调用sys_exofork函数，创建一个env子进程，并为子进程申请一个页表并初始化UTOP上的映射关系（内核的映射关系），然后将父进程的tf复制到子进程的tf中，但是要把子进程的tf的eax设置为0，标志这个是个子进程，这个很关键</li>
<li>创建完成子进程之后，我们要将父进程的页目录表和页表的映射关系给复制到子进程的页目录表和页表中。也就是我们对任意有写权限和cow（copy on write）的USTACKTOP一下的页面，父进程调用duppage()函数将其映射到子进程地址空间，并将父进程和子进程页表中的权限改为只读和cow标志<ul>
<li>为什么只读，因为采用的是cow方式，当父进程和子进程同时映射一块物理内存的时候，如果这个时候有一个进程想写，就必须触发页错误，这个错误是由处理器产生的。</li>
<li><strong>我们必须先将子进程的页表中的权限设置为PTE_COW，然后再设置父进程的，为什么？</strong><ul>
<li><a target="_blank" rel="noopener" href="https://ypl.coffee/6-828-2018-lab4/">https://ypl.coffee/6-828-2018-lab4/</a></li>
<li>因为设置子进程页表项权限是在父进程设置的，会写栈，如果提前设置cow，那么就会触发页错误而申请新的空间当作栈，并设置为可写的，但是后面再去映射子进程的时候，会把这个物理页在子进程中设置为cow，他俩就不一致了，出现错误。</li>
</ul>
</li>
<li>子进程的异常栈需要单独设置，因为异常栈是就是用来处理页错误异常的，不能标志位cow，不然就会一直错误下去。</li>
</ul>
</li>
<li>然后再父进程中设置子进程的env的页错误处理程序入口地址</li>
<li>然后父进程设置子进程的装填为RUNNABLE，这样子进程就可以被cpu调度到了。</li>
</ol>
<h5 id="实际页错误处理函数"><a href="#实际页错误处理函数" class="headerlink" title="实际页错误处理函数"></a>实际页错误处理函数</h5><p>也就是发生页错误的时候（往cow或只读的页面写操作时，就会发生）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">pgfault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> UTrapframe *utf)</span><br>&#123;<br>	<span class="hljs-type">void</span> *addr = (<span class="hljs-type">void</span> *) utf-&gt;utf_fault_va;    <span class="hljs-comment">//发生异常的时候的地址</span><br>	<span class="hljs-type">uint32_t</span> err = utf-&gt;utf_err;<br>	<span class="hljs-type">int</span> r;<br><br>	<span class="hljs-comment">// Check that the faulting access was (1) a write, and (2) to a</span><br>	<span class="hljs-comment">// copy-on-write page.  If not, panic.</span><br>	<span class="hljs-comment">// Hint:</span><br>	<span class="hljs-comment">//   Use the read-only page table mappings at uvpt</span><br>	<span class="hljs-comment">//   (see &lt;inc/memlayout.h&gt;).</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-comment">//通过这个uvpt能够取得这个虚拟地址对应的页表项，这个页表项的后12位是用来标记它指定的页的权限</span><br>	<span class="hljs-comment">//https://blog.csdn.net/weixin_43344725/article/details/89382013</span><br>	<span class="hljs-keyword">if</span>((err &amp; FEC_WR)==<span class="hljs-number">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW)==<span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;pgfault: it&#x27;s not writable or attempt to access a non-cow page!&quot;</span>);<br>	&#125;<br>	<span class="hljs-comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span><br>	<span class="hljs-comment">// copy the data from the old page to the new page, then move the new</span><br>	<span class="hljs-comment">// page to the old page&#x27;s address.</span><br>	<span class="hljs-comment">// Hint:</span><br>	<span class="hljs-comment">//   You should make three system calls.</span><br><br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-comment">//获取这个进程的id</span><br>	<span class="hljs-type">envid_t</span> envid = sys_getenvid();<br>	<span class="hljs-comment">//申请一个页面，然后将物理地址映射到PFTEMP去了</span><br>	<span class="hljs-keyword">if</span>((r = sys_page_alloc(envid,(<span class="hljs-type">void</span> *)PFTEMP,PTE_P|PTE_W|PTE_U))&lt;<span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;pgfault: page allocation failed %e&quot;</span>, r);<br>	&#125;<br>	<span class="hljs-comment">//addr就是发生缺页中断时的地址，将这个addr取整，获取到这个页的地址</span><br>	addr = ROUNDDOWN(addr,PGSIZE);<br>	<span class="hljs-comment">//然后将这个页的内容复制到刚才申请的PFTEMP中去</span><br>	memmove(PFTEMP,addr,PGSIZE);<br>	<span class="hljs-comment">//解除这个addr和指定物理地址的映射</span><br>	<span class="hljs-keyword">if</span>((r - sys_page_unmap(envid,addr))&lt;<span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;pgfault: page unmap failed %e&quot;</span>, r);<br>	&#125;<br>	<span class="hljs-comment">//因为上面我们解除了addr和物理页面的映射，现在我们想将addr映射到PFTEMP对应的物理地址去，这样下次再访问addr是，找到的物理地址就是新的物理地址</span><br>	<span class="hljs-comment">//并且这个新的物理页可读可写了已经，之前访问的都是父进程的，可读不可写</span><br>	<span class="hljs-keyword">if</span>((r = sys_page_map(envid,PFTEMP,envid,addr,PTE_P|PTE_W|PTE_U))&lt;<span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;pgfault: page map failed %e&quot;</span>, r);<br>	&#125;<br>	<span class="hljs-comment">//经过上面，我们现在有两块虚拟页映射到了同一块新申请的物理地址</span><br>	<span class="hljs-comment">//接下来我们将解除PFTEMP虚拟地址和物理地址的映射关系</span><br>	<span class="hljs-keyword">if</span>((r = sys_page_unmap(envid,PFTEMP))&lt;<span class="hljs-number">0</span>)&#123;<br>		panic(<span class="hljs-string">&quot;pgfault: page unmap failed %e&quot;</span>, r);<br>	&#125;<br>	<span class="hljs-comment">//这样我们就完成了缺页异常处理的全部功能：就是将父进程的物理页内容重新赋值一份出来，然后更改子进程的页表映射关系，将子进程相同的虚拟地址映射</span><br>	<span class="hljs-comment">//到不同的物理页面上，这样就完成了子进程和父进程的隔离</span><br><br>	<span class="hljs-comment">// panic(&quot;pgfault not implemented&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>基本步骤如下：</strong></p>
<p>当发生页错误的时候，就会到这里来。</p>
<ul>
<li>首先检测是不是写页面时发生的错误（错误码为FEC_WR）且页面被标记为PTE_COW，如果不是这种情况，就会直接panic</li>
<li>然后处理进程的页错误，首先是我们会重新申请一块物理内存并将他映射到虚拟地址PFTEMP处，将映射关系存放在这个进程的页表中，并将这个PDE和PTE的权限改成可写权限。然后再将发生页错误的物理地址的内容复制到刚申请的物理内存去，并在这个进程的页表中解除发生页错误的虚拟地址和物理地址之间的映射（如果这个物理地址的引用为0，就会被释放，如果没有就继续存在）</li>
<li>父子进程都会做上面的动作，在对被标志了cow页面进行写操作时。最后那个最开始的页面就会被释放掉了。</li>
</ul>
<blockquote>
<p>先fork映射页表关系</p>
</blockquote>
<p><img src="/2022/10/18/mit-6.828/image-20230309115148597.png" srcset="/img/loading.gif" lazyload alt="image-20230309115148597"></p>
<blockquote>
<p>发生页错误</p>
</blockquote>
<p><img src="/2022/10/18/mit-6.828/image-20230309115731416.png" srcset="/img/loading.gif" lazyload alt="image-20230309115731416"></p>
<h3 id="抢占式任务处理"><a href="#抢占式任务处理" class="headerlink" title="抢占式任务处理"></a>抢占式任务处理</h3><h4 id="时钟中断和抢占"><a href="#时钟中断和抢占" class="headerlink" title="时钟中断和抢占"></a>时钟中断和抢占</h4><p>到目前为止，我们采用的协同式多任务机制，采用的是用户自己调用sys_yield去主动的让出cpu，但是这种方式会带来其他任务无法获得cpu的机会，因此我们借助硬件来完成中断式的抢占任务。</p>
<p>我们基于cpu的时钟中断，在我们的中断表中安装相应的外部中断描述符，然后设置好对应的始终中断处理程序，在trap.c的init中处理。</p>
<p>外部中断（即设备中断），总共有16中可能的外部中断，``picirq.c<code>中的</code>pic_init<code>映射了编号0-15的外部中断到IDT表中，其表项索引为</code>IRQ_OFFSET～IRQ_OFFSET+15（32-47）。也就是当0-15的外部中断发生后，就会被cpu给转到IDT的32-47中断索引对应的中断处理程序上去。（在这个过程，也需要特权级的检测），我们这里使用的了<strong>32号的时钟中断</strong>。</p>
<p>我们在jos中对xv6进行了简化，在内核态的时候禁用外部中断（也就是进入内核态就将中断使能关闭了）。我们如何控制了？外部中断的控制在<code>寄存器elfags</code>的FL_IF标志位，这个位置为1的时候表示开启中断，即在进入内核态的时候置为0，离开内核态的时候置为1.</p>
<p>我们在bootloader的时候关闭了中断，因为内核在启动的时候是不允许开中断的，使用cli关闭了中断。</p>
<p>我们需要在<code>kern/env.c env_alloc()</code>中添加一句<code>e-&gt;env_tf.tf_eflags |= FL_IF</code>这个保存在tf中，会在恢复用户天的时候设置中断开启（很关键的一步）</p>
<p>但是我们还要注意在中断表的描述符设置的时候，我们需要将其设置为<code>中断门</code>，不能设置为<code>陷阱门</code>,我们可以看SETGATE上面的描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">An interrupt that vectors through an interrupt gate resets IF, thereby preventing other interrupts from interfering with the current interrupt handler<br>  An interrupt through a trap gate does not change IF.<br></code></pre></td></tr></table></figure>

<p>也就是说中断门会给IF标志位设为0（屏蔽了外部中断，这样就不会发生嵌套的中断），而陷阱门不会。</p>
<p>如果我们允许一些中断可以相互嵌套，那么就可以将这个设置为1，也就是将他设置为陷阱门</p>
<p><strong>当我们进入时钟中断时，他的处理逻辑就是响应中断，然后调用sched_yield()这个函数主动让出cpu</strong></p>
<h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h3><p>IPC–inter-process conmmunication</p>
<p>先在每个进程已经处于独立运行的状态了，进程间的通信还没有实现,我们这里实现一个简单的IPC机制，像pipe管道这种方式我们等会也要去了解和分析。</p>
<p>在jos中我们增加了两个系统调用来供用户进程之间的通信。<code>sys_ipc_recv</code>和<code>sys_ipc_send</code>。</p>
<p>在用户进程之间的传递消息主要包含两个：</p>
<ol>
<li>一个32为的值value</li>
<li>一个页面的映射</li>
</ol>
<p>允许一个页面的映射是保证一次通信可以传递更多的内容。</p>
<h4 id="单个value传递"><a href="#单个value传递" class="headerlink" title="单个value传递"></a>单个value传递</h4><p>调用者会调用sys_ipc_recv来接受消息，这个函数会进入中断，然后设置自己的env为等待接收消息状态，在等待进程消息状态，任何一个进程都可以向这个进程发送消息，然后让出cpu，等待消息</p>
<p>发送者会调用sys_ipc_send函数，并将接收者的进程id和消息作为参数，向指定的进程发送消息。然后去envs数组中找到这个env就将消息给他，并唤醒这个env，返回0.</p>
<h4 id="页面传递"><a href="#页面传递" class="headerlink" title="页面传递"></a>页面传递</h4><p>接收进程会调用一个sys_ipc_recv函数并提供一个有效的地址dstva（&lt;UTOP) 这个地址是用来当它接收到一个物理页的时候，将这个虚拟地址映射到这个接收的物理页上。并将之前的映射关系给去除了</p>
<p>发送进程会调用sys_ipc_send函数，并提供一个有效地址srcva（&lt;UTOP）这个地址就是要发送的页面的虚拟地址，根据这个地址我们找到对应的pageinfo，然后设置接收方的访问权限perm，然后在发送的系统调用中寻找指定的接收方，然后将这个page给映射到指定的env的dstva上，然后这个物理页就被两个进程的共享了。</p>
<h4 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h4><p><code>sys_ipc_recv</code>：挂起等待接收消息</p>
<ul>
<li>判断是否要接收一个页面：dstva &lt; UTOP<ul>
<li>如果dstva &lt; UTOP但dstva没有4K对齐，返回-E_INVAL异常退出</li>
<li>如果dstva &gt;= UTOP表明不想收到一个页面！！！</li>
</ul>
</li>
<li><strong>设置当前进程的env_ipc_recving和env_ipc_dstva</strong></li>
<li>挂起当前进程（env_status设置为ENV_NOT_RUNNABLE），切换到其他环境运行</li>
<li>sys_ipc_recv本身永不返回，但调用者能收到0作为正确返回值，这里和fork原理一样，<strong>由sys_ipc_try_send设置接收者寄存器eax的值实现</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_ipc_recv</span><span class="hljs-params">(<span class="hljs-type">void</span> *dstva)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-comment">//看看这个dstva是不是小于UTOP，如果小于，则是希望接受一个页，并且dstva必须是起始页地址（页对齐）</span><br>	<span class="hljs-keyword">if</span>(dstva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; dstva != ROUNDDOWN(dstva,PGSIZE))&#123;<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	curenv-&gt;env_ipc_recving = <span class="hljs-literal">true</span>; <span class="hljs-comment">//设置正在接受数据</span><br>	curenv-&gt;env_ipc_dstva = dstva; <span class="hljs-comment">//设置接受页的虚拟地址</span><br>	curenv-&gt;env_status = ENV_NOT_RUNNABLE;<span class="hljs-comment">//设置不可运行状态</span><br>	curenv-&gt;env_ipc_from = <span class="hljs-number">0</span>;  <span class="hljs-comment">//envid of the sender</span><br>	<span class="hljs-comment">// panic(&quot;sys_ipc_recv not implemented&quot;);</span><br>	sched_yield();<span class="hljs-comment">//交出cpu的使用权</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><code>sys_ipc_try_send</code>：将消息值<code>value</code>发送到id为<code>envid</code>的进程</p>
<ul>
<li>先经过一些列的判断</li>
<li>然后完成目标进程的页面映射</li>
<li>设置目标进程接收完成状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_ipc_try_send</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">uint32_t</span> value, <span class="hljs-type">void</span> *srcva, <span class="hljs-type">unsigned</span> perm)</span><br>&#123;<br>	<span class="hljs-comment">// LAB 4: Your code here.</span><br>	<span class="hljs-type">int</span> r;<br>	<span class="hljs-type">pte_t</span> *pte;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span> <span class="hljs-comment">//目标进程</span><br>	<span class="hljs-keyword">if</span>((r = envid2env(envid,&amp;env,<span class="hljs-number">0</span>))&lt;<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-comment">//如果不存在这个env</span><br>		<span class="hljs-keyword">return</span> -E_BAD_ENV;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(env-&gt;env_ipc_recving !=<span class="hljs-literal">true</span> || env-&gt;env_ipc_from != <span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-comment">//判读目标进程是否处于接收状态，并且之前没人发送消息给他</span><br>		<span class="hljs-keyword">return</span> -E_IPC_NOT_RECV;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(srcva &lt;(<span class="hljs-type">void</span> *)UTOP &amp;&amp; PGOFF(srcva))&#123;<br>		<span class="hljs-comment">//如果srcva&lt;UTOP，那么说明是页传送，那么srcva必须是页对齐的</span><br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	<span class="hljs-comment">//下面是表示页传送</span><br>	<span class="hljs-keyword">if</span>(srcva&lt; (<span class="hljs-type">void</span> *) UTOP)&#123;<br>		<span class="hljs-comment">//要传送的页的权限必须包含PTE_P 和PTE_U</span><br>		<span class="hljs-keyword">if</span>((perm &amp; PTE_P) == <span class="hljs-number">0</span> || (perm &amp; PTE_U) == <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-keyword">return</span> -E_INVAL;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span>((perm &amp; ~(PTE_P | PTE_U | PTE_W | PTE_AVAIL)) != <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-keyword">return</span> -E_INVAL;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//看看要传送的这个物理页是否存在</span><br>	<span class="hljs-keyword">if</span>(srcva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; (pp = page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte)) == <span class="hljs-literal">NULL</span>)&#123;<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	<span class="hljs-comment">//查看这个页是不是两个同时拥有可写的权限，不能发送的页不可写，而接收方可写</span><br>	<span class="hljs-keyword">if</span>(srcva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; (perm &amp; PTE_W) !=<span class="hljs-number">0</span>  &amp;&amp; (*pte &amp; PTE_W) ==<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">return</span> -E_INVAL;<br>	&#125;<br>	<span class="hljs-comment">//如果发送的是页，并且目标进程的所要映射的地址不等于0，那么就可以将这个物理页插入到目标进程的页表中，完成映射</span><br>	<span class="hljs-keyword">if</span>(srcva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; env-&gt;env_ipc_dstva !=<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-keyword">if</span>(( r = page_insert(env-&gt;env_pgdir,pp,env-&gt;env_ipc_dstva,perm)) &lt; <span class="hljs-number">0</span>)&#123;<br>			<span class="hljs-comment">//表示没有足够的内存进程映射，就是无法申请新的页表之类的</span><br>			<span class="hljs-keyword">return</span> -E_NO_MEM;<br>		&#125;<br>		<br>		env-&gt;env_ipc_perm = perm;<br>	&#125;<br><br>	<span class="hljs-comment">//上面完成了消息的发送           ======================== 全都是在发送进程中完成的</span><br>	<span class="hljs-comment">//接下来就是恢复目标进程的状态</span><br><br><br>	env-&gt;env_ipc_from = curenv-&gt;env_id; <span class="hljs-comment">//设置进程消息来源进程id</span><br>	env-&gt;env_ipc_recving = <span class="hljs-literal">false</span>;       <span class="hljs-comment">//设置目标进程不在处于接收状态</span><br>	env-&gt;env_ipc_value = value;         <span class="hljs-comment">//设置这个要传送的消息---value</span><br>	env-&gt;env_status = ENV_RUNNABLE;     <span class="hljs-comment">//设置进程状态为可运行状态</span><br>	env-&gt;env_tf.tf_regs.reg_eax =<span class="hljs-number">0</span>;<span class="hljs-comment">// 接受进程的中断返回值</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">// panic(&quot;sys_ipc_try_send not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/2022/10/18/mit-6.828/lab4_5_IPC%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="JOS IPC原理"></p>
<h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>本lab将实现的是一个文件系统，主要包含下面4部分内容：</p>
<ul>
<li>实现一个文件系统进程（FS进程），基于进程实现文件系统，通过给这个进程的eflags寄存器的IOPL位使能，使得这个进程拥有IO读写的能力。从而避免了进入内核态，省去了较多的开销</li>
<li>建立RPC机制，通过进程间的通信实现文件的读写，用户进程基于进程通信和文件系统进程进行信息交流实现，通过访问文件系统进程，从而实现读写文件功能</li>
<li>更高级的抽象，引入了<strong>文件描述符</strong>（FD），通过这个文件描述符我们可以将控制台，pipe，普通文件等统统按照文件对待。</li>
<li>支持从文件中读取进程运行。</li>
</ul>
<h3 id="磁盘结构和File结构"><a href="#磁盘结构和File结构" class="headerlink" title="磁盘结构和File结构"></a>磁盘结构和File结构</h3><blockquote>
<p>Sector 和 Blocks</p>
</blockquote>
<p>大部分磁盘都是以Sector为粒度进行读写的，Jos中的sector是512字节，文件系统以block为单位分配和使用磁盘，一个block是4096个字节。</p>
<ul>
<li>Sector：这个是磁盘的属性，一个sector是512</li>
<li>block: 这个是我们操作系统的属性，一个block是4096</li>
</ul>
<blockquote>
<p>Superblocks – 超级块</p>
<p>超级块主要包含了文件系统的属性元数据，比如blocksize，disksize，根目录位置等，这些特殊的block叫做superblocks</p>
</blockquote>
<p><img src="/2022/10/18/mit-6.828/lab5_1_disk_layout.png" srcset="/img/loading.gif" lazyload alt="磁盘结构"></p>
<p>结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Super</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> s_magic;       <span class="hljs-comment">// Magic number: FS_MAGIC</span><br>    <span class="hljs-type">uint32_t</span> s_nblocks;     <span class="hljs-comment">// Total number of blocks on disk</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">s_root</span>;</span>     <span class="hljs-comment">// Root directory node</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>File 元数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br>    <span class="hljs-type">char</span> f_name[MAXNAMELEN];    <span class="hljs-comment">// filename</span><br>    <span class="hljs-type">off_t</span> f_size;           <span class="hljs-comment">// file size in bytes</span><br>    <span class="hljs-type">uint32_t</span> f_type;        <span class="hljs-comment">// file type</span><br>    <span class="hljs-comment">// Block pointers.</span><br>    <span class="hljs-comment">// A block is allocated iff its value is != 0.</span><br>    <span class="hljs-type">uint32_t</span> f_direct[NDIRECT]; <span class="hljs-comment">// direct blocks</span><br>    <span class="hljs-type">uint32_t</span> f_indirect;        <span class="hljs-comment">// indirect block</span><br>    <span class="hljs-comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span><br>    <span class="hljs-comment">// fsformat on a 64-bit machine.</span><br>    <span class="hljs-type">uint8_t</span> f_pad[<span class="hljs-number">256</span> - MAXNAMELEN - <span class="hljs-number">8</span> - <span class="hljs-number">4</span>*NDIRECT - <span class="hljs-number">4</span>];<br>&#125; __attribute__((packed));  <span class="hljs-comment">// required only on some 64-bit machines</span><br><br></code></pre></td></tr></table></figure>

<p>这个File可以指代目录也可以指代普通文件，由这个type字段标识</p>
</blockquote>
<p>这个file结构十分的重要，它记录了这个文件的所有信息，比如文件名，文件大小，文件类型，文件存储位置等信息，在这个文件存储位置是记录了具体的block号，有一个直接索引的长度为10个int大小的数组，记录了这个文件存储的位置，还有一个间接索引的字段，记录了一个block，这个block的内容是一个个block num，记录剩余文件内容的位置，总共可以拥有1034个block</p>
<p><img src="/2022/10/18/mit-6.828/lab5_2_file%E7%BB%93%E6%9E%84.PNG" srcset="/img/loading.gif" lazyload alt="File文件结构"></p>
<blockquote>
<p>Block Bitmap</p>
</blockquote>
<p>这个位图是记录了这个磁盘中有哪些block没有被使用，如果使用了，就将对应的位设为0，0表示使用，1表示未使用。</p>
<p>因此我们提供了一个block的分配器alloc_block函数，用来搜索这个bitmap数组，然后返回这个未使用的block。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//给bitmap的对用的块编号置0（已使用）</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">alloc_block</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>	<span class="hljs-comment">// The bitmap consists of one or more blocks.  A single bitmap block</span><br>	<span class="hljs-comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span><br>	<span class="hljs-comment">// super-&gt;s_nblocks blocks in the disk altogether.</span><br><br>	<span class="hljs-comment">// LAB 5: Your code here.</span><br>	<span class="hljs-type">uint32_t</span> blockno;<br>	<span class="hljs-keyword">for</span>(blockno = <span class="hljs-number">0</span>; blockno &lt; super-&gt;s_nblocks ; blockno++)&#123;<br>		<span class="hljs-keyword">if</span>(block_is_free(blockno))&#123;<br>			bitmap[blockno/<span class="hljs-number">32</span>] ^= <span class="hljs-number">1</span>&lt;&lt;(blockno%<span class="hljs-number">32</span>);  <span class="hljs-comment">//给这个空闲的位置0；表示已使用</span><br>			<span class="hljs-comment">//紧接着将bitmap同步到磁盘</span><br>			flush_block(bitmap); <span class="hljs-comment">//虚拟地址和磁盘块地址都是对应好的了</span><br>			<span class="hljs-keyword">return</span> blockno;<br> 		&#125;<br>	&#125;<br>	<span class="hljs-comment">// panic(&quot;alloc_block not implemented&quot;);</span><br>	<span class="hljs-keyword">return</span> -E_NO_DISK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><h4 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h4><blockquote>
<p>文件系统进程如何去访问磁盘呢？</p>
</blockquote>
<p>到目前为止内核还没有访问磁盘的能力。JOS不像其他操作系统一样在内核添加磁盘驱动，然后提供系统调用。我们实现一个文件系统进程来作为磁盘驱动。<br><strong>x86处理器使用EFLAGS寄存器的IOPL为来控制保护模式下代码是否能执行设备IO指令，比如in和out。我们希望文件系统进程能访问IO空间，其他进程不能。</strong></p>
<p>所以我们在创建这个文件系统进程的时候一定要将他的Trapframe字段中的eflags字段给设置一下，保证IOPL位使能，从而实现这个文件系统能够执行IO操作</p>
<h4 id="Block-Cache-–-加载文件到内存"><a href="#Block-Cache-–-加载文件到内存" class="headerlink" title="Block Cache – 加载文件到内存"></a>Block Cache – 加载文件到内存</h4><p>我们的文件系统最大可以支持3GB，我们是将文件系统进程的<strong>虚拟地址0x10000000-0xD0000000</strong>默认映射到3GB的磁盘空间。</p>
<ul>
<li><strong>但是我们不可能一下子将3GB磁盘缓存到内存中，而是通过一个pgfault来实现这个文件的加载进内存。</strong></li>
<li>当我们访问某个block对应的内存地址时出现页错误，然后将这个block加载到内存中，并映射页表关系。</li>
</ul>
<blockquote>
<p>bc_pgfault()函数，就是文件系统发生页错误时真正处理异常的函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Fault any disk block that is read in to memory by</span><br><span class="hljs-comment">// loading it from disk.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">bc_pgfault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> UTrapframe *utf)</span><br>&#123;<br>	<span class="hljs-type">void</span> *addr = (<span class="hljs-type">void</span> *) utf-&gt;utf_fault_va;<span class="hljs-comment">//发生缺页中断的地方</span><br>	<span class="hljs-type">uint32_t</span> blockno = ((<span class="hljs-type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;  <span class="hljs-comment">//获取磁盘块编号</span><br>	<span class="hljs-type">int</span> r =<span class="hljs-number">0</span>;<br><br>	<span class="hljs-comment">// Check that the fault was within the block cache region</span><br>	<span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-type">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-type">void</span>*)(DISKMAP + DISKSIZE))<br>		panic(<span class="hljs-string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,<br>		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);<br><br>	<span class="hljs-comment">// Sanity check the block number.</span><br>	<span class="hljs-keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)<br>		panic(<span class="hljs-string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);<br><br>	<span class="hljs-comment">// Allocate a page in the disk map region, read the contents</span><br>	<span class="hljs-comment">// of the block from the disk into that page.</span><br>	<span class="hljs-comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span><br>	<span class="hljs-comment">// the disk.</span><br>	<span class="hljs-comment">// 在内存中申请一个页用来存放从磁盘读取的一个block</span><br>	<span class="hljs-comment">// LAB 5: you code here:</span><br>	addr = ROUNDDOWN(addr,PGSIZE);  <span class="hljs-comment">//获取发生缺页中断的页的起始地址</span><br>	<span class="hljs-keyword">if</span>((sys_page_alloc(<span class="hljs-number">0</span>,addr,PTE_W|PTE_U|PTE_P) &lt; <span class="hljs-number">0</span>))<span class="hljs-comment">//为文件系统进程申请一个页，并完成映射</span><br>		 panic(<span class="hljs-string">&quot;in bc_pgfault, sys_page_alloc: %e&quot;</span>, r);<br>	<span class="hljs-keyword">if</span>((r = ide_read(blockno * BLKSECTS,addr,BLKSECTS))&lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//blockno * BLKSECTS表示扇区号（一个块包含BLKSECTS个扇区）。功能是将某个扇区号开始的扇区读进来BLKSECTS个扇区到addr处</span><br>		panic(<span class="hljs-string">&quot;in bc_pgfault, ide_read: %e&quot;</span>, r);<br>	<span class="hljs-comment">// Clear the dirty bit for the disk block page since we just read the</span><br>	<span class="hljs-comment">// block from disk</span><br>	<span class="hljs-keyword">if</span> ((r = sys_page_map(<span class="hljs-number">0</span>, addr, <span class="hljs-number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 设置PTE_D位置为0，表示不是dirty的</span><br>		panic(<span class="hljs-string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);<br><br>	<span class="hljs-comment">// Check that the block we read was allocated. (exercise for</span><br>	<span class="hljs-comment">// the reader: why do we do this *after* reading the block</span><br>	<span class="hljs-comment">// in?)</span><br>	<span class="hljs-keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))<br>		panic(<span class="hljs-string">&quot;reading free block %08x\n&quot;</span>, blockno);<br>&#125;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>flush_block这个函数是将内存中的数据写入到磁盘中</p>
<ul>
<li>通过页表项中的PTE_D位（dirty位–标识这个内存是否脏了）</li>
</ul>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">flush_block</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr)</span><br>&#123;<br>	<span class="hljs-type">uint32_t</span> blockno = ((<span class="hljs-type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<br><br>	<span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-type">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-type">void</span>*)(DISKMAP + DISKSIZE))<br>		panic(<span class="hljs-string">&quot;flush_block of bad va %08x&quot;</span>, addr);<br><br>	<span class="hljs-comment">// LAB 5: Your code here.</span><br>	<span class="hljs-type">int</span> r =<span class="hljs-number">0</span>;<br>	addr = ROUNDDOWN(addr,PGSIZE);<br>	<span class="hljs-comment">//脏块的判断是通过PTE_D来判断的</span><br>	<span class="hljs-keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;  <span class="hljs-comment">//先看这个addr有没有读进来的扇区，并且有没有被修改,如果有，那么就将这个addr对应的块同步到磁盘</span><br>		<span class="hljs-keyword">if</span>((r = ide_write(blockno * BLKSECTS,addr,BLKSECTS)) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//将addr地址开始的块内存写入到磁盘扇区编号为blockno * BLKSECTS地方</span><br>			panic(<span class="hljs-string">&quot;in flush_block, ide_write: %e&quot;</span>, r);<br>		&#125;<br>		<span class="hljs-keyword">if</span>((r = sys_page_map(<span class="hljs-number">0</span>,addr,<span class="hljs-number">0</span>,addr,uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//清空PTE_D位，也就是dirty，这个就是重新自映射一下，只是把perm改了一下</span><br>			panic(<span class="hljs-string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// panic(&quot;flush_block not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/2022/10/18/mit-6.828/lab5_3_fs%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E7%A3%81%E7%9B%98.png" srcset="/img/loading.gif" lazyload alt="JOS fs进程虚拟地址空间和磁盘关系"></p>
<p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p>
<h3 id="File-Operations-–-文件操作"><a href="#File-Operations-–-文件操作" class="headerlink" title="File Operations – 文件操作"></a>File Operations – 文件操作</h3><blockquote>
<p>基本的文件操作：</p>
</blockquote>
<ol>
<li><code>file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</code>：查找f指向文件结构的第filebno个block的存储地址，保存到ppdiskbno中。如果f-&gt;f_indirect还没有分配，且alloc为真，那么将分配要给新的block作为该文件的f-&gt;f_indirect。类比页表管理的pgdir_walk()。</li>
<li><code>file_get_block(struct File *f, uint32_t filebno, char **blk)</code>：该函数查找文件第filebno个block对应的虚拟地址addr，将其保存到blk地址处。</li>
<li><code>walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)</code>：解析路径path，填充pdir和pf地址处的File结构。比如/aa/bb/cc.c那么pdir指向代表bb目录的File结构，pf指向代表cc.c文件的File结构。又比如/aa/bb/cc.c，但是cc.c此时还不存在，那么pdir依旧指向代表bb目录的File结构，但是pf地址处应该为0，lastelem指向的字符串应该是cc.c。</li>
<li><code>dir_lookup(struct File *dir, const char *name, struct File **file)</code>：该函数查找dir指向的文件内容，寻找File.name为name的File结构，并保存到file地址处。</li>
<li><code>dir_alloc_file(struct File *dir, struct File **file)</code>：在dir目录文件的内容中寻找一个未被使用的File结构，将其地址保存到file的地址处。</li>
</ol>
<blockquote>
<p>文件操作</p>
</blockquote>
<ol>
<li><code>file_create(const char *path, struct File **pf)</code>：创建path，如果创建成功pf指向新创建的File指针。</li>
<li><code>file_open(const char *path, struct File **pf)</code>：寻找path对应的File结构地址，保存到pf地址处。</li>
<li><code>file_read(struct File *f, void *buf, size_t count, off_t offset)</code>：从文件f中的offset字节处读取count字节到buf处。</li>
<li><code>file_write(struct File *f, const void *buf, size_t count, off_t offset)</code>：将buf处的count字节写到文件f的offset开始的位置。</li>
</ol>
<h3 id="File-System-interface"><a href="#File-System-interface" class="headerlink" title="File System interface"></a>File System interface</h3><p>上面我们为这个文件系统进程提供了一大堆文件操作的函数，但是这些函数只能被文件系统进程使用，而无法被其他的进程使用，因此我们需要进行进程间的通信，实现这个不同的用户进程和这个文件进程通信，通过将要操作的文件信息发送给文件进程，让他给我们操作文件。这其实是一种RPC机制。</p>
<p><img src="/2022/10/18/mit-6.828/image-20230322210322786.png" srcset="/img/loading.gif" lazyload alt="image-20230322210322786"></p>
<p>这个机制是如何实现的呢？</p>
<ul>
<li>首先我们的文件系统会一直处于接收状态，一直接收IPC请求，然后将对应的请求分配到对应的处理函数中去，并将结果通过IPC发送给用户进程。</li>
<li>对于客户端来说，我们会为一个fsipcbuf结构分配一个共享页，然后将这个共享也作为自己这个进程和文件进程的共享空间，我们利用这个共享页发送我们要对文件操作的动作（open/write/read等）和文件的一些信息（name等）。</li>
<li>对于文件进程来说，它会把fsipcbuf对应的那个用户进程的共享页给映射到一个指定的位置（0x0ffff000），然后就可以读取用户进程发送过来的信息，然后文件进程还可以在这个内存中写东西，供用户进程使用。</li>
<li>在open操作时，文件进程还会申请一个页作为FD文件描述符页并发送给用户进程，然后用户进程接收时将这个对应的物理页映射到自己当初分配至fd空间处，这个fd包含了这个文件基本内容，文件id和文件类型（是设备还是控制台还是file），通过这个我们就可以调用不同的read/write函数。（这个fd很巧妙）<ul>
<li>在open时，文件进程会分配一个openfile结构空间，用来记录这个打开的文件，他里面有一个File，这个就是我们操作磁盘的关键。并且在这个结构中还有一个fd指针，指向一个文件系统分配的页空间，然后将这个页空间和用户进程的fd对应的地址相映射，这样用户进程就拿到了这个在文件系统中产生的文件描述符。</li>
</ul>
</li>
</ul>
<h3 id="Spawning-Process"><a href="#Spawning-Process" class="headerlink" title="Spawning Process"></a>Spawning Process</h3><p>这个是实现一个从磁盘中读取一个进程文件，然后并运行的功能。和uinx的fork之后采取exec()动作一样。</p>
<p>基本流程就是：</p>
<ol>
<li>从文件系统打开prog程序文件</li>
<li>调用系统调用sys_exofork()创建一个新的Env结构</li>
<li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段（该字段包含寄存器信息）。</li>
<li>根据ELF文件中program herder，将用户程序以Segment读入内存，并映射到指定的线性地址处。</li>
<li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNNABLE。</li>
</ol>
<p><img src="/2022/10/18/mit-6.828/lab5_6_fs%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="客户端进程和FS进程交互"></p>
<p>更高级的抽象，引入<strong>文件描述符</strong>。通过文件描述符这一层抽象就可以将<strong>控制台，pipe，普通文件</strong>，统统按照文件来对待。文件描述符和pipe的原理总结如下：</p>
<p><img src="/2022/10/18/mit-6.828/lab5_5_%E6%96%87%E4%BB%B6_fd%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_pipe%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" lazyload alt="文件描述符和pipe原理"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MIT6-828/">#MIT6.828</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MIT-6.828操作系统</div>
      <div>http://example.com/2022/10/18/mit-6.828/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bollcode</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年10月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" title="网络协议">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网络协议</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
