

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/basketball.svg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="bollcode">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++基础知识【随记】1. 引用指针、引用  引用的本质就是指针常量，一旦初始化完成，就无法再改变 引用实际上是给一个变量起的别名，编译器不会给引用变量开辟新的空间，变量和他的引用变量共用同一块内存   1.引用本质–引用是一个指针常量，引用一旦完成就无法改变  12345678910int main()&amp;#123;	int a &#x3D; 10;	&#x2F;&#x2F;自定转化为int* const b&#x3D;&amp;a;">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础知识">
<meta property="og:url" content="http://example.com/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C++基础知识【随记】1. 引用指针、引用  引用的本质就是指针常量，一旦初始化完成，就无法再改变 引用实际上是给一个变量起的别名，编译器不会给引用变量开辟新的空间，变量和他的引用变量共用同一块内存   1.引用本质–引用是一个指针常量，引用一旦完成就无法改变  12345678910int main()&amp;#123;	int a &#x3D; 10;	&#x2F;&#x2F;自定转化为int* const b&#x3D;&amp;a;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/C++.jpg">
<meta property="article:published_time" content="2023-04-13T02:40:33.297Z">
<meta property="article:modified_time" content="2023-06-28T15:00:44.163Z">
<meta property="article:author" content="bollcode">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/C++.jpg">
  
  
  
  <title>C++基础知识 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>bollcode</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++基础知识"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-13 10:40" pubdate>
          2023年4月13日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          86k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          714 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++基础知识</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h2 id="【随记】"><a href="#【随记】" class="headerlink" title="【随记】"></a>【随记】</h2><h3 id="1-引用"><a href="#1-引用" class="headerlink" title="1. 引用"></a>1. 引用</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_62529445/article/details/126278769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~YuanLiJiHua~Position-1-126278769-blog-124724506.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~YuanLiJiHua~Position-1-126278769-blog-124724506.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1">指针、引用</a></p>
<blockquote>
<p>引用的本质就是<strong>指针常量</strong>，一旦初始化完成，就无法再改变</p>
<p>引用实际上是给一个变量起的别名，编译器不会给引用变量开辟新的空间，变量和他的引用变量共用同一块内存</p>
</blockquote>
<blockquote>
<p>1.引用本质–引用是一个指针常量，引用一旦完成就无法改变</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-comment">//自定转化为int* const b=&amp;a;</span><br>	<span class="hljs-comment">//指针常量是指针的指向不可以改</span><br>	<span class="hljs-comment">//也就说明了引用为什么不可以改</span><br>	<span class="hljs-type">int</span>&amp; b = a;<br>	<span class="hljs-comment">//编译器发现b是引用，自动帮我们转化为*b=20;</span><br>	b = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>2.常量引用</p>
</blockquote>
<p>当函数参数是引用的时候，有时需要用到常量引用，涉及到权限以及防止误操作。</p>
<p>权限方面不能放大，只能缩小。</p>
<p>例如一个变量是一个可读可写的权限，可以修改为只读的权限。</p>
<p>一个变量是只读的权限，不能修改为可读可写的权限。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//权限平移</span><br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-type">int</span>&amp; b = a;<br> <br>	<span class="hljs-comment">//权限不能放大</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">20</span>;<span class="hljs-comment">//c是只读</span><br>	<span class="hljs-comment">//int&amp; d=c;//d是可读可写 c是只读，错误</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; d = c;<span class="hljs-comment">//d是只读 权限平移</span><br> <br>	<span class="hljs-comment">//权限可以缩小</span><br>	<span class="hljs-type">int</span> e = <span class="hljs-number">30</span>;<span class="hljs-comment">//e可读可写</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; f = e;<span class="hljs-comment">//f只读</span><br> <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用引用传参，函<strong>数内如果不改变参数</strong>，建议使用const引用传参  const int&amp; b</p>
<p><strong>因为如果将引用作为参数，就相当于指针一样，就可以改变原有的值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用常量引用防止误操作修改实参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//b+=10;//误操作，改变了实参</span><br>	<span class="hljs-comment">// 加入const之后，都是只读的权限，避免通过引用修改实参</span><br>	cout &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-comment">//该函数只是实现打印数据功能</span><br>	<span class="hljs-built_in">ShowValue</span>(a);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>引用使用场景</p>
</blockquote>
<ol>
<li>引用做参数</li>
</ol>
<p>作用：函数传参时，可以用引用让形参修改实参</p>
<p>优点：简化指针修改实参</p>
<p>总结：<strong>通过引用参数产生的效果和按地址传递是一样的，引用的语法更加简单清楚，唯一的缺点就是引用无法重新赋值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//引用做函数参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> tmp = a;<br>	a = b;<br>	b = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;交换前a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;交换前b=&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>	<span class="hljs-built_in">mySwap</span>(a, b);<br>	cout &lt;&lt; <span class="hljs-string">&quot;交换后a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;交换后b=&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//交换前a=10 b=20</span><br><span class="hljs-comment">//交换后a=20 b=10</span><br></code></pre></td></tr></table></figure>



<ol start="2">
<li>引用做返回值</li>
</ol>
<blockquote>
<p>引用可以做参数返回，但是不能返回局部变量的引用，可以返回静态变量的引用</p>
<p>因为局部变量是放在栈区的，函数结束后就会销毁变量，而静态变量是在静态区的，静态区的变量是在程序结束之后才释放的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这个程序使用引用返回本质是不对的，返回值没有保障</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-comment">//n存放在栈区，出了作用域就被销毁</span><br>	n++;<br>	<span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span>&amp; ret = <span class="hljs-built_in">count</span>();<br>	cout &lt;&lt; ret &lt;&lt; endl;<br>	cout &lt;&lt; ret &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这个场景可以使用传引用返回</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-comment">//static修饰的变量n存放在静态区</span><br>	n++;<br>	<span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span>&amp; ret = <span class="hljs-built_in">count</span>();<br>	cout &lt;&lt; ret &lt;&lt; endl;<br>	cout &lt;&lt; ret &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-引用和指针的区别"><a href="#2-引用和指针的区别" class="headerlink" title="2. 引用和指针的区别"></a>2. 引用和指针的区别</h3><blockquote>
<p>语法角度：引用是没有开辟新的空间用来存储引用变量，指针是有一个空间用来存储指针变量的</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>	<span class="hljs-comment">//语法角度，ra没有开空间</span><br>	<span class="hljs-type">int</span>&amp; ra = a;<br>	ra = <span class="hljs-number">20</span>;<br> <br>	<span class="hljs-comment">//语法角度，pa开了4or8byte空间</span><br>	<span class="hljs-type">int</span>* pa =&amp;a;<br>	*pa = <span class="hljs-number">20</span>;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>底层角度：引用和指针都是开辟了新的空间</p>
</blockquote>
<p>实际上，b在内存条上是占用了一块空间的。不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间，<strong>且取其地址时直接取到所指向的地址</strong>。<strong>实际在内存空间上，引用本身也占用一块内存，里面存储着所引用的变量的地址，大小与指针相同，字面上也表现为unsigned long int型。只是经过编译器处理后，访问这块内存时将直接转而访问其指向的内存。因此在程序中无法读取到这块内存本身。</strong></p>
<p>这可以理解为“编译器的把戏”或“程序的谎言”，但这一机制不是为了捉弄程序员，而是为了真正实现别名的效果。</p>
<p>综上：<strong>引用的实现实际上是占用内存空间的，但程序把它按照不占用内存空间来处理</strong>。</p>
<blockquote>
<p>引用和指针的不同点：</p>
</blockquote>
<ol>
<li>引用概念上定义一个变量的别名，指针存储一个变量地址。</li>
<li>引用在定义时必须初始化，指针没有要求</li>
<li>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体</li>
<li>没有NULL引用，但有NULL指针</li>
<li>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)</li>
<li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li>
<li>有多级指针，但是没有多级引用</li>
<li>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</li>
<li>指针使用更强大，更危险，更复杂，引用比指针使用起来相对更安全，更简单，但相对局限</li>
</ol>
<h3 id="C-创建对象方式"><a href="#C-创建对象方式" class="headerlink" title="C++ 创建对象方式"></a>C++ 创建对象方式</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44890993/article/details/126880953">C++创建对象的方式</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> String = std::string;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  String m_Name;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Person</span>() :<span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unknown&quot;</span>) &#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> String&amp; name) :<span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> String&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h4 id="1-在栈上创建对象"><a href="#1-在栈上创建对象" class="headerlink" title="1. 在栈上创建对象"></a>1. 在栈上创建对象</h4><p>在栈上创建的对象，有一个自动的生命周期，他们的生命周期由它声明的作用域所决定，换言之，只要变量超出了其作用域，该对象的内存就被释放了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  &#123;<br>    <span class="hljs-comment">// 在栈上创建对象</span><br>    <span class="hljs-comment">// 可以写为 Person personOnStack = Person(&quot;person1&quot;);</span><br>    <span class="hljs-function">Person <span class="hljs-title">personOnStack</span><span class="hljs-params">(<span class="hljs-string">&quot;person1&quot;</span>)</span></span>; <br>    <span class="hljs-comment">// 打印名字 person1</span><br>    std::cout &lt;&lt; personOnStack.<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>  &#125; <span class="hljs-comment">// 当代码运行到此行时，personOnStack将被回收</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-在堆上创建对象"><a href="#2-在堆上创建对象" class="headerlink" title="2. 在堆上创建对象"></a>2. 在堆上创建对象</h4><p>在堆上创建对象则不同。在堆上创建的对象会一直待在那里，直到你决定把它释放，空闲出其对应的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  &#123;<br>    <span class="hljs-comment">// 在堆上创建对象 关键词 new</span><br>    Person *personOnHeap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;person2&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 打印名字 person1</span><br>    std::cout &lt;&lt; personOnHeap-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 在堆上分配的对象要手动释放内存</span><br>  <span class="hljs-comment">// 即 new 和 delete一起使用</span><br>  <span class="hljs-keyword">delete</span> personOnHeap;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-比较"><a href="#3-比较" class="headerlink" title="3.比较"></a>3.比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 创建 Person 类型的指针</span><br>  Person *p1, *p2;<br>  &#123;<br>    <span class="hljs-comment">// 在栈上创建对象</span><br>    <span class="hljs-comment">// 可以写为 Person personOnStack = Person(&quot;person1&quot;);</span><br>    <span class="hljs-function">Person <span class="hljs-title">personOnStack</span><span class="hljs-params">(<span class="hljs-string">&quot;person1&quot;</span>)</span></span>; <br>    <span class="hljs-comment">// 在堆上创建对象 关键词 new</span><br>    Person *personOnHeap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;person2&quot;</span>);<br>    <span class="hljs-comment">/* p1指针指向 personOnStack 所在的内存地址</span><br><span class="hljs-comment">     * 在大括号之后 personOnStack 将被回收</span><br><span class="hljs-comment">     * 在大括号之后将获取不到 m_name = person1 的对象</span><br><span class="hljs-comment">     */</span><br>    p1 = &amp;personOnStack;<br>    <br>    <span class="hljs-comment">/* personOnHeap赋值给p2</span><br><span class="hljs-comment">     * 在大括号之后 personOnHeap不会被回收</span><br><span class="hljs-comment">     * 在大括号之后将获取到 m_name = person2 的对象 </span><br><span class="hljs-comment">     */</span><br>    p2 = personOnHeap;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 打印结果为空</span><br>  std::cout &lt;&lt; p1-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 打印名字 person2</span><br>  std::cout &lt;&lt; p2-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>    <br>  <span class="hljs-comment">// 在堆上分配的对象要手动释放内存</span><br>  <span class="hljs-comment">// 即 new 和 delete一起使用</span><br>  <span class="hljs-keyword">delete</span> p2;<br>  <span class="hljs-comment">// 此处不需要delete p1的原因？</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上代码所示，当代码运行到main函数中的大括号后，personOnStack对象被释放，所以p1获取到的m_Name为空；而在堆上创建的，personOnHeap对象没有被释放，所以p2能够正常获取m_Name。</p>
<p>​    最后，p1不需要delete的原因——main函数中的大括号之后，personOnStack对象被释放，所以personOnStack对象的地址也被释放，p1指针不需要被delete。</p>
<h3 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39875125/article/details/115566413">https://blog.csdn.net/weixin_39875125/article/details/115566413</a></p>
<h2 id="【基本语法】"><a href="#【基本语法】" class="headerlink" title="【基本语法】"></a>【基本语法】</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><blockquote>
<p>一维数组</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义方式1</span><br><span class="hljs-type">int</span>  arr[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">//定义方式2</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;  <span class="hljs-comment">//长度10，没有定义的为0</span><br><span class="hljs-comment">//定义方式3 </span><br><span class="hljs-type">int</span> arr2[]  = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;    <span class="hljs-comment">//长度就是&#123;&#125;中的元素的个数</span><br><br>arr可以表示这个数组，以及数组的起始地址<br></code></pre></td></tr></table></figure>

<blockquote>
<p>二维数组</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义方式1</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>];<span class="hljs-comment">//定义一个3行5列的二维数组</span><br><span class="hljs-comment">//定义方式2</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>&#125;&#125;;<br><br><span class="hljs-comment">//定义方式3</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">45</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>,<span class="hljs-number">55</span>&#125;;<span class="hljs-comment">//他会自动帮我划分行和列</span><br><br><span class="hljs-comment">//定义方式4</span><br><span class="hljs-type">int</span> arr3[][<span class="hljs-number">3</span>]  = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">//必须要把列定义行，这样才能识别</span><br></code></pre></td></tr></table></figure>

<h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h3><blockquote>
<p>指向一块地址空间</p>
</blockquote>
<h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>指针变量指向地址为0的空间</p>
<p>用途： 初始化指针</p>
<p>注意：空指针指向的内存是不可以访问的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p;<br><span class="hljs-type">int</span> *p  = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>定义： 指针变量指向非法的空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义指针变量p指向内存空间地址为0x1100的空间（但是没有事先申请，所以没有访问权限）</span><br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-number">0x1100</span>;<br>cout &lt;&lt; *p &lt;&lt; endl  <span class="hljs-comment">//访问野指针报错</span><br></code></pre></td></tr></table></figure>

<h4 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h4><blockquote>
<p>三种情况 – 就近原则，靠近谁，谁就不能修改</p>
</blockquote>
<ul>
<li><p>常量指针 ：顾名思义，就是指针指向了一个常量，也就是指针指向的变量不可修改</p>
</li>
<li><p>指针常量：这个指针是一个常量，不能修改这个指针，即无法修改指针的指向</p>
</li>
<li><p>const修饰指针和常量</p>
</li>
</ul>
<blockquote>
<p>常量指针：指针的指向可以改，但是指针指向的内容不可以改（其实是不能通过*p进行修改）</p>
<p>​    使用案例：<strong>可以作为一个函数参数，这样既可以取代了值传递，又不能修改原来的变量</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;<br><br>    *p = <span class="hljs-number">40</span>;  <span class="hljs-comment">//这个是错误的，不能通过*p进行修改，不代表a就是常量</span><br>    <br>    p = &amp;b; <span class="hljs-comment">//这个是正确的，可以更改指针的指向</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>指针常量：指针的指向不能改，指针指向的变量可以改，其实这个指针就是个常量了</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br><br>    *p = <span class="hljs-number">40</span>; <span class="hljs-comment">//这个是正确的 ，可以修改指针指向的变量</span><br><br>    p = &amp;b;<span class="hljs-comment">//这个是错误的，无法修改指针的指向，指针是个常量</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>const 修饰指针和常量：指针指向无法修改，指针指向的变量无法修改</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br><br>    *p = <span class="hljs-number">40</span>;<span class="hljs-comment">//错误</span><br><br>    p = &amp;b; <span class="hljs-comment">//错误</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<h4 id="指针访问数组元素"><a href="#指针访问数组元素" class="headerlink" title="指针访问数组元素"></a>指针访问数组元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">56</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span> *p = arr;<span class="hljs-comment">//这个int 类型的指针就指向了这个数组</span><br>cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//输出数组的第一个元素 1</span><br>p++;<span class="hljs-comment">//这样就指向了数组的第二个元素，p = p+5;表示指向从p开始计数后的第五个元素</span><br>cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//输出 2</span><br><br></code></pre></td></tr></table></figure>



<h3 id="3-内存四区"><a href="#3-内存四区" class="headerlink" title="3. 内存四区"></a>3. 内存四区</h3><blockquote>
<ul>
<li>代码区</li>
<li>全局区</li>
<li>栈区</li>
<li>堆区</li>
</ul>
</blockquote>
<blockquote>
<p>代码区：存放代码，其实就是代码段</p>
</blockquote>
<blockquote>
<p>全局区：存放全局变量，static变量，全局常量，<strong>字符串常量</strong>；</p>
<p>​                局部变量不存在全局区；</p>
<p>栈区：存放局部变量，函数返回地址，<strong>不要将局部变量的地址返回出去</strong>，因为函数结束后，局部变            量地址空间被释放了，可能会被其他内容覆盖。<strong>但是，这个也不是绝对的，如果我们的            局部变量开辟在堆区中，是可以将其返回的</strong>。</p>
<p>堆区：堆区是由程序员进行管理和开辟的，<strong>堆区数据利用new关键字进行内存开辟</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//在堆区中申请了一个内存存放10，并返回这个空间的地址</span><br>        <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//将这个堆区中的10的地址返回出去，这个指针变量p在栈中，被释放</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">int</span> *m = <span class="hljs-built_in">func</span>();<span class="hljs-comment">//获取指针，这个指针就指向了堆区10的地址,这个空间不会自动释放</span><br>        cout &lt;&lt; *m &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4. new和delete"></a>4. new和delete</h3><blockquote>
<p>new 用来在堆区申请一块内存，并返回内存的地址</p>
<p>delete 用来释放new出来的地址空间</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);     <span class="hljs-comment">//在堆中申请一块内存</span><br><span class="hljs-keyword">delete</span> p;                      <span class="hljs-comment">//释放内存</span><br><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];      <span class="hljs-comment">//在堆中申请一块数组空间</span><br><span class="hljs-keyword">delete</span>[] p;                  <span class="hljs-comment">//使用delete[]  来释放</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>对于基本类型，使用delete 或者delete[] 都可以释放数组空间，但是对于对象就不行</p>
<p>因为对象空间的释放是调用其析构函数，delete只是调用一个对象的析构函数，delete[] 才是调用对象数组中的所有对象的析构函数来释放，所以释放对象数组要用delete[]；</p>
</blockquote>
<h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p>看上面【随记】</p>
<p>int a = 10;</p>
<p>int &amp;b = a; //定义一个引用b</p>
<h4 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h4><blockquote>
<p><strong>本质就是指针常量</strong>–不能改变指向，可以改变变量</p>
</blockquote>
<blockquote>
<p>引用必须初始化，且不能更改引用对象</p>
</blockquote>
<blockquote>
<p>引用也占用空间，但是无法找到引用的地址，即使cout&lt;&lt; &amp;b &lt;&lt; endl 这个输出的是变量a的地址</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">//编译的时候会自动的转成int *const b =a; 所以就是一个指针常量，不可改变指向，可以修改值</span><br>b = <span class="hljs-number">20</span>;     <span class="hljs-comment">//编译的时候会自动转成 *b =20;</span><br><br></code></pre></td></tr></table></figure>

<h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><blockquote>
<p>不能改指向，也不能改值</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a =<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b =<span class="hljs-number">20</span>; <span class="hljs-comment">// 其实就是const int &amp; b = 20;</span><br></code></pre></td></tr></table></figure>

<h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h3><blockquote>
<p>函数的形参可以直接定义成默认参数，但是声明和定义中必须只能有一个保留默认参数</p>
</blockquote>
<h4 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//占位参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">//第二个int 就是占位的，但是函数调用的时候必须要传进来具体值，占位参数也可以有默认值</span><br><span class="hljs-comment">//void func(int a,int = 10); 这个也是正确的</span><br></code></pre></td></tr></table></figure>

<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>作用：【函数名可以相同，提高复用性】</p>
<blockquote>
<p>函数重载满足的条件</p>
</blockquote>
<ul>
<li>同一个作用域下</li>
<li>函数名相同</li>
<li>函数的<strong>参数类型不同</strong>或者 **个数不同 **或者 <strong>顺序不同</strong></li>
</ul>
<p>【注意】函数的返回值不能够作为函数重载的条件，只能是上面那三个差别。但是函数重载是可以返回值不一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;int func(int a,double b)&quot;</span> &lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (char c)&quot;</span> &lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//重载的原因是参数导致的，返回值不参与</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>其他的重载函数注意</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> =<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//有默认值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-type">int</span> c =<span class="hljs-number">10</span>; <br>    <span class="hljs-built_in">f</span>(c);<span class="hljs-comment">//调用的无const    因为a是个变量，可以改,即int &amp;a =c ;合法</span><br>    <br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">//调用有coonst ， 10是个常量，const int&amp;a =10 合法</span><br>       <br>     <span class="hljs-built_in">f1</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">//这个时候就不知到调用哪个f1了，需要避免</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="【类与对象】"><a href="#【类与对象】" class="headerlink" title="【类与对象】"></a>【类与对象】</h2><blockquote>
<p>三大特性</p>
</blockquote>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<blockquote>
<p>权限：public protect private</p>
</blockquote>
<ul>
<li><p>public  类外和类内都可以访问</p>
</li>
<li><p>protect 类外不可以访问，但是子类继承可以访问</p>
</li>
<li><p>private 类外不可以访问，但是子类不能可以访问</p>
</li>
</ul>
<h3 id="1-class-和-struct差别"><a href="#1-class-和-struct差别" class="headerlink" title="1. class 和 struct差别"></a>1. class 和 struct差别</h3><ul>
<li>struct 默认权限是public</li>
<li>class 默认权限是private</li>
</ul>
<h3 id="2-对象的初始化和清理"><a href="#2-对象的初始化和清理" class="headerlink" title="2. 对象的初始化和清理"></a>2. 对象的初始化和清理</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221127155115222.png" srcset="/img/loading.gif" lazyload alt="image-20221127155115222"></p>
<h4 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h4><p>两种分类方式</p>
<ul>
<li>按参数分类：有参构造和无参构造</li>
<li>按类型分类：普通构造和拷贝构造</li>
</ul>
<p>三种调用方式</p>
<ul>
<li>括号法</li>
<li>显示法</li>
<li>隐士转换法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span> &#123;<br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">person</span>()&#123;<br>        <br>    &#125;<br>   <br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)&#123;<br>        age = a;<br>        cout &lt;&lt; age &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)&#123;<br>        age = p.age;<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()&#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//括号法</span><br>person p1;  <span class="hljs-comment">//默认构造函数调用，person p1();这个不行，这个会被认为是一个函数声明</span><br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 有参构造函数调用</span><br><span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<span class="hljs-comment">//采用拷贝构造函数调用</span><br><br><span class="hljs-comment">//显示法</span><br>person p1;<br>person p2 = <span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//有参构造</span><br>person p3 = <span class="hljs-built_in">person</span>(p2) <span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>) ;<span class="hljs-comment">//匿名对象，最好不要拷贝构造函数初始化匿名对象</span><br><br><span class="hljs-comment">//隐士转换法</span><br>person p4 = <span class="hljs-number">10</span>;<span class="hljs-comment">//相当于 person p4 = person(10);</span><br>person p5 = p3; <span class="hljs-comment">//相当于person p5 = person(p3);</span><br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>拷贝构造函数的调用时机</p>
</blockquote>
<ul>
<li><p>使用一个已经创建完毕的对象初始化一个新对象</p>
</li>
<li><p>值传递的方式给函数初始值</p>
</li>
<li><p>值方式返回局部对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1. 使用一个已经创建完毕的对象初始化一个新对象</span><br><span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>; <span class="hljs-comment">//这个是直接调用拷贝函数初始化一个对象</span><br><br><span class="hljs-comment">//2. 使用值传递方式给函数参数赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(person p)</span></span>&#123;<br>    <br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-built_in">f</span>(p1);  <span class="hljs-comment">//这个相当于隐士调用，person p = p1  =&gt;person p = person(p1);</span><br>    <span class="hljs-comment">//会调用这个拷贝函数</span><br>&#125;<br><br><span class="hljs-comment">//3. 值方式返回局部对象  -- 记住一点就行，返回的是值，也是值传递，(会去调用拷贝构造)</span><br><span class="hljs-function">person <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    person p;<br>    <span class="hljs-keyword">return</span> p;  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<br>     person p1 = <span class="hljs-built_in">f</span>();  <span class="hljs-comment">//这个会返回一个值对象，也就是不是f()中的那个p，而是拷贝了一份返回回来了</span><br>    <span class="hljs-comment">//person p1 = p; 隐士转换</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><ul>
<li>一般默认会给我们提供无参构造函数，和拷贝构造函数</li>
<li>如果我们写了有参构造函数，编译器就不再提供默认构造函数，但是依旧提供拷贝构造函数</li>
</ul>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><ul>
<li>浅拷贝：简单的赋值拷贝操作</li>
<li>深拷贝：在堆区中重新申请空间，进行拷贝操作</li>
</ul>
<blockquote>
<p>浅拷贝</p>
</blockquote>
<p>直接拷贝复制过去，如果其中一个对象调用了析构函数，就会使得共同指向的堆区被其中一个释放</p>
<p>从而导致另一个对象无法访问和释放</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221128110425379.png" srcset="/img/loading.gif" lazyload alt="image-20221128110425379"></p>
<blockquote>
<p>深拷贝</p>
</blockquote>
<p>重新在堆空间申请一块内存给到赋值的对象</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221128110551004.png" srcset="/img/loading.gif" lazyload alt="image-20221128110551004"></p>
<blockquote>
<p>总结</p>
</blockquote>
<p><strong>如果类中有在堆区开辟的属性，那么一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p>
<h4 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//就是上面的那个f()函数，返回一个person</span><br>person p1 = <span class="hljs-built_in">f</span>();<span class="hljs-comment">//这个有的编译器会进行返回值优化，也就是直接将p1指向f()中的p的空间</span><br></code></pre></td></tr></table></figure>



<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><blockquote>
<p>将堆区代码开辟的空间释放</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221127155150127.png" srcset="/img/loading.gif" lazyload alt="image-20221127155150127"></p>
<h3 id="3-类的静态成员"><a href="#3-类的静态成员" class="headerlink" title="3. 类的静态成员"></a>3. 类的静态成员</h3><blockquote>
<p>变量</p>
</blockquote>
<ul>
<li>所有对象共享这个一个变量</li>
<li>编译阶段分配内存</li>
<li>类内声明，类外初始化操作</li>
<li>访问方式： 可以直接  <strong>类名::变量</strong>访问，也可以用对象访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-type">static</span> <span class="hljs-type">int</span> age;  <span class="hljs-comment">//类内声明</span><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<span class="hljs-comment">//外部无法访问</span><br>    <br>&#125;<br>person::age = <span class="hljs-number">10</span>;<span class="hljs-comment">//类外初始化</span><br>person::num =<span class="hljs-number">30</span>;<span class="hljs-comment">//</span><br><br><span class="hljs-built_in">main</span>()&#123;<br>    person p;<br>    p.age = <span class="hljs-number">100</span>;<br>    person::age =<span class="hljs-number">20</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>静态成员函数</p>
</blockquote>
<ul>
<li>全局共享</li>
<li>只能访问类的静态成员变量</li>
</ul>
<h3 id="4-对象模型和this指针"><a href="#4-对象模型和this指针" class="headerlink" title="4. 对象模型和this指针"></a>4. 对象模型和this指针</h3><blockquote>
<p><strong>成员变量  和  成员函数  是分开存储的</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p) ==&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//空对象的占用空间是1</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p); ==&gt;<span class="hljs-number">4</span> <span class="hljs-comment">//占用4</span><br><br><span class="hljs-keyword">class</span> person&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p) ==&gt;<span class="hljs-number">4</span>;<span class="hljs-comment">//静态成员不属于对象的</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//函数也不属于类对象上，只有一份</span><br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p) ==&gt;<span class="hljs-number">4</span> ;<span class="hljs-comment">//函数也是单独存储的</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>this指针</p>
</blockquote>
<p>每一个非静态成员函数只会诞生一个函数实例，也就是多个同类型的对象会公用同一块代码</p>
<p>那么这一块代码如何区分哪个对象调用自己的呢？</p>
<p>通过this指针解决</p>
<p><strong>this 指针指向的是每一个被调成员函数所属的对象，每一个非静态成员函数都包含this指针</strong></p>
<p>this指针不需要定义，直接使用</p>
<p>this指针的用途：</p>
<ul>
<li>当形参和成员变量同名时，用this指针取分</li>
<li>在类的非静态成员函数返回对象本身，使用return *this;</li>
</ul>
<h3 id="5-常函数和常对象"><a href="#5-常函数和常对象" class="headerlink" title="5. 常函数和常对象"></a>5. 常函数和常对象</h3><p><strong>this本质是指针常量—&gt;不能修改指向，可以修改指向的变量的值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//这个代表就是常函数--&gt;也就是this现在是一个const person * const p；</span><br><span class="hljs-comment">//无法修改值和指向</span><br><span class="hljs-comment">//但是可以修改类中的mutable修饰的对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;a = <span class="hljs-number">100</span>;  <span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> a;  <span class="hljs-comment">//特殊变量，可以被常函数引用和修改</span><br><span class="hljs-type">int</span> b;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>常变量</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> person p;  <br>p-&gt;b =<span class="hljs-number">10</span>; <span class="hljs-comment">//错误</span><br>p-&gt;a =<span class="hljs-number">100</span>;<span class="hljs-comment">//可以 常量可以修改mutable修饰的变量</span><br><br>p.<span class="hljs-built_in">func</span>();<span class="hljs-comment">//只能调用常函数</span><br><br></code></pre></td></tr></table></figure>

<h3 id="6-友元"><a href="#6-友元" class="headerlink" title="6. 友元"></a>6. 友元</h3><blockquote>
<p>在程序中，有些是私有属性，也想让类外特殊的一些函数或者类进行访问，这就需要友元技术</p>
<p>即朋友</p>
<p>【目的】让一个类或者函数访问另一个类的私有成员</p>
<p>【关键字】 friend</p>
<p>【用法】在类中加入 friend xxx       xxx表示全局方法或类</p>
</blockquote>
<blockquote>
<p>全局函数做友元</p>
<p>类做友元</p>
<p>类成员做友元：要指定哪个类的方法   **friend  void  Person::visit();    **</p>
</blockquote>
<h3 id="7-运算符重载"><a href="#7-运算符重载" class="headerlink" title="7. 运算符重载"></a>7. 运算符重载</h3><h4 id="号重载"><a href="#号重载" class="headerlink" title="+号重载"></a>+号重载</h4><blockquote>
<p>用于两个类相加，普通的+号不适用</p>
<p>可以在<strong>类中</strong>定义operator+(person &amp;p){…};方法，就可以用+号了，重载了普通+号</p>
<p>也可以在<strong>全局</strong>定义operator+(person &amp;p，perosn &amp;m){…};</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130105637224.png" srcset="/img/loading.gif" lazyload alt="image-20221130105637224"></p>
<blockquote>
<p>运算符重载，也可以发生函数重载</p>
</blockquote>
<img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130105857072.png" srcset="/img/loading.gif" lazyload alt="image-20221130105857072" style="zoom:50%;">

<p><strong>operator+()函数重载，参数不同，但是都可以作为+号的重载</strong></p>
<h4 id="lt-lt-重载"><a href="#lt-lt-重载" class="headerlink" title="&lt;&lt; 重载"></a>&lt;&lt; 重载</h4><blockquote>
<p>只能利用全局函数重载左移运算符</p>
</blockquote>
<p> <img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130111234668.png" srcset="/img/loading.gif" lazyload alt="image-20221130111234668"></p>
<h4 id="号重载-1"><a href="#号重载-1" class="headerlink" title="= 号重载"></a>= 号重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> * age;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a)&#123;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(a);<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person p)&#123;<br>        <span class="hljs-comment">//浅拷贝 ： this-&gt;age = p.age;</span><br>        <br>        <span class="hljs-comment">//这个就是深拷贝，这堆区中重新new一块内存给这个对象</span><br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[p.age];<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        <span class="hljs-keyword">if</span>(age !=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> age;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Person p)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;age != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> age;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p.age);  <span class="hljs-comment">//实现了深拷贝</span><br>    &#125;<br>&#125;<br><br><br>person p1;<br>person p2 = p1; **<span class="hljs-comment">//这也是可以的，这个是调用的拷贝构造的，跟=号没关系**，本质是person p2(p1);</span><br>但是上面的是**拷贝构造导致的浅拷贝**，会出现重复释放内存的问题,所以要重写拷贝构造函数<br>    <br>    <br><span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//如果没有重载 = 号，就会崩掉，因为会导致浅拷贝的重复释放，</span><br><span class="hljs-comment">//如果重载了 = 号，就是将=号变为深拷贝，就会给p2在堆区重新申请空间</span><br>p2 = p1;  <br><span class="hljs-comment">//所以我们要重载 这个=号，使他进行深拷贝</span><br>  <br></code></pre></td></tr></table></figure>



<blockquote>
<p>对于那个拷贝构造函数出现的浅拷贝，是在构造的时候给对象赋值用的</p>
<p>=号是构造完成之后，要发生重新赋值的时候用的，用的地方不同</p>
</blockquote>
<h4 id="号重载-2"><a href="#号重载-2" class="headerlink" title="== 号重载"></a>== 号重载</h4><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载 *"></a>函数调用运算符重载 *</h4><p>STL用的比较多–也叫仿函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-comment">//实现了()重载，</span><br>    	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string s)</span></span>&#123;<br>            cout &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>&#125;<br><span class="hljs-built_in">test</span>()&#123;<br>	person p;<br>        <span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//像不像一个函数调用，所以也称作仿函数</span><br>       <span class="hljs-built_in">person</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//这个叫做匿名对象+（）重载</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8. 继承"></a>8. 继承</h3><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><blockquote>
<p>基本语法</p>
</blockquote>
<p>class 子类 ：继承方式 父类</p>
<p>子类也叫派生类</p>
<p>父类也叫基类</p>
<blockquote>
<p>继承方式</p>
</blockquote>
<ul>
<li>公共继承：到子类中，除了私有属性不可访问，其他的属性权限不变</li>
<li>保护继承：到子类中，除了私有属性不可访问，其他属性权限都变成protected</li>
<li>私有继承：到子类中，除了父类的私有属性无法访问，其他属性变成private</li>
</ul>
<p><strong>父类的私有成员可以被继承，但是子类自己也无法访问</strong></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130115752687.png" srcset="/img/loading.gif" lazyload alt="image-20221130115752687"></p>
<h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-type">int</span> A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> C;  <span class="hljs-comment">//父类的私有变量会被继承下去，但是无法访问</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> D;<br>&#125;<br><br><span class="hljs-built_in">test</span>()&#123;<br>	Son son;<br>    cout&lt;&lt; <span class="hljs-built_in">sizeof</span>(son) &lt;&lt; endl;<span class="hljs-comment">//这个输出是16 </span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在指定的类文件下使用  <code>cl /d1 reportSingleClassLayout类名 文件名</code>可以查看对象模型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130120844425.png" srcset="/img/loading.gif" lazyload alt="image-20221130120844425"></p>
<h4 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，同时会调用父类的构造函数创建父类对象</p>
<p>【问题】那么父类和子类的构造和析构顺序谁先谁后？</p>
<p>【答案】<strong>先父类的构造函数，在子类构造函数（从里到外），先子类的析构函数，再父类的析构函数（从外到里）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    Son son;<br>&#125;<br>father 构造函数<br>son 构造函数<br>son 析构函数<br>father 析构函数<br></code></pre></td></tr></table></figure>

<h4 id="继承中子类父类重名成员"><a href="#继承中子类父类重名成员" class="headerlink" title="继承中子类父类重名成员"></a>继承中子类父类重名成员</h4><blockquote>
<p>方法重名应该是重写？<strong>如果子类中出现了一个和父类重名的函数，那么会覆盖所有的父类相同函数名重载的函数</strong>，如果想调用，就必须指定作用域</p>
</blockquote>
<p>如果没有指定作用域，默认是子类的，如果子类没有，才会父类的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> A =<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> A =<span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot; son&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    Son son;<br>    cout &lt;&lt; son.A &lt;&lt;endl; <span class="hljs-comment">//10</span><br>    cout &lt;&lt; son.Father::A &lt;&lt; endl ; <span class="hljs-comment">// 20  指定作用域</span><br>    son.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// son</span><br>    son.Father::<span class="hljs-built_in">f</span>();<span class="hljs-comment">//father   </span><br>    son.<span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">//错误，如果子类中出现了一个和父类重名的函数，那么会覆盖所有的父类相同函数名重载的函数</span><br>    son.Father::<span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//正确</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="继承中同名静态成员处理方式"><a href="#继承中同名静态成员处理方式" class="headerlink" title="继承中同名静态成员处理方式"></a>继承中同名静态成员处理方式</h4><p>和普通的一样，只是静态的访问方式可以直接类访问</p>
<blockquote>
<p><strong>父类中的静态变量和子类中的静态变量不是同一个全局变量</strong></p>
<p>静态变量只能在同一个类中共享，而不能在父类和子类中共享</p>
</blockquote>
<h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>利用虚继承解决菱形继承问题</p>
<h3 id="9-多态"><a href="#9-多态" class="headerlink" title="9. 多态"></a>9. 多态</h3><h4 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a>多态概念</h4><blockquote>
<p>多态分类：</p>
<ul>
<li>静态多态：函数重载和运算符重载都属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时多态</li>
</ul>
<p>静态多态和动态多态区别</p>
<ul>
<li>静态多态的函数地址早绑定 - <strong>在编译阶段确定函数地址</strong></li>
<li>动态多态的函数地址晚绑定 - <strong>在运行阶段确定函数地址</strong></li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father is eating&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;father&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;son is eating&quot;</span> &lt;&lt; endl; <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;son&quot;</span> &lt;&lt;endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Father &amp;f)</span></span>&#123;<br>    f.<span class="hljs-built_in">eat</span>();<br>    f.<span class="hljs-built_in">sing</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	Son s;<br>        <span class="hljs-built_in">test</span>(s);  <span class="hljs-comment">//输出 son is eating 、 father</span><br>    <span class="hljs-comment">//因为eat()是虚函数，在使用的时候才会被动态绑定，对于非虚函数就不行</span><br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>多态满足条件</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类的<strong>虚函数</strong></li>
</ul>
<p>多态使用：</p>
<ul>
<li><strong>父类指针或者引用指向子类对象</strong></li>
</ul>
</blockquote>
<h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Anima</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物说话&quot;</span>  &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Animal == &quot;</span> &lt;&lt;  <span class="hljs-built_in">sizeof</span>(Animal) &lt;&lt; endl;  <span class="hljs-comment">// 1;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>非静态函数是分开存储的</p>
<p><strong>当加上virtual 就会变成4个字节了</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Anima</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物说话&quot;</span>  &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Animal == &quot;</span> &lt;&lt;  <span class="hljs-built_in">sizeof</span>(Animal) &lt;&lt; endl;  <span class="hljs-comment">// 4;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>多态原理</p>
</blockquote>
<ul>
<li>首先只有继承了父类，并重写了父类的虚函数，就可以实现多态的效果</li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221206104124309.png" srcset="/img/loading.gif" lazyload alt="image-20221206104124309"></p>
<p>如果一个父类有着虚函数，那么这个类中就会多一个变量 vfptr ,这个变量指向父类自己的虚函数表，</p>
<p>虚函数表中包含的是自己的虚函数的函数指针（地址）</p>
<p>如果一个子类继承了父类，那么就会继承这个虚函数表（重新复制一份，不是共享）和vfptr，这个vfptr指向自己的虚函数表，如果重写了父类的虚函数，那么就会将这个虚函数表的对应的父类的虚函数的指针指向自己实现的虚函数。</p>
<p>具体效果如上图所示。</p>
<p><strong>虚函数表是每个类都有的，父类和子类都有自己的虚函数表，如果子类继承父类，将父类中的虚函数表中的内容复制到自己的虚函数表中，如果重写了，写自己的虚函数表的地址</strong></p>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类的虚函数的实现往往是无意义的，因为都是调用子类重写的内容</p>
<p>因此可以将虚函数改为<strong>纯虚函数</strong></p>
<p>什么是纯虚函数，就是父类中的虚函数没有任何东西，相当于只有一个声明</p>
<p>语法：<code>virtual 返回值类型 函数名（参数列表） = 0；</code></p>
<blockquote>
<p> <strong>那么什么是抽象类呢？</strong></p>
</blockquote>
<p>一个类中有了纯虚函数，就是抽象类</p>
<p>【特点】：</p>
<ul>
<li><strong>无法实例化对象</strong></li>
<li><strong>子类继承后必须重写抽象类中的纯虚函数，否则也属于纯虚函数</strong></li>
</ul>
<h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;animal 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Animal</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;animal 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br>    string *s;<br>    <span class="hljs-built_in">Cat</span>(string name)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;cat 构造函数&quot;</span> &lt;&lt; endl;<br>        s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    ~<span class="hljs-built_in">Cat</span>()&#123;<br>        <span class="hljs-keyword">if</span>(s !=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> s;<br>            cout &lt;&lt; <span class="hljs-string">&quot;cat 析构函数&quot;</span> &lt;&lt; endl;<br>            s = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; *s &lt;&lt; <span class="hljs-string">&quot;cat speak&quot;</span> &lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>    Animal *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    a-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> a;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">animal 构造函数<br>cat 构造函数<br>Tom cat speak<br>animal 析构函数<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面说明了父类指针在析构的时候，不会调用子类的析构函数,就会导致子类总如果有堆区属性</p>
<p>就会出现堆区泄露现象。</p>
</blockquote>
<p>【解决方法】</p>
<ul>
<li><strong>在父类的析构函数加上virtual关键字，使其变成一个虚函数，这样就可以调用子类的析构函数了</strong></li>
<li>这样就可以父类指针释放子类对象不干净的问题</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">animal 构造函数<br>cat 构造函数<br>Tom cat speak<br>cat 析构函数<br>animal 析构函数<br></code></pre></td></tr></table></figure>



<blockquote>
<p>什么是纯虚析构？</p>
</blockquote>
<p>就是父类的虚构函数写成了纯虚函数形式：virtual ~Animal（） = 0；</p>
<p>但是这个直接运行是有问题的，因为父类中也需要析构函数，解决办法是在类的外面进行实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;<br>Animal::~<span class="hljs-built_in">Animal</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;纯虚析构&quot;</span> &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>有点类似于静态变量，类内声明，类外实现</p>
<h2 id="【文件操作】"><a href="#【文件操作】" class="headerlink" title="【文件操作】"></a>【文件操作】</h2><p><strong>c++ 中文件操作需要包含头文件</strong><fstream></fstream></p>
<p>文件类型包含两种：</p>
<ul>
<li>文本文件 ：文件以文本的ascii码进行存储在计算机中</li>
<li>二进制文件： 文件以文本的二进制形式存储在计算机中</li>
</ul>
<h3 id="1-操作文件的类"><a href="#1-操作文件的类" class="headerlink" title="1. 操作文件的类"></a>1. 操作文件的类</h3><p>操作文件的三大类：</p>
<ul>
<li>ofstream ： 写操作</li>
<li>ifstream： 读操作</li>
<li>fstream ： 读写操作</li>
</ul>
<h3 id="2-文本文件"><a href="#2-文本文件" class="headerlink" title="2. 文本文件"></a>2. 文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>基本步骤</p>
<ul>
<li>1.包含头文件 #include<fstream></fstream></li>
<li>2.创建流对象   ofstream ofs；</li>
<li>3.打开文件    ofs.open(“文件路径”，打开方式)；</li>
<li>4.写数据   ofs &lt;&lt; “写入的数据”；</li>
<li>5.关闭文件  ofs.close();</li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221206120103158.png" srcset="/img/loading.gif" lazyload alt="image-20221206120103158"></p>
<p>如果想要多个方法使用，用 | 符号就行</p>
<h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>基本步骤</p>
<ul>
<li>1.包含头文件 #include<fstream></fstream></li>
<li>2.创建流对象   ifstream ifs；</li>
<li>3.打开文件    ifs.open(“文件路径”，打开方式)；</li>
<li>4.读数据   四种方式读取</li>
<li>5.关闭文件  ifs.close();</li>
</ul>
<blockquote>
<p>读数据的四种方式</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(ifs &gt;&gt; buf)&#123;<br>	cout &lt;&lt; buf &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(ifs.<span class="hljs-built_in">getline</span>(buf,<span class="hljs-built_in">sizeof</span>(buf)))&#123;<br>    cout &lt;&lt; buf &lt;&lt;endl;<br>&#125;<br><br>string buf;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ifs,buf))&#123;<br>    cout &lt;&lt; buf &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> buf;<br><span class="hljs-keyword">while</span>((c = ifs.<span class="hljs-built_in">get</span>()) !=EOF)&#123;<br>    cout &lt;&lt; c &lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-二进制文件"><a href="#3-二进制文件" class="headerlink" title="3. 二进制文件"></a>3. 二进制文件</h3><p>以二进制方式对文件进行读写</p>
<p><strong>打开方式要指定ios::binary;</strong></p>
<h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ofstream ofs;<br>    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary);<br>    Person p = &#123;<span class="hljs-number">18</span>,<span class="hljs-string">&quot;张三&quot;</span>&#125;；<br>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;p,<span class="hljs-built_in">sizeof</span>(Person)); <span class="hljs-comment">//将p写入到文件中</span><br>    ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary);<br>    Person p = &#123;<span class="hljs-number">18</span>,<span class="hljs-string">&quot;张三&quot;</span>&#125;;<br>    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p,<span class="hljs-built_in">sizeof</span>(Person)); <span class="hljs-comment">//读进来文件</span><br>    cout &lt;&lt; p.age &lt;&lt; p.name &lt;&lt;endl;<br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="【模板和STL】"><a href="#【模板和STL】" class="headerlink" title="【模板和STL】"></a>【模板和STL】</h2><h3 id="1-泛型编程"><a href="#1-泛型编程" class="headerlink" title="1. 泛型编程"></a>1. 泛型编程</h3><p>c++的一种编程思想就是泛型编程，主要是利用的技术就是模板</p>
<p>c++提供的两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></p>
<h3 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2. 函数模板"></a>2. 函数模板</h3><blockquote>
<p>函数模板的作用</p>
</blockquote>
<p>建立一个通用函数，其函数的返回值类型和形参类型都可以不具体指定，用一个<strong>虚拟的类型</strong>来代表</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或者定义<br><br><span class="hljs-keyword">template</span> --- 声明这是一个模板<br><span class="hljs-keyword">typename</span> --- 表明后面的符号代表一个数据类型，可以用<span class="hljs-keyword">class</span>代替<span class="hljs-keyword">typename</span><br>T --- 通用数据类型，名称可以替换<br></code></pre></td></tr></table></figure>

<blockquote>
<p>举例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">( T &amp;a, T &amp;b)</span></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-comment">//1. 自动类型推导</span><br>    <span class="hljs-comment">// myswap(a,b);</span><br>    <span class="hljs-comment">//2. 显示指定类型</span><br>    <span class="hljs-built_in">myswap</span>&lt;<span class="hljs-type">int</span>&gt; (a,b);<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>函数模板注意事项</p>
</blockquote>
<ul>
<li><p><strong>自动类型推导，必须推导出一直的类型才能使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> c;<br><span class="hljs-built_in">myswap</span>(a,c);<span class="hljs-comment">//这个就会出错，不能够推导出一致的数据类型</span><br></code></pre></td></tr></table></figure></li>
<li><p><strong>模板必须要确定出T的数据类型，才可以使用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">//这个函数没有使用到T，但是在函数调用的时候必须也要指定类型</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//错误的</span><br>    <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">//正确</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="函数模板和普通函数的区别"><a href="#函数模板和普通函数的区别" class="headerlink" title="函数模板和普通函数的区别"></a>函数模板和普通函数的区别</h4><ul>
<li><p>普通函数在调用的时候是可以发生隐士类型转换的</p>
<ul>
<li>隐式类型转换有两种，一种是算术类型转换（就是比如int 和 long赋值会发生类型转换），一种是类类型转换（这个就是上面的隐士转换法）</li>
</ul>
</li>
<li><p>函数模板 用自动类型推导，不可以发生隐式类型转换</p>
</li>
<li><p>函数模板 用显示指定类型，可以发生隐式类型转换</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myadd1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myadd2</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>	<span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br>         <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">myadd1</span>(a,c) &lt;&lt; endl ;<span class="hljs-comment">//这个结果是107，因为字符c被转换成了int，表示97，发生了隐士类型转换</span><br>        cout &lt;&lt; <span class="hljs-built_in">myadd2</span>(a,c) &lt;&lt; endl; <span class="hljs-comment">// 错误，无法发生隐式类型转换，无法推导出一致类型</span><br>        cout &lt;&lt; <span class="hljs-built_in">myadd2</span>&lt;<span class="hljs-type">int</span>&gt;(a,c) &lt;&lt; endl;  <span class="hljs-comment">//正确，可以发生隐式类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>建议使用显示指定类型</strong></p>
</blockquote>
<h4 id="普通函数和函数模板的调用规则"><a href="#普通函数和函数模板的调用规则" class="headerlink" title="普通函数和函数模板的调用规则"></a>普通函数和函数模板的调用规则</h4><blockquote>
<p>问题来源：普通函数名称和函数模板的名称相同，参数个数应该也相同吧</p>
</blockquote>
<ul>
<li>如果函数模板和函数模板都可以调用，那么优先调用普通函数（使用的是自动类型转换方式调用）</li>
<li>通过空模板参数列表，可以强制调用函数模板</li>
<li>函数模板间也可以发生重载，和一般重载一个意思，一般参数个数不同</li>
<li>如果函数模板可以产生更好的匹配，优先调用函数模板 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;普通函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T a, T b)</span></span>&#123;       <span class="hljs-comment">//允许同名函数存在，但是如果调用了 int a =9;int b =10; print(a,b);优先走普通函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;模板函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(a,b); <span class="hljs-comment">//优先普通函数</span><br>    <br>    print&lt;&gt;(a,b); <span class="hljs-comment">//这个时候强制调用函数模板</span><br>    <br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;k&#x27;</span>;<br>    <span class="hljs-type">char</span> d = <span class="hljs-string">&#x27;j&#x27;</span>;<br>    <span class="hljs-built_in">print</span>(c,d);<span class="hljs-comment">//这个时候调用函数模板，更好的匹配</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h4><h3 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3. 类模板"></a>3. 类模板</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote>
<p>作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型代表</p>
</blockquote>
<blockquote>
<p>语法： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> K,....&gt;<br>类<br></code></pre></td></tr></table></figure>
</blockquote>
<p>template  声明创建模板</p>
<p>typename  表明后面的符号表示虚拟类型</p>
<p>T 虚拟类型，可以有多个</p>
<blockquote>
<p>案例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    N name;<br>    T age;<br>    <span class="hljs-built_in">person</span>(N n,T t)&#123;<br>        <span class="hljs-keyword">this</span>.name = n;<br>        <span class="hljs-keyword">this</span>.age = t;<br>    &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>       cout &lt;&lt; <span class="hljs-keyword">this</span>.name &lt;&lt; endl;<br>       cout &lt;&lt; <span class="hljs-keyword">this</span>.age &lt;&lt; endl;<br>   &#125;<br>&#125;<br><span class="hljs-comment">//使用类模板</span><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;  <br>    p.<span class="hljs-built_in">show</span>(); <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h4><ul>
<li>类模板没有自动类型推导的方式</li>
<li>类模板在模板参数列表中可以有默认参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类模板没有自动类型推导的方式</span><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">19</span>)</span></span>;<span class="hljs-comment">//这个是错误的，必须指明类型即person&lt;string,int&gt; p(&quot;hello&quot;,19);才正确</span><br>&#125;<br><span class="hljs-comment">//类模板在模板参数列表中可以有默认参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> = <span class="hljs-type">int</span>&gt; <span class="hljs-comment">//默认后面的那个类型是T，可以不用在创建时指定</span><br><span class="hljs-keyword">class</span> person&#123;<br>    ....<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h4><blockquote>
<p><strong>类模板的成员函数在调用的时候才会去创建</strong></p>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    T obj;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<br>        obj.<span class="hljs-built_in">show1</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123;<br>        obj.<span class="hljs-built_in">show2</span>();<br>	&#125;<br>    <span class="hljs-comment">//像上面f1和f2都是在调用的时候才会创建，因为它并不知道obj到底是个什么类型的对象</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><ul>
<li>类模板实例化出的对象，向函数传参的方式</li>
</ul>
<p>一共有三种传入方式</p>
<ul>
<li>指定传入类型   最常用</li>
<li>参数模板化</li>
<li>整个类模板化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    N name;<br>    T age;<br>    <br>    <span class="hljs-built_in">person</span>(N n,T t)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = n;<br>        <span class="hljs-keyword">this</span>-&gt;age = t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1. 指定传入类型,模板类作为参数，指定具体的虚拟类型 -------这个最常用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">( person&lt;string,<span class="hljs-type">int</span>&gt; &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-comment">//2. 参数模板化,模板类作为参数，不指定具体的虚拟类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(person&lt;T1,T2&gt; &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-comment">//3. 将整个类模板化,模板类作为参数，这个就是名副其实的模板函数了</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">(T &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-comment">//1.</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-built_in">test</span>(p);<br>    <span class="hljs-comment">//2.这个像一个模板函数</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-built_in">test2</span>(p1); <span class="hljs-comment">//正常输出</span><br>    <span class="hljs-comment">//3. test3就是一个模板函数，然后自动类型推导</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;he&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-built_in">test3</span>(p2); <span class="hljs-comment">//正常</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>



<h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><blockquote>
<p>当类模板碰到继承时，需要注意以下几点</p>
</blockquote>
<ul>
<li>当子类继承的父类是一个类模板时，子类在声明的时候，需要指出父类中T的类型</li>
<li>如果不指定，编译器无法给子类分配内存</li>
<li>如果想灵活指定父类中的T的类型，子类也需要变为类模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    T m;<br>&#125;<br><span class="hljs-comment">//1. 当子类继承的父类是一个类模板时，子类在声明的时候，需要指出父类中T的类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base   <span class="hljs-comment">//这是错误的，没有指定具体类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt; &#123;&#125;<span class="hljs-comment">//这个是正确的</span><br><br><span class="hljs-comment">// 2. 如果想灵活指定父类中的T的类型，子类也需要变为类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : Base&lt;T2&gt;<br>&#123;<br>    T1 obj;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    Son&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt; son;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="类模板成员函数的类外实现"><a href="#类模板成员函数的类外实现" class="headerlink" title="类模板成员函数的类外实现**"></a>类模板成员函数的类外实现**</h4><p>实际中类的声明和成员函数的声明都是在.h文件中，实现在.cpp文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Person</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T t, K k); <span class="hljs-comment">//类内声明，类外实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br> T t;<br>  K k;<br>&#125;<br><br><span class="hljs-comment">//类外实现，格式一定要正确</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br>Person&lt;T,K&gt;::<span class="hljs-built_in">Person</span>(T t, K k)&#123;  <br>    <span class="hljs-keyword">this</span>-&gt;t = t;<br>    <span class="hljs-keyword">this</span>-&gt;k = k;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br> <span class="hljs-type">void</span> Person&lt;T,K&gt;::<span class="hljs-built_in">show</span>()&#123;<br>     cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;t &lt;&lt; <span class="hljs-keyword">this</span>-&gt;k &lt;&lt; endl;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写**"></a>类模板分文件编写**</h4><p>分文件编写的时候，我们一般把类的声明和类成员函数的声明放在.h文件中</p>
<p>然后将类的成员函数的实现放到.cpp文件中</p>
<p>然后在使用的时候包含这个.cpp文件</p>
<p>在编写类模板的时，一般不分文件，将声明和实现都写到一个文件中，然后将这个文件命名为.hpp文件</p>
<h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4><blockquote>
<p>目标：掌握类模板配合友元函数的类内实现和类外实现</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">//类内实现</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f11</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//全局函数先声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//这个函数是一个全局函数，只不过在类内部声明，并表示是这个类的友元</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f11</span><span class="hljs-params">(Person&lt;T,K&gt; p)</span></span>&#123;<br>        cout &lt;&lt; p.k &lt;&lt; endl;   <span class="hljs-comment">//可以访问到这个类的私有成员</span><br>    &#125;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T t, K k); <span class="hljs-comment">//类内声明，类外实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br> T t;<br>  K k;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br>Person&lt;T,K&gt;::<span class="hljs-built_in">Person</span>(T t, K k)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;t = t;<br>    <span class="hljs-keyword">this</span>-&gt;k = k;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br> <span class="hljs-type">void</span> Person&lt;T,K&gt;::<span class="hljs-built_in">show</span>()&#123;<br>     cout &lt;&lt;<span class="hljs-keyword">this</span>-&gt;k &lt;&lt; <span class="hljs-keyword">this</span>-&gt;t&lt;&lt; endl;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    p.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-comment">// cout &lt;&lt; p.k &lt;&lt; endl;   //无法访问到私有成员</span><br>    <span class="hljs-built_in">f11</span>(p);<br>    <br>    <br><span class="hljs-comment">//类外实现</span><br> 直接看视频吧<br></code></pre></td></tr></table></figure>



<h2 id="【STL】"><a href="#【STL】" class="headerlink" title="【STL】"></a>【STL】</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul>
<li>为了建立数据结构和算法的一套标准，诞生了STL</li>
<li>STL —  Standard Template Library 标准模板库</li>
<li>STL 从广义上分为： <strong>容器（container） 算法（algorithm） 迭代器（iterator）</strong></li>
<li><strong>容器</strong>和<strong>算法</strong>之间通过迭代器进行无缝连接</li>
<li>STL几乎所有的代码都采用了模板类或模板函数</li>
</ul>
<h4 id="stl六大组件"><a href="#stl六大组件" class="headerlink" title="stl六大组件"></a>stl六大组件</h4><p>STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器、空间配置器</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113455135.png" srcset="/img/loading.gif" lazyload alt="image-20221212113455135"></p>
<h4 id="STL中的容器、算法、迭代器"><a href="#STL中的容器、算法、迭代器" class="headerlink" title="STL中的容器、算法、迭代器"></a>STL中的容器、算法、迭代器</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113532791.pngd" srcset="/img/loading.gif" lazyload alt="image-20221212113532791"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113554789.png" srcset="/img/loading.gif" lazyload alt="image-20221212113554789"></p>
<p>a<img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113657711.png" srcset="/img/loading.gif" lazyload alt="image-20221212113657711"></p>
<h3 id="2-vector"><a href="#2-vector" class="headerlink" title="2. vector"></a>2. vector</h3><p>  STL中最常用的容器是Vector，可以理解为数组，</p>
<h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器： vector</p>
<p>算法： for_each</p>
<p>迭代器： vector<int>::iterator</int></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>     <span class="hljs-comment">// 提供vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;alogrithm&gt;</span> <span class="hljs-comment">// 提供for_each()</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建一个vector容器对象，通过模板参数指定容器中存放的数据类型</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-comment">// 向容器中添加数据</span><br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    <br>    <span class="hljs-comment">// 每个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span><br>    <span class="hljs-comment">// v.begin() 返回迭代器，这个迭代器指向容器中的第一个元素</span><br>    <span class="hljs-comment">// v.end() 返回迭代器，这个迭代器指向容器中的最后一个元素的下一个位置</span><br>    <span class="hljs-comment">// vector&lt;int&gt;::iterator  拿到vector&lt;int&gt; 这种容器的迭代器类型</span><br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator begin_m = v.<span class="hljs-built_in">begin</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator  end_m = v.<span class="hljs-built_in">end</span>();<br><br>    <span class="hljs-keyword">while</span>(begin_m != end_m)&#123;<br>        cout &lt;&lt; *begin_m &lt;&lt; endl;<br>        begin_m++; <span class="hljs-comment">// 移动迭代器指向容器的下一个位置，迭代器暂时可以理解成指针，操作何指针相似</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),myprint); <span class="hljs-comment">// 这个是提供的遍历算法，myprint用来回调使用的，函数指针</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="vector存放自定义类型"><a href="#vector存放自定义类型" class="headerlink" title="vector存放自定义类型"></a>vector存放自定义类型</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    	<span class="hljs-type">int</span> age;<br>    	string name;<br>    	<span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> age, string name)&#123;<br>               age = age;<br>               name =name;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">person  <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;kk&quot;</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;ll&quot;</span>)</span></span>;<br>    <br>    vector&lt;person&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    <span class="hljs-keyword">for</span>(vector&lt;person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>()；  it != v.<span class="hljs-built_in">end</span>() ; it++)&#123;<br>        cout &lt;&lt; (*it).age &lt;&lt; (*it).name &lt;&lt; endl;<br>        cout &lt;&lt; it-&gt;age &lt;&lt; it -&gt;name &lt;&lt;endl;  <span class="hljs-comment">// 两种都可以</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>vector数据结构和数组非常相似，也称作单端数组</p>
<p>区别：</p>
<p>​    不同之处子啊与数组是静态空间，而vector是动态拓展的</p>
<blockquote>
<p><strong>动态拓展</strong></p>
</blockquote>
<ul>
<li><strong>==并不是在原来的空间之后续接新的空间，而是找到更大的空间，然后将原来的数据拷贝过去，释放原来的空间==</strong></li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216221251010.png" srcset="/img/loading.gif" lazyload alt="image-20221216221251010"></p>
<h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><p>创建vector容器</p>
<blockquote>
<p>函数原型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216221418471.png" srcset="/img/loading.gif" lazyload alt="image-20221216221418471"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">// vector&lt;int&gt; v2(v.begin(),v.end());</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v)</span></span>;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it!= v2.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h4><p>给vector容器赋值</p>
<blockquote>
<p>函数原型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216222222960.png" srcset="/img/loading.gif" lazyload alt="image-20221216222222960"> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">// vector&lt;int&gt; v2(v.begin(),v.end());</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2 ;<br>    v2.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it!= v2.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h4><p>对vector容器的容量和大小操作</p>
<blockquote>
<p>函数原型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216222506798.png" srcset="/img/loading.gif" lazyload alt="image-20221216222506798"></p>
<h4 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除*"></a>vector插入和删除*</h4><p>对vector进行插入和删除操作</p>
<blockquote>
<p>函数原型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216222845088.png" srcset="/img/loading.gif" lazyload alt="image-20221216222845088"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">// 2,3,4</span><br><br>    v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 2,3</span><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">100</span>);<span class="hljs-comment">// 100,2,3</span><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>);<span class="hljs-comment">// 1000,1000,100,2,3</span><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">// 1000,100,2,3</span><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 空</span><br></code></pre></td></tr></table></figure>



<h4 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取**"></a>vector数据存取**</h4><p>对vector中的数据进行存取操作</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216223531305.png" srcset="/img/loading.gif" lazyload alt="image-20221216223531305"></p>
<h4 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器**"></a>vector互换容器**</h4><p>实现两个容器内的元素进行互换</p>
<p>函数原型：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216223731255.png" srcset="/img/loading.gif" lazyload alt="image-20221216223731255"></p>
<blockquote>
<p>基本使用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-comment">// printvector(v);</span><br>    v.<span class="hljs-built_in">swap</span>(v2);<br>    <span class="hljs-built_in">printvector</span>(v);<br></code></pre></td></tr></table></figure>



<blockquote>
<p>用处：内存收缩</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216224817021.png" srcset="/img/loading.gif" lazyload alt="image-20221216224817021"></p>
<p>vector<int>(v).swap(v); //  vector<int>(v)创建了一个匿名类，相当于vector<int> x = v;x.swap(v);</int></int></int></p>
<p>因为匿名类使用完就释放了，所以收缩了空间</p>
<h4 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h4><p>减少vector在动态拓展容量时的拓展次数</p>
<p>函数原型：</p>
<p>​    <img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216225104464.png" srcset="/img/loading.gif" lazyload alt="image-20221216225104464"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>); <span class="hljs-comment">// 一开始就预留空间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p != &amp;v[<span class="hljs-number">0</span>])&#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; num &lt;&lt;endl; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>



<h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p><strong>string的本质是一个类</strong></p>
<h4 id="string-和-char-的区别"><a href="#string-和-char-的区别" class="headerlink" title="string 和 char *的区别"></a>string 和 char *的区别</h4><ul>
<li>char* 是一个指针</li>
<li>string是一个类，类的内部封装了char*，管理这个字符串，是一个<code>char*</code>型的容器</li>
</ul>
<p>特点：</p>
<p>string类内部封装了很多的成员方法</p>
<p>例如：查找：find 拷贝copy，删除delete，替换replace 插入insert</p>
<p>string 管理char*的所分配的内存，不用担心赋值越界和取值越界</p>
<h4 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h4><p>构造函数原型：</p>
<ul>
<li>string()   创建一个空的字符串，例如string str；</li>
<li>string(const char* s);  使用字符串s进行初始化</li>
<li>string(const string&amp; str);  使用一个string对象初始化另一个string对象</li>
<li>string(int n,char c);  使用n个字符c初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-type">char</span> * s = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(s)</span></span>;<br>    cout &lt;&lt; str2 &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(str2)</span></span>;<br>    cout &lt;&lt; s3 &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;t&#x27;</span>)</span></span>;<br>    cout &lt;&lt; s4 &lt;&lt; endl;<br>    <br>    <br>    <span class="hljs-comment">// 输出</span><br>    hello,world<br>     hello,world<br>    tttt<br><br></code></pre></td></tr></table></figure>

<h4 id="string-赋值操作"><a href="#string-赋值操作" class="headerlink" title="string 赋值操作"></a>string 赋值操作</h4><blockquote>
<p>功能：给string字符串赋值</p>
</blockquote>
<p>赋值的函数原型</p>
<ul>
<li>string &amp; operator=(const char* s);   // char*类型字符串 赋值给当前的字符串</li>
<li>string &amp; operator=(const string &amp;s); // 把字符串付给当前的字符串</li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216211730250.png" srcset="/img/loading.gif" lazyload alt="image-20221216211730250"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string str2= s;<br>    cout &lt;&lt; str2 &lt;&lt; endl;<br>    string s4;<br>    s4.<span class="hljs-built_in">assign</span>(str);<br>    cout &lt;&lt; s4 &lt;&lt; endl;<br>    string s5;<br>    s5.<span class="hljs-built_in">assign</span>(s,<span class="hljs-number">3</span>);<br>    cout &lt;&lt; s5 &lt;&lt;endl;<br><br>hello<br>hello<br>hello<br>hel<br>   <br></code></pre></td></tr></table></figure>



<h4 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216213353739.png" srcset="/img/loading.gif" lazyload alt="image-20221216213353739"></p>
<p><strong>从上面看出对于+号只能对 字符串或者字符可以，对于数字不行</strong></p>
<p><code>string&amp; append(cons string&amp; s,int pos,int n)</code>比较重要</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str += <span class="hljs-string">&quot;llll&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;world&quot;</span>;<br>    str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;kkkk&quot;</span>);<br>    str.<span class="hljs-built_in">append</span>(s);<br>    cout &lt;&lt; str &lt;&lt;endl;<br><br>    str.<span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str.<span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>hellollll<br>hellollllkkkkworld <br>hellollllkkkkworldwor<br>hellollllkkkkworldworld<br></code></pre></td></tr></table></figure>



<h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h4><p>查找：查找指定的字符串是否存在</p>
<p>替换：在指定的位置替换字符串</p>
<p>函数原型：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216214319972.png" srcset="/img/loading.gif" lazyload alt="image-20221216214319972"></p>
<p><strong>find和rfind其实就是一个从左往右查，一个是从右往左找</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">    string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <br>    <span class="hljs-type">int</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;l&quot;</span>);<br>    cout &lt;&lt; pos &lt;&lt; endl;<br><br>    cout &lt;&lt; str.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;l&quot;</span>) &lt;&lt;endl;<br>    cout &lt;&lt; str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;kkkkkk&quot;</span>);<br><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>hkkkkkklo<br></code></pre></td></tr></table></figure>

<h4 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h4><p>字符串之间的比较</p>
<p>比较方式：</p>
<ul>
<li>字符串比较按字符的ASCII码进行比较</li>
<li>=返回0</li>
<li><code>&gt;</code>返回1</li>
<li>&lt; 返回-1</li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216215145684.png" srcset="/img/loading.gif" lazyload alt="image-20221216215145684"></p>
<h4 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取*"></a>string字符存取*</h4><p>string中单个字符存取的方式有两种</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216215318884.png" srcset="/img/loading.gif" lazyload alt="image-20221216215318884"></p>
<h4 id="string中的插入和删除"><a href="#string中的插入和删除" class="headerlink" title="string中的插入和删除*"></a>string中的插入和删除*</h4><p>对string字符串进行插入和删除字符操作</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216215736224.png" srcset="/img/loading.gif" lazyload alt="image-20221216215736224"></p>
<p>都是从0开始，insert在pos位置开始，不是pos后面一位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;uuu&quot;</span>);<br>    cout &lt;&lt; str &lt;&lt;endl;<br>    str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    cout &lt;&lt;str &lt;&lt;endl;<br><br>huuuello<br>hello<br></code></pre></td></tr></table></figure>

<h4 id="string字串"><a href="#string字串" class="headerlink" title="string字串"></a>string字串</h4><p>从字符串中获取想要的字串</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216220129777.png" srcset="/img/loading.gif" lazyload alt="image-20221216220129777"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    cout &lt;&lt; str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) &lt;&lt;endl;<br>    cout &lt;&lt; str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt;endl;<br><br>hel<br>el<br>    <br>    string str = <span class="hljs-string">&quot;zhangsan@163.com&quot;</span>;<br>    <span class="hljs-type">int</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;@&quot;</span>);<br>    string s = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,pos);<br>    cout &lt;&lt; s &lt;&lt; endl;  <span class="hljs-comment">// zhangsan</span><br><br></code></pre></td></tr></table></figure>



<h3 id="4-deque"><a href="#4-deque" class="headerlink" title="4. deque"></a>4. deque</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>双端数组，可以进行头部插入删除操作</p>
<blockquote>
<p>deque与vector的区别</p>
</blockquote>
<ul>
<li>vector对于头部的插入删除效率低，数据量越大，效率越低</li>
<li>deque相对而言，对于头部的插入删除速度会比vector快</li>
<li>vector访问元素时的速度比deque快，这和两者的内部实现有关</li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218192027988.png" srcset="/img/loading.gif" lazyload alt="image-20221218192027988"></p>
<blockquote>
<p> 工作原理</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218195031162.png" srcset="/img/loading.gif" lazyload alt="image-20221218195031162"></p>
<p>deque容器的迭代器也是支持随机访问的</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218195159713.png" srcset="/img/loading.gif" lazyload alt="image-20221218195159713"></p>
<h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218201440871.png" srcset="/img/loading.gif" lazyload alt="image-20221218201440871"><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218201533529.png" srcset="/img/loading.gif" lazyload alt="image-20221218201533529"></p>
<h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218201627448.png" srcset="/img/loading.gif" lazyload alt="image-20221218201627448"></p>
<h4 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h4><p>向deque容器中插入和删除元素</p>
<blockquote>
<p>函数原型</p>
</blockquote>
<ul>
<li>两端插入操作<ul>
<li><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202140955.png" srcset="/img/loading.gif" lazyload alt="image-20221218202140955"></li>
</ul>
</li>
<li>指定位置插入<ul>
<li><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202232012.png" srcset="/img/loading.gif" lazyload alt="image-20221218202232012"></li>
</ul>
</li>
</ul>
<h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202831458.png" srcset="/img/loading.gif" lazyload alt="image-20221218202831458"></p>
<h4 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202927241.png" srcset="/img/loading.gif" lazyload alt="image-20221218202927241"></p>
<h3 id="5-stack"><a href="#5-stack" class="headerlink" title="5. stack"></a>5. stack</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>stack是一种先进后出的数据结构，他只有一个出口</p>
<p>栈不允许有遍历行为，但是可以返回他的元素的个数，以及判断它是不是为空</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204259504.png" srcset="/img/loading.gif" lazyload alt="image-20221218204259504"></p>
<h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204422191.png" srcset="/img/loading.gif" lazyload alt="image-20221218204422191"></p>
<h3 id="6-queue"><a href="#6-queue" class="headerlink" title="6. queue"></a>6. queue</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p>queue是一种先进先出的数据结构，他有两个出口</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204719955.png" srcset="/img/loading.gif" lazyload alt="image-20221218204719955"></p>
<h4 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204810209.png" srcset="/img/loading.gif" lazyload alt="image-20221218204810209"></p>
<h3 id="7-list链表"><a href="#7-list链表" class="headerlink" title="7. list链表"></a>7. list链表</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p>功能： 将数据进行链式存储</p>
<p>链表是一种在物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针进行连接实现的</p>
<p>链表的组成：链表由一系列节点组成</p>
<p>结点的组成：一个存储数据元素的数据域，另一个是存储下一个结点地址的指针</p>
<p><strong>STL中的链表是一个双向循环链表</strong></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218214019740.png" srcset="/img/loading.gif" lazyload alt="image-20221218214019740"></p>
<p><strong>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移属于双向迭代器</strong></p>
<blockquote>
<p>list优点</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218214311940.png" srcset="/img/loading.gif" lazyload alt="image-20221218214311940"></p>
<h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p>创建list容器</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218214444063.png" srcset="/img/loading.gif" lazyload alt="image-20221218214444063"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; l1;<br>    l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l2</span><span class="hljs-params">(l1.begin(),l1.end())</span></span>;<br><br>    <span class="hljs-built_in">printlist</span>(l2);<br>    <br>    list&lt;<span class="hljs-type">int</span>&gt; l3 = l1;<br>    <span class="hljs-built_in">printlist</span>(l3);<br><br><span class="hljs-number">30</span><br><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br><span class="hljs-number">30</span><br><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>



<h4 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h4><p>功能：</p>
<p>​    给list容器进行赋值，以及交换list容器</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218215106507.png" srcset="/img/loading.gif" lazyload alt="image-20221218215106507"></p>
<h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218215442302.png" srcset="/img/loading.gif" lazyload alt="image-20221218215442302"></p>
<h4 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218215750154.png" srcset="/img/loading.gif" lazyload alt="image-20221218215750154"></p>
<p><strong>这个里面的pos都是迭代器，不是下标，并且list的迭代器不是随机访问的，只能前移和后移</strong></p>
<h4 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218220225643.png" srcset="/img/loading.gif" lazyload alt="image-20221218220225643"></p>
<h4 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218220529979.png" srcset="/img/loading.gif" lazyload alt="image-20221218220529979"></p>
<p>这个反转和排序都是list的成员函数，不是alogrithm中的sort，那个sort是只支持随机访问的迭代器的</p>
<p>sort默认是进行升序排列，如果想要进行降序排列</p>
<p>可以自定义一个函数，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mycompare</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><br>list&lt;<span class="hljs-type">int</span>&gt; l;<br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>l.<span class="hljs-built_in">sort</span>(mycompare); <span class="hljs-comment">// 20,10,就是他会调用我们这个函数，按照返回ture的规则进行排序，a代表老数据，b代表新数据</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218222821430.png" srcset="/img/loading.gif" lazyload alt="image-20221218222821430"></p>
<p><strong>这个就是双重排序了</strong></p>
<h3 id="8-set-mutiset"><a href="#8-set-mutiset" class="headerlink" title="8. set / mutiset"></a>8. set / mutiset</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>对于set来说，所有的元素在插入的时候会被排序，并且set中不会有重复的元素</li>
</ul>
<blockquote>
<p>set本质</p>
</blockquote>
<ul>
<li>set/mutiset 是属于关联式容器，底层采用的是二叉树结构</li>
</ul>
<p>set和mutiset区别</p>
<ul>
<li>set不允许有重复的元素存在</li>
<li>mutiset允许有重复的元素存在</li>
</ul>
<h4 id="set构造函数和赋值"><a href="#set构造函数和赋值" class="headerlink" title="set构造函数和赋值"></a>set构造函数和赋值</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223330515.png" srcset="/img/loading.gif" lazyload alt="image-20221218223330515"></p>
<h4 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223640356.png" srcset="/img/loading.gif" lazyload alt="image-20221218223640356"></p>
<h4 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除**"></a>set插入和删除**</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223732001.png" srcset="/img/loading.gif" lazyload alt="image-20221218223732001"></p>
<h4 id="set的查找和统计"><a href="#set的查找和统计" class="headerlink" title="set的查找和统计**"></a>set的查找和统计**</h4><p>功能：</p>
<p>​    对set容器进行查找数据和统计数据</p>
<p>函数原型</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223917311.png" srcset="/img/loading.gif" lazyload alt="image-20221218223917311"></p>
<p><strong>这个count因为set中不能存在相同的元素，所以可以使用count进行判断这个元素是否存在在这个set中</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; myset;<br>myset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>mysert.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = myset.<span class="hljs-built_in">find</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 返回这个set中的20对应的这个迭代器</span><br></code></pre></td></tr></table></figure>

<h4 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建**"></a>pair对组创建**</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218224910618.png" srcset="/img/loading.gif" lazyload alt="image-20221218224910618"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>pair&lt;string,<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-number">10</span>);<br><br>cout &lt;&lt; p.first &lt;&lt; p.second&lt;&lt;endl ;<span class="hljs-comment">// k , 20</span><br></code></pre></td></tr></table></figure>



<h4 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h4><p>目标：</p>
<p>​    set排序默认从小到大，掌握如何改变排序规则</p>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则</li>
</ul>
<blockquote>
<p>示例一：排序内置类型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218225819941.png" srcset="/img/loading.gif" lazyload alt="image-20221218225819941"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218225913020.png" srcset="/img/loading.gif" lazyload alt="image-20221218225913020"></p>
<blockquote>
<p>自定义类型排序</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218230102049.png" srcset="/img/loading.gif" lazyload alt="image-20221218230102049"></p>
<h3 id="9-map"><a href="#9-map" class="headerlink" title="9. map"></a>9. map</h3><h2 id="【多线程】"><a href="#【多线程】" class="headerlink" title="【多线程】"></a>【多线程】</h2><p>==<a target="_blank" rel="noopener" href="https://juejin.cn/post/7140448119104143373#heading-22">参考博客</a>==</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7071030029659930632">https://juejin.cn/post/7071030029659930632</a></p>
<h3 id="c-线程同步"><a href="#c-线程同步" class="headerlink" title="c++ 线程同步"></a>c++ 线程同步</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>解决多线程数据混乱的方案就是进行线程同步，最常用的是互斥锁 ，在C++11 中提供了四种互斥锁：</strong></p>
<ol>
<li><code>std::mutex</code> : 独占的互斥锁，不能递归使用；</li>
<li><code>std::timed_mutex:</code> 带超时的独占互斥锁，不能递归使用；</li>
<li><code>std::recursive_mutex:</code> 递归互斥锁，不带超时功能；</li>
<li><code>std::recursive_timed_mutex :</code> 带超时的递归互斥锁；</li>
</ol>
<blockquote>
<p>mutex</p>
</blockquote>
<p>独占互斥锁提供了lock和unlock两个api，用来获得锁和释放锁</p>
<p><strong>使用互斥锁进行线程同步的流程：</strong></p>
<ol>
<li>找到多个线程操作的共享资源<code>（全局变量、堆内存、类成员变量）</code>，成为<strong>临界资源</strong> ；</li>
<li>找到共享资源相关的上下文代码，即<strong>临界区</strong></li>
<li>再临界区的上边调用互斥锁类的 <code>lock()</code> 方法；</li>
<li>再临界区的下边调用互斥锁类的 <code>unlock()</code> 方法；</li>
</ol>
<p>==线程同步的目的：==<code>使多线程按照顺序依次进行执行临界区代码，对共享资源的访问从并行访问变成线性访问，访问效率降低了但是保证了数据的正确性；</code></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/55643e30bcfb4c0381644f697778af3ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" srcset="/img/loading.gif" lazyload alt="互斥锁.png"></p>
<h4 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h4><p><code>lock_guard</code> 是C++11新增的一个模板类，可以==简化互斥锁 <code>lock()</code> 和 <code>unlock()</code> 的写法==，同时也更安全；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span>;<br><span class="hljs-comment">//常用构造</span><br><span class="hljs-function">eplicit <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_type&amp; m)</span></span>;<br></code></pre></td></tr></table></figure>

<p><code>lock_guard</code> 在使用上面的构造函数构造对象时，<strong>会自动锁定互斥量</strong>，且在退出作用域后进行析构就会自动解锁，以保证互斥量的正确性，避免忘记 <code>unlock()</code> 而导致的线程死锁。</p>
<h4 id="条件变量-condition-variable"><a href="#条件变量-condition-variable" class="headerlink" title="条件变量 condition_variable"></a>条件变量 condition_variable</h4><p>C++11 提供了另一种用于等待的同步机制，能阻塞一个或多个线程，直到收到另一个线程发出的通知或超时时，才能唤醒当前阻塞的线程。<strong>条件变量需要和互斥量配合使用。</strong></p>
<p><code>condition_variable:</code> 配合 <code>std::unique_lock&lt;std::mutex&gt;</code> 进行 wait 操作，也就是阻塞线程的操作；</p>
<p><code>conditon_variable_any</code> : 可以和任意带有 <code>lock() 、unlock()</code>语义的 <code>mutex</code> 搭配使用，即存在四种：</p>
<ol>
<li><code>std::mutex :</code> 独占的非递归互斥锁；</li>
<li><code>std::timed_mutex:</code> 带超时的独占非递归锁；</li>
<li><code>std::recursive_mutex:</code> 不带超时功能的递归互斥锁；</li>
<li><code>std::recursive_timed_mutex:</code> 带超时的递归互斥锁；</li>
</ol>
<p><code>conditon_variable</code> 的成员函数主要分为两部分：<code>线程等待(阻塞)函数</code> 和 <code>线程通知(唤醒)函数</code> ，定义在头文件 <code>&lt;condition_variable&gt;</code>中</p>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h5><p>wait方法是，由一个condition_variable变量来调用，其作用是，释放这个线程获取的锁lck.unlock()，然后进入阻塞状态，由别的线程通过相同的cv对象来唤醒自己重新去获取锁和判断条件是否继续阻塞。</p>
<p>当这个wait被唤醒之后，会调用lck.lock()重新上锁，然后wait退出，可以理解为lck的状态变换和wait函数的调用和退出是同时的</p>
<p>wait有两个重载版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当前线程的执行会被阻塞，直到收到 notify 为止。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;<br><br><span class="hljs-comment">// 当前线程仅在pred=false时阻塞；如果pred=true时，不阻塞。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Predicate</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure>

<h5 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Unblocks当前正在等待此条件的一个线程。</span><br><span class="hljs-comment">// 如果没有线程在等待，则函数不执行任何操作。</span><br><span class="hljs-comment">// 如果有多个线程在等待，它不会指定具体哪个线程。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_one</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-comment">// Unblocks当前等待此条件的所有线程。</span><br><span class="hljs-comment">// 如果没有线程在等待，则函数不执行任何操作。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_all</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br></code></pre></td></tr></table></figure>

<p>notify是用来唤醒某个阻塞的线程，没有操作这个锁（没有释放锁这一说）</p>
<h5 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h5><p>我们上面提到很多次虚假唤醒，这里详细解释一下。其实在正常情况下，wait类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，wait类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的wait函数，因为这种(xxx, Predicate pred )类型的函数等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">pred</span>()) <span class="hljs-comment">//while循环，解决了虚假唤醒的问题</span><br>&#123;<br>    <span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假设系统不存在虚假唤醒的时，代码只要像下面这样写就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (不满足条件) &#123;<br>    <span class="hljs-comment">//没有虚假唤醒，wait函数可以一直等待，直到被唤醒或者超时，没有问题。</span><br>    <span class="hljs-comment">//但实际中却存在虚假唤醒，导致假设不成立，wait不会持续等待，会跳出if语句，</span><br>    <span class="hljs-comment">//提前执行其他代码，流程异常</span><br>    <span class="hljs-built_in">wait</span>();  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">但因为存在虚假唤醒，所以，正确的方式应该是使用<span class="hljs-keyword">while</span>语句来解决：<br><br><span class="hljs-keyword">while</span> (!(xxx条件) ) &#123;<br>    <span class="hljs-comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span><br>    <span class="hljs-comment">//否则继续等待，解决虚假唤醒</span><br>    <span class="hljs-built_in">wait</span>();  <br>&#125;<br></code></pre></td></tr></table></figure>















































































<h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h1><h2 id="new-表达式"><a href="#new-表达式" class="headerlink" title="new 表达式"></a>new 表达式</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210113822159.png" srcset="/img/loading.gif" lazyload alt="image-20230210113822159"></p>
<blockquote>
<p>new 表达式原理</p>
<ol>
<li>通过operator new 去malloc空间</li>
<li>使用构造函数在申请的空间上构造对象</li>
</ol>
</blockquote>
<p>底层调用的是operator new ，更底层是调用的malloc，我们再try中可以看到，new一个对象，首先是调用operator new去申请一块内存，然后通过编译器调用类的构造函数去构造这个对象，但是应用程序不能直接通过类调用构造函数，但是可以通过placement new，这个placement new就是在p指向的空间上调用构造函数去构造对象。</p>
<blockquote>
<p>new失败的时候调用的是callnewh(size)，这个函数就是new handler</p>
</blockquote>
<h2 id="delete-表达式"><a href="#delete-表达式" class="headerlink" title="delete 表达式"></a>delete 表达式</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210114710089.png" srcset="/img/loading.gif" lazyload alt="image-20230210114710089"></p>
<blockquote>
<p>delete 表达式</p>
<ol>
<li>先析构对象</li>
<li>再释放空间</li>
</ol>
</blockquote>
<p>底层调用的是operator delete，底层再调用的是free函数，</p>
<p>析构函数可以直接调用，和构造函数不同</p>
<h2 id="构造和析构函数直接调用"><a href="#构造和析构函数直接调用" class="headerlink" title="构造和析构函数直接调用"></a>构造和析构函数直接调用</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210115032146.png" srcset="/img/loading.gif" lazyload alt="image-20230210115032146"></p>
<p>构造函数不可以通过指针直接调用（可以通过placement new），但是析构函数可以通过指针直接调用</p>
<h2 id="array-new，-array-delete"><a href="#array-new，-array-delete" class="headerlink" title="array new， array delete"></a>array new， array delete</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210125754369.png" srcset="/img/loading.gif" lazyload alt="image-20230210125754369"></p>
<p>在分配内存的时候，会给内存的多分配一些内存用来存储这个空间的长度等信息</p>
<p>当我们使用array new时，在释放内存的时候一般都是使用delete[]来释放，这个会逐个来析构每个对象，如果只是delete，那么就只会析构一个对象，并且导致内存泄漏，但是如果析构函数没有意义的话，其实可以不用delete[]</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210130108264.png" srcset="/img/loading.gif" lazyload alt="image-20230210130108264"></p>
<blockquote>
<p>array new时，一般调用的是默认构造函数，这就会导致对象不能够对成员对象赋值操作，所以可以采用placement new 再次调用构造函数来进行成员对象的赋值</p>
</blockquote>
<blockquote>
<p>array size in memory</p>
</blockquote>
<p>使用new 的话就在堆空间中，不使用new 在stack中</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210131136064.png" srcset="/img/loading.gif" lazyload alt="image-20230210131136064"></p>
<p>这个使用delete pi是因为没有析构函数，无关紧要的，直接释放</p>
<p>当如果是object的，就如下</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210131241480.png" srcset="/img/loading.gif" lazyload alt="image-20230210131241480"></p>
<p>在内存中会多记录一个长度的数，并且基本一定要写delete[] p ，但是如果这个demo类中的析构函数无关紧要的，那么就会不记录这个长度数值，因为析构没啥意义，这个长度也是为析构时准备的</p>
<h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><blockquote>
<p>在已经分配的内存上构造对象而已</p>
<p>原理其实也是调用了operator new 只不过调用的是另一个重载的版本，源代码如下</p>
<p>这个operator new(sizeof(Complex),buf){</p>
<p>return buf //直接返回了这个地址，也就是省区了重新malloc的步骤，因为这个重载的版本就是为了能够调用类的构造函数而已</p>
<p>}</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210131900415.png" srcset="/img/loading.gif" lazyload alt="image-20230210131900415"></p>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="c-内存分配的途径"><a href="#c-内存分配的途径" class="headerlink" title="c++内存分配的途径"></a>c++内存分配的途径</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210133553299.png" srcset="/img/loading.gif" lazyload alt="image-20230210133553299"></p>
<p>进行new 的时候，先调用operator new去申请空间，也就是调用malloc申请空间，然后再调用类的构造函数来进行构造对象</p>
<p>释放的时候，就先调用析构函数析构对象，然后调用operator delete去释放空间</p>
<blockquote>
<p>我们可以对这个operator new 和operator delete 进行重载，自己定义如何分配空间和释放空间动作，在stl中有体现</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210133903406.png" srcset="/img/loading.gif" lazyload alt="image-20230210133903406"></p>
<h3 id="重载operator-new-和operator-delete"><a href="#重载operator-new-和operator-delete" class="headerlink" title="重载operator new 和operator delete"></a>重载operator new 和operator delete</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210134015838.png" srcset="/img/loading.gif" lazyload alt="image-20230210134015838"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210134048191.png" srcset="/img/loading.gif" lazyload alt="image-20230210134048191"></p>
<h3 id="重载实例"><a href="#重载实例" class="headerlink" title="重载实例"></a>重载实例</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140311502.png" srcset="/img/loading.gif" lazyload alt="image-20230210140311502"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140351138.png" srcset="/img/loading.gif" lazyload alt="image-20230210140351138"></p>
<h3 id="重载new（）-delete（）"><a href="#重载new（）-delete（）" class="headerlink" title="重载new（）/delete（）"></a>重载new（）/delete（）</h3><blockquote>
<p>new() 其实在我们的讲的那个placement new就是其中的一个，我们也可以进行重载operator new</p>
<p>使用new的时候一定会调用operator new，所以我们还是重载的operator new，</p>
<p>【记住】operator new 的第一个参数一定是object的大小，后面才是具体的参数</p>
</blockquote>
<blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140711652.png" srcset="/img/loading.gif" lazyload alt="image-20230210140711652"></p>
<p>只有在operator new出现异常的时候我们才会调用这个operator delete</p>
</blockquote>
<h3 id="basic-string使用new（extra）扩充申请量"><a href="#basic-string使用new（extra）扩充申请量" class="headerlink" title="basic_string使用new（extra）扩充申请量"></a>basic_string使用new（extra）扩充申请量</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140913511.png" srcset="/img/loading.gif" lazyload alt="image-20230210140913511"></p>
<h2 id="per-class-allocator"><a href="#per-class-allocator" class="headerlink" title="per-class allocator"></a>per-class allocator</h2><blockquote>
<p>总共有三个版本，具体直接看ppt吧，代码很详细，就是每个类一下子多申请一些空间，省去cookie的占用率</p>
</blockquote>
<h2 id="new-handler"><a href="#new-handler" class="headerlink" title="new handler"></a>new handler</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210152056181.png" srcset="/img/loading.gif" lazyload alt="image-20230210152056181"></p>
<blockquote>
<p>当分配内存失败后，我们会先调用一个自己的new_handler()函数，这个函数自己写的</p>
<p>然后就会一致循环的调用malloc和调用new handler（）函数</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210152316273.png" srcset="/img/loading.gif" lazyload alt="image-20230210152316273"></p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="vc6下的malloc内存布局"><a href="#vc6下的malloc内存布局" class="headerlink" title="vc6下的malloc内存布局"></a>vc6下的malloc内存布局</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210153058161.png" srcset="/img/loading.gif" lazyload alt="image-20230210153058161"></p>
<p>两头有着相同的cookie，然后申请的大小必须是16的倍数，pad指向的区间就是保证16的倍数</p>
<h3 id="G2-9分配器"><a href="#G2-9分配器" class="headerlink" title="G2.9分配器"></a>G2.9分配器</h3><h4 id="std-alloc-运行模式"><a href="#std-alloc-运行模式" class="headerlink" title="std::alloc 运行模式"></a>std::alloc 运行模式</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210201021058.png" srcset="/img/loading.gif" lazyload alt="image-20230210201021058"></p>
<blockquote>
<p>std::allocator 是一个内存分配器，它自己维护了一个长度16的链表，这个链表是静态变量，所以头部一直存在，但是指向的真正内存是从堆中申请的，这个分配器在分配内存的时候6也是调用的malloc，只不过他每次申请的内存比较大，然后将多余的内存维护在自己的链表中，然后剩余的内存当下次分配时不用从malloc获取了</p>
</blockquote>
<blockquote>
<p>这个意义在于是消除了cookie，速度对于malloc并没有提升很多</p>
</blockquote>
<h2 id="malloc-和-free"><a href="#malloc-和-free" class="headerlink" title="malloc 和 free"></a>malloc 和 free</h2><h1 id="C-对象"><a href="#C-对象" class="headerlink" title="C++对象"></a>C++对象</h1><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><p>一般建议是采用引用传递，因为引用传递更加的快，建议传参数和返回值使用引用，但是有些情况是不能用引用的，就是在函数内部创建的对象，离开了这个函数之后，这个变量就没了，所以应该进行值传递，不能引用传递。</p>
<h3 id="拷贝构造、拷贝赋值"><a href="#拷贝构造、拷贝赋值" class="headerlink" title="拷贝构造、拷贝赋值"></a>拷贝构造、拷贝赋值</h3><blockquote>
<p>string 内部有一个指针，这个指针指向的内容就是我们的真正的字符串</p>
<p>对于含有指针的类来说，一般要自己定义拷贝构造函数等（<strong>避免出现浅拷贝现象</strong>）</p>
</blockquote>
<blockquote>
<p>三个特殊函数：拷贝构造（进行深拷贝），拷贝赋值（其实就是重载=号），析构函数</p>
<p>temp a =c; 这个其实调用的是拷贝构造</p>
<p>temp a;</p>
<p>a =c;这个才调用的是拷贝赋值</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211204314635.png" srcset="/img/loading.gif" lazyload alt="image-20230211204314635"></p>
<blockquote>
<p>深拷贝和浅拷贝区别就是一个拷贝的是整个对象的内容，一个只是拷贝了指针而已</p>
</blockquote>
<p>比如有一个类，他有一个指针成员变量，现在有一个对象，这个对象的指针指向了一块内存，然后调用拷贝构造去创建一个新的对象，如果我们没有自己定义自己的拷贝构造函数，那么就会由编译器给我们提供一个默认的拷贝构造函数，但是这个拷贝构造函数仅仅是将旧对象的值赋值给了新对象的值，结果就是新对象的这个指针现在和旧对象的指针内容一样（也就是指向了同一块内存）那么这个就是浅拷贝，当其中一个对象的指针去改变指针指向的内容时，就会影响两个对象，所以我们应该是写自己的拷贝构造函数，进行深拷贝，也就是重新申请一块空间，将旧对象指针指向的内容给拷贝到新申请的空间中去，然后将新对象的指针指向这个空间，这个就是深拷贝。</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211210029676.png" srcset="/img/loading.gif" lazyload alt="image-20230211210029676"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211210122874.png" srcset="/img/loading.gif" lazyload alt="image-20230211210122874"></p>
<blockquote>
<p>拷贝赋值</p>
</blockquote>
<p> 基本步骤就是：要有自我检测，因为没有自我检查，会改变这个内存的位置，然后清空自己之前的内容和内存，然后重新申请一块和要赋值的内容的大小空间，然后再赋值到新空间去</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211210522829.png" srcset="/img/loading.gif" lazyload alt="image-20230211210522829"></p>
<blockquote>
<p>析构函数</p>
</blockquote>
<p>对于含有指针成员的对象，一定要定义析构函数，因为要析构掉指针指向的内容</p>
<h2 id="new-和delete搭配"><a href="#new-和delete搭配" class="headerlink" title="new 和delete搭配"></a>new 和delete搭配</h2><p>new 会被编译器编译成operator new（）–这个是去申请空间的，然后再调用构造函数在申请的空间上进行构造对象</p>
<p>delete会被编译器编译成先调用析构函数，然后再调用operator delete 去释放内存</p>
<p>使用new 的时候要搭配delete使用，防止内存泄漏</p>
<p>new[] 也要搭配delete[] 使用，如果使用delete，就会只会释放一个对象内存，并且对于含有指针成员的对象，会导致内存泄漏，泄漏的是指针指向的内容，不是对象自己。</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态函数和静态成员，都是只有一份的，如果在一个类中定义一个静态函数，那么这个函数就不会包含这个this指针，所以他只能调用这个类的静态成员变量，无法像普通的函数那样，当调用自己的成员函数的时候，就会将自己的this指针传进去，这样就可以使用自己的成员对象。</p>
<h2 id="static版本的单例"><a href="#static版本的单例" class="headerlink" title="static版本的单例"></a>static版本的单例</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211225601849.png" srcset="/img/loading.gif" lazyload alt="image-20230211225601849"></p>
<h2 id="继承、虚函数、多态"><a href="#继承、虚函数、多态" class="headerlink" title="继承、虚函数、多态"></a>继承、虚函数、多态</h2><p><strong>base class 的dtor必须是virtual，否则会出现undefined behavior</strong></p>
<p>在继承中，成员变量可以被继承下来，成员函数也可以被继承下来，但是从内存的角度来说，应该是继承的函数的调用权</p>
<blockquote>
<p>虚函数</p>
</blockquote>
<ul>
<li>non-virtual ： 你不希望derived class（派生类）去重新定义（override，覆写重写）它</li>
<li>virtual函数： 你希望derived class 重新定义（override）它，而且你对这个函数有了一个默认的定义了</li>
<li>pure virtual 函数 ： 你希望你的子类<strong>一定要重新定义它</strong>，因为你对这个函数没有任何定义</li>
</ul>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230212152602042.png" srcset="/img/loading.gif" lazyload alt="image-20230212152602042"></p>
<blockquote>
<p>虚函数本质</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/format,png.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><blockquote>
<p>为什么要有智能指针</p>
</blockquote>
<p>我们在动态分配内存时候，有时候忘记释放内存，导致内存泄漏，还有就是我们提前释放了内存，导致指针指向非法内存</p>
<p>为了更容易的使用动态内存，出现了智能指针来管理动态对象</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/p/4777312.html"><strong>参考博客–智能指针shared_ptr的原理实现</strong></a></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230213135345916.png" srcset="/img/loading.gif" lazyload alt="image-20230213135345916"></p>
<blockquote>
<p>允许多个指针指向同一个对象；</p>
</blockquote>
<p><strong>智能指针都共享一个计数器（也就是shared_ptr包含一个计数器的指针），和一个指向对象的指针</strong></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb5a2m5Lmg55qE5bCR5bm0,size_20,color_FFFFFF,t_70,g_se,x_16.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr拥有它指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个对象</p>
<blockquote>
<p>unique_ptr没有拷贝构造和拷贝赋值，但是它可以调用release()和reset将指针的控制权从一个unique_ptr转给另一个unique_ptr</p>
</blockquote>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/QG-whz/p/4909359.html"><strong>参考博客–对象内存布局</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1755489"><strong>clang编译器下的对象模型</strong></a></p>
<h3 id="c-对象模型"><a href="#c-对象模型" class="headerlink" title="c++对象模型"></a>c++对象模型</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMTA4ODk=,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMTA4ODk=,size_16,color_FFFFFF,t_70-16765569750365.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNTAwNTk1MzAzMQ==,size_16,color_FFFFFF,t_70.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025195611333-359739251.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>在此模型下，nonstaic数据成员被置于每一个类对象中，而static数据成员被至于类对象之外</li>
<li>static和nonstatic的函数也是置于对象之外，而对于virtual函数，则是通过虚函数表+虚函数指针来支持</li>
<li>每一个带有虚函数的类，都会生成一个表格，叫做虚表。<strong>虚表中存放着一堆指针，这些指针指向该类每一个虚函数。</strong>虚表中的函数地址将按声明时的顺序排列，不过当子类有多个重载函数时例外，后面会讨论。</li>
<li>每个类对象都有一个虚表指针（vtpr），由编译器生成，虚表指针的设定与重置皆由类的复制控制（即时构造函数，析构函数，赋值操作符）来完成。vptr的位置为编译器决定，传统上它被放在所有显示声明的成员之后，<strong>不过现在许多编译器把vptr放在一个类对象的最前端。</strong>关于数据成员布局的内容，在后面会详细分析。</li>
</ul>
<p><strong>另外，虚函数表的前面设置了一个指向type_info的指针，用以支持RTTI（Run Time Type Identification，运行时类型识别）。RTTI是为多态而生成的信息，包括对象继承关系，对象本身的描述等，只有具有虚函数的对象在会生成。</strong></p>
<h3 id="单继承下的对象模型"><a href="#单继承下的对象模型" class="headerlink" title="单继承下的对象模型"></a>单继承下的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> d) :<span class="hljs-built_in">Base</span>(<span class="hljs-number">1000</span>),      <span class="hljs-built_in">DeriveI</span>(d)&#123;&#125;;<br>    <span class="hljs-comment">//overwrite父类虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive::Drive_print()&quot;</span> ; &#125;<br>    <span class="hljs-comment">// Derive声明的新的虚函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Drive_print</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive::Drive_print()&quot;</span> ; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Derive</span>()&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> DeriveI;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230217171455506.png" srcset="/img/loading.gif" lazyload alt="image-20230217171455506" style="zoom:50%;">



<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200700974-1784981192.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在C++对象模型中，对于一般继承（这个一般是相对于虚拟继承而言），</p>
<p>若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数(<strong>注意子类与父类拥有各自的一个虚函数表</strong>)；</p>
<p>若子类并无overwrite父类虚函数，而是声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后（在vs中无法通过监视看到扩充的结果，不过我们通过取地址的方法可以做到，子类新的虚函数确实在父类子物体的虚函数表末端）。</p>
<p>而对于虚继承，若子类overwrite父类虚函数，同样地将覆盖父类子物体中的虚函数表对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr，这与一般继承不同,在后面再讨论。</p>
<h3 id="多继承下的对象模型"><a href="#多继承下的对象模型" class="headerlink" title="多继承下的对象模型"></a>多继承下的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">baseI</span>(i)&#123;&#125;;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> baseI; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">countI</span><span class="hljs-params">()</span></span>&#123;&#125;;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::print()&quot;</span>; &#125;<br> <br><span class="hljs-keyword">private</span>:<br> <br>    <span class="hljs-type">int</span> baseI;<br> <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> baseS;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base_2</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">base2I</span>(i)&#123;&#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base_2</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> base2I; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">countI</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base_2::print()&quot;</span>; &#125;<br> <br><span class="hljs-keyword">private</span>:<br> <br>    <span class="hljs-type">int</span> base2I;<br> <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> base2S;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive_multyBase</span> :<span class="hljs-keyword">public</span> Base, <span class="hljs-keyword">public</span> Base_2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Drive_multyBase</span>(<span class="hljs-type">int</span> d) :<span class="hljs-built_in">Base</span>(<span class="hljs-number">1000</span>), <span class="hljs-built_in">Base_2</span>(<span class="hljs-number">2000</span>) ,<span class="hljs-built_in">Drive_multyBaseI</span>(d)&#123;&#125;;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive_multyBase::print&quot;</span> ; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Drive_print</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive_multyBase::Drive_print&quot;</span> ; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Drive_multyBaseI;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200614927-1378567718.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200604380-2000558778.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>单继承中（一般继承），子类会扩展父类的虚函数表。在多继承中，子类含有多个父类的子对象，该往哪个父类的虚函数表扩展呢？当子类overwrite了父类的函数，需要覆盖多个父类的虚函数表吗？</p>
<ul>
<li>子类的虚函数被放在声明的第一个基类的虚函数表中。</li>
<li><strong>overwrite时，所有基类的print()函数都被子类的print()函数覆盖</strong>。（这里是有两个虚函数表吗？）</li>
<li>内存布局中，父类按照其声明顺序排列。</li>
</ul>
<p>其中第二点保证了父类指针指向子类对象时，总是能够调用到真正的函数。</p>
<p><strong>子类继承了两个父类，会把父类的两个虚函数表都复制过来，重写会覆盖所有同时出现在两个父类中的函数，如果自己有新的虚函数，会在第一个父类复制过来的虚函数表中扩加。</strong>，子类中的成员变量的布局也是根据继承时声明的顺序来的。</p>
<h3 id="菱形继承下的对象模型"><a href="#菱形继承下的对象模型" class="headerlink" title="菱形继承下的对象模型"></a>菱形继承下的对象模型</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200532099-858573066.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> ib;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>) :<span class="hljs-built_in">ib</span>(i)&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Bf</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::Bf()&quot;</span> &lt;&lt; endl; &#125;<br> <br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span> : <span class="hljs-keyword">public</span> B<br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> ib1;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">B1</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">100</span> ) :<span class="hljs-built_in">ib1</span>(i) &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B1::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B1::f1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Bf1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B1::Bf1()&quot;</span> &lt;&lt; endl; &#125;<br> <br> <br> <br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span> : <span class="hljs-keyword">public</span> B<br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> ib2;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">B2</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1000</span>) :<span class="hljs-built_in">ib2</span>(i) &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B2::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B2::f2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Bf2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B2::Bf2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>&#125;;<br> <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B1, <span class="hljs-keyword">public</span> B2<br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> id;<br> <br> <br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">10000</span>) :<span class="hljs-built_in">id</span>(i)&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::f1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::f2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Df</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::Df()&quot;</span> &lt;&lt; endl; &#125;<br> <br>&#125;;<br><br></code></pre></td></tr></table></figure>



<p>这时，根据单继承，我们可以分析出B1，B2类继承于B类时的内存布局。又根据一般多继承，我们可以分析出D类的内存布局。我们可以得出D类子对象的内存布局如下图：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200514692-1054547262.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>D类对象内存布局中，图中青色表示b1类子对象实例，黄色表示b2类子对象实例，灰色表示D类子对象实例。从图中可以看到，由于D类间接继承了B类两次，导致D类对象中含有两个B类的数据成员ib，一个属于来源B1类，一个来源B2类。这样不仅增大了空间，更重要的是引起了程序歧义：</p>
<blockquote>
<p>问题描述：我们其实可以看作是一个多继承，因为对于D来说就是多继承，但是因为B1和B2都是继承的B，所以导致了D中有两个成员变量B::ib,这就会导致重复继承，在调用的时候出现歧义</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">D d;<br> <br>d.ib =<span class="hljs-number">1</span> ;               <span class="hljs-comment">//二义性错误,调用的是B1的ib还是B2的ib？</span><br> <br>d.B1::ib = <span class="hljs-number">1</span>;           <span class="hljs-comment">//正确</span><br> <br>d.B2::ib = <span class="hljs-number">1</span>;           <span class="hljs-comment">//正确</span><br><br></code></pre></td></tr></table></figure>

<p><strong>尽管我们可以通过明确指明调用路径以消除二义性</strong>，但二义性的潜在性还没有消除，我们可以通过虚继承来使D类只拥有一个ib实体。</p>
<p>我们会用虚继承来解决这个问题</p>
<h3 id="虚继承下的对象模型"><a href="#虚继承下的对象模型" class="headerlink" title="虚继承下的对象模型"></a>虚继承下的对象模型</h3><h4 id="虚继承作用"><a href="#虚继承作用" class="headerlink" title="虚继承作用"></a>虚继承作用</h4><p>虚继承解决了菱形继承中最派生类拥有多个间接父类实例的情况。虚继承的派生类的内存布局与普通继承很多不同，主要体现在：</p>
<ul>
<li><strong>虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面。</strong><ul>
<li><strong>vs非虚继承：直接扩展父类虚函数表。</strong></li>
</ul>
</li>
<li><strong>虚继承的子类也单独保留了父类的vprt与虚函数表。这部分内容接与子类内容以一个四字节的0来分界。</strong></li>
<li>虚继承的子类对象中，含有四字节的虚表指针偏移值。</li>
</ul>
<p>为了分析最后的菱形继承，我们还是先从单虚继承继承开始。</p>
<h4 id="虚基类表解析"><a href="#虚基类表解析" class="headerlink" title="虚基类表解析"></a>虚基类表解析</h4><p>在C++对象模型中，虚继承而来的子类会生成一个隐藏的虚基类指针（vbptr），在Microsoft Visual C++中，<strong>虚基类表指针总是在虚函数表指针之后</strong>，因而，对某个类实例来说，如果它有虚基类指针，那么虚基类指针可能在实例的0字节偏移处（该类没有vptr时，vbptr就处于类实例内存布局的最前面，否则vptr处于类实例内存布局的最前面），也可能在类实例的4字节偏移处。<br>一个类的虚基类指针指向的虚基类表，与虚函数表一样，虚基类表也由多个条目组成，条目中存放的是<strong>偏移值</strong>。第一个条目存放虚基类表指针（vbptr）所在地址到该类内存首地址的偏移值，由第一段的分析我们知道，这个偏移值为0（类没有vptr）或者-4（类有虚函数，此时有vptr）。我们通过一张图来更好地理解。</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200459817-94705070.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200451380-675544058.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>虚基类表的第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值，这点我们在下面会验证。</p>
<h4 id="简单虚继承"><a href="#简单虚继承" class="headerlink" title="简单虚继承"></a>简单虚继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的内容与前面相同</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> B<br><br><br></code></pre></td></tr></table></figure>

<img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230217215955888.png" srcset="/img/loading.gif" lazyload alt="image-20230217215955888" style="zoom:50%;">



<p>根据我们前面对虚继承的派生类的内存布局的分析，B1类的对象模型应该是这样的：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200421083-639353686.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值。</p>
</blockquote>
<p><strong>在我们的例子中，也就是B类实例内存地址相对于vbptr的偏移值，也即是：[4]-[1]的偏移值，结果即为12，从地址上也可以计算出来：007CFDFC-007CFDF4结果的十进制数正是12。现在，我们对虚基类表的构成应该有了一个更好的理解。</strong></p>
<h4 id="虚拟菱形继承"><a href="#虚拟菱形继承" class="headerlink" title="虚拟菱形继承"></a>虚拟菱形继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span>  B&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span>  B&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B1,<span class="hljs-keyword">public</span> B2&#123;...&#125; <span class="hljs-comment">// 这个就是普通的多继承 </span><br><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200354427-697488742.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>菱形虚拟继承下，最派生类D类的对象模型又有不同的构成了。在D类对象的内存构成上，有以下几点：</p>
<ul>
<li>在D类对象内存中，基类出现的顺序是：先是B1（最左父类），然后是B2（次左父类），最后是B（虚祖父类）</li>
<li>D类对象的数据成员id放在B类前面，两部分数据依旧以0来分隔。</li>
<li>编译器没有为D类生成一个它自己的vptr，而是覆盖并扩展了最左父类的虚基类表，与简单继承的对象模型相同。</li>
<li>超类B的内容放到了D类对象内存布局的最后。</li>
</ul>
<p>菱形虚拟继承下的C++对象模型为：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200237724-1193009551.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200219192-322378663.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h3 id="继承中构造和析构调用顺序"><a href="#继承中构造和析构调用顺序" class="headerlink" title="继承中构造和析构调用顺序"></a>继承中构造和析构调用顺序</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7b8a3c3bbe924eacafb8ab424ecc68fe.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h1 id="C-effective"><a href="#C-effective" class="headerlink" title="C++ effective"></a>C++ effective</h1><h2 id="04-确定对象被使用前已经被初始化"><a href="#04-确定对象被使用前已经被初始化" class="headerlink" title="04. 确定对象被使用前已经被初始化"></a>04. 确定对象被使用前已经被初始化</h2><ul>
<li>为内置对象进行手工初始化（int,long,char..）</li>
<li>构造函数做好使用成员初值列，而不要在构造函数本体内使用赋值操作。初始化的顺序是根据你在类中的声明顺序，而不是你成员初值列的初始化顺序，尽量抱持一致。<ul>
<li>如果是在构造函数内的赋值相当于先调用default 构造函数，再对对象进行赋值</li>
<li>而使用成员初值列则是直接采用copy构造函数进行初始化，效率更高</li>
</ul>
</li>
<li>为免除”跨编译单元之初始化次序“，请以localstatic对象替换non-local static对象，因为定义在函数内的local static对象，在调用函数的时候，一定回发生初始化。</li>
</ul>
<h2 id="05-了解c-默默编写并调用了哪些函数"><a href="#05-了解c-默默编写并调用了哪些函数" class="headerlink" title="05. 了解c++默默编写并调用了哪些函数"></a>05. 了解c++默默编写并调用了哪些函数</h2><p>几乎你写的每一个class都会有一个或者多个构造函数、一个析构函数、一个copy assignment操作符。</p>
<p>如果你定义了一个空类，里面什么都没有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>那么在编译期间，编译器会给你默认的生成一个copy构造函数、一个copy assignment操作符、一个析构函数、一个default 构造函数,<strong>这些函数都是public 和inline的</strong>。</p>
<p>就相当于下面：<strong>但是只有在这些函数被调用的时候才会被创建出来</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Empty</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp; temp)&#123;&#125;;<br>    ~<span class="hljs-built_in">Empty</span>()&#123;&#125;;<br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp; temp)&#123;&#125;;<br>&#125; /<br></code></pre></td></tr></table></figure>

<blockquote>
<p>有的时候编译器会拒绝编译一些operator=，比如一个类中的成员是一个引用和const常量，当发生copy assignment时，相当于将引用的指向更改，这是不允许的，并且const常量也不允许更改，所以这个时候不能生成这个operator=，但是可以生产copy构造函数，因为copy构造函数只在初始化被调用，引用和常量都可以在初始化赋值</p>
</blockquote>
<h2 id="07-为多态基类声明virtual析构函数"><a href="#07-为多态基类声明virtual析构函数" class="headerlink" title="07. 为多态基类声明virtual析构函数"></a>07. 为多态基类声明virtual析构函数</h2><p>首先我们要清楚子类继承父类的时候，当创建子类对象的时候，构造函数顺序和析构函数顺序</p>
<p>对于构造函数，先调用父类的构造函数，在调用子类的构造函数内容，</p>
<p>对于析构函数，先调用子类的析构函数，然后调用父类的析构函数</p>
<blockquote>
<p>如果没有在子类中定义自己的copy 构造，那么会生成一个调用父类拷贝构造函数的自己的拷贝构造函数。（无论父类的构造函数是自己定义的还是由编译器生成的，只要子类没有定义，就会在编译器合成时调用它）</p>
<p><strong>如果自己在子类中定义了自己的拷贝构造函数，那么在进行调用子类的copy构造函数时会调用父类的默认构造函数。都是调用默认构造函数</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">person</span>()&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;调用了person()&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt;endl;;<br>    &#125;<br>     ~<span class="hljs-built_in">person</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了~person----&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ming</span>: <span class="hljs-keyword">public</span> person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ming</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了ming()&quot;</span> &lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">ming</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了~ming&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ming* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ming</span>();<span class="hljs-comment">//只有将析构函数声明为virtual的，才能通过父类的指针调用子类的析构函数（就是将虚函数表的父类虚析构函数给覆盖了），实现全部析构（子类的析构函数无论如何都会调用父类的析构函数的）</span><br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">调用了<span class="hljs-built_in">person</span>()<br>调用了<span class="hljs-built_in">ming</span>()<br>调用了~ming<br>调用了~person----<br></code></pre></td></tr></table></figure>

<p>这个在子类的构造函数和析构函数中，编译器都会生成父类的构造函数和析构函数，无论析构函数是不是virtual类型的。</p>
<blockquote>
<p><strong>将父类的析构函数声明为virtual类型的作用：通过父类指针析构掉子类对象</strong></p>
</blockquote>
<p>例如我们使用父类的指针指向了子类的对象，但是在析构的时候，我们只会通过父类指针调用到父类的析构函数，而无法调用子类的析构函数（子类的析构函数自己拥有，所以无法通过父类的指针找到），这样就导致”局部销毁“的现象，就是将父类的内容给析构掉了，但是子类自己的内容没有析构掉。</p>
<p>如果我们将父类的析构函数定义为virtual就会生成一个虚函数表，子类的析构函数就会覆盖虚函数表中的父类的虚析构函数，这样当父类指针指向之类对象时，因为会通过vptr找到虚函数表，然后找到子类的析构函数，这样就完成了对子类对象的析构（子类的析构函数里调用了父类的析构函数）。</p>
<h2 id="09-不要在析构函数和构造函数中调用虚函数"><a href="#09-不要在析构函数和构造函数中调用虚函数" class="headerlink" title="09. 不要在析构函数和构造函数中调用虚函数"></a>09. 不要在析构函数和构造函数中调用虚函数</h2><p>因为在继承关系中，当我们构造子类对象时，我们调用的时父类构造再子类构造，如果在父类构造函数中调用了虚函数，那么此时调用的函数是属于父类的，而不是属于子类的，因为子类还没有构建呢，当调用父类构造时此时其实是一个父类对象，只有在后面调用了子类构造时才会转变成子类对象。</p>
<h2 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13. 以对象管理资源"></a>13. 以对象管理资源</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f1</span>()&#123;<br>    Person * p =<span class="hljs-built_in">PersonFactory</span>(); <span class="hljs-comment">// 通过工厂模式获得一个对象</span><br>   ......<span class="hljs-comment">//中间经过了一些步骤，有可能直接return或者异常离开了这个函数</span><br>   <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 就无法执行这个语句，导致内存泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>解决方法：以对象管理资源</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f1</span>()&#123;<br>    shared_ptr&lt;person&gt; p =<span class="hljs-built_in">PersonFactory</span>(); <span class="hljs-comment">// 通过工厂模式获得一个对象</span><br>   ......<span class="hljs-comment">//中间经过了一些步骤，有可能直接return或者异常离开了这个函数</span><br>&#125;<br><span class="hljs-comment">// 当离开这个函数的时候，智能指针p会在自己的析构函数内调用delete去释放创建的person对象</span><br><span class="hljs-comment">// 以shared_ptr 这个对象来管理资源</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：但是shared_ptr只能调用delete，不能调用delete[],所以不要用智能指针管理数组</p>
</blockquote>
<blockquote>
<p>总结：为防止内存泄漏，请使用RAII对象，他们在构造函数中获取资源，并在析构函数中释放资源</p>
</blockquote>
<h2 id="16-成对使用new和delete时采用相同形式"><a href="#16-成对使用new和delete时采用相同形式" class="headerlink" title="16. 成对使用new和delete时采用相同形式"></a>16. 成对使用new和delete时采用相同形式</h2><p>如果在new中使用了[]，那么在相应的delete表达式中也是用[]，如果你没有new数组，就不要delete数组</p>
<p>因为在delete的时候，会先拿到数组头部的数组长度N，然后根据这个n进行逐个析构，如果你对单一对象使用delete[]，那么就有可能发生额外的析构。</p>
<h2 id="17-以独立语句将newed对象置入智能指针"><a href="#17-以独立语句将newed对象置入智能指针" class="headerlink" title="17. 以独立语句将newed对象置入智能指针"></a>17. 以独立语句将newed对象置入智能指针</h2><p><strong>这是为了防止内存泄漏，虽然我们使用RAII就是为了防止泄漏，但是由于一些原因，我们还是会导致内存泄漏，所以说不是使用了智能指针就一定不会发生泄漏</strong></p>
<p>比如在一个函数的参数是，</p>
<p>void processWidget(std::tr1::shared_ptr<Widget> pw,int priority);</Widget></p>
<p>当我们这样使用时</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">procesWidget</span>(std::tr1:<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>()),<span class="hljs-built_in">priority</span>());<br>在调用这个方法之前，编译器会创建代码，做以下三件事：<br>    调用priority<br>    执行<span class="hljs-keyword">new</span><br>    调用智能指针的构造函数<br>那么<span class="hljs-keyword">new</span>和构造函数的调用顺序肯定抱持一前一后，但是priority有可能在<span class="hljs-keyword">new</span>执行之后执行，如果发生意外，就会导致内存泄漏，因为还没有将创建的对象指针赋予智能指针<br><br></code></pre></td></tr></table></figure>



<h2 id="20-宁以pass-py-reference-to-const-替换pass-by-value"><a href="#20-宁以pass-py-reference-to-const-替换pass-by-value" class="headerlink" title="20. 宁以pass-py-reference-to-const 替换pass-by-value"></a>20. 宁以pass-py-reference-to-const 替换pass-by-value</h2><p><strong>除非你另外指定，函数的参数都是以实际实参的复件为初值，而调用端所获得的也是函数返回值的一个复件。这些复件都是由对象的copy构造函数产出的，这可能使得pass-by-value称为费时的操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-built_in">person</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">person</span>();<br><span class="hljs-keyword">private</span>:<br>    string name;<br>    string address;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> : <span class="hljs-keyword">public</span> person&#123;<br> <span class="hljs-keyword">private</span>:<br>    string schoolname;<br>    string schooladdress;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalidate</span><span class="hljs-params">(student s)</span></span>;<br>student s;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">isvalidate</span>(s);<br></code></pre></td></tr></table></figure>

<p>当调用函数时，会发生什么事情，我们可以看到这个是值传递，所以相当于调用了子类的copy构造函数，那么就会先调用父类的copy构造函数（如果子类定义了自己的copy构造，则默认调用父类的无参构造），再调用子类的copy构造函数（因为函数参数的student，如果是perosn不调用），然后再调用内部的成员的构造函数，析构函数也是一样。</p>
<blockquote>
<p>总结：尽量使用pass-by-reference-to-const，高效，且不会发生切割问题</p>
<p>但是对于内置类型和STL的迭代器以及函数对象是采用值传递的。</p>
</blockquote>
<h2 id="21-必须返回对象时，别返回引用"><a href="#21-必须返回对象时，别返回引用" class="headerlink" title="21. 必须返回对象时，别返回引用"></a>21. 必须返回对象时，别返回引用</h2><p>因为一个local 变量在出了作用域之后会被销毁，那么此时引用就会指向非法地址</p>
<blockquote>
<p>总结：绝不要返回一个引用指向一个local stack 对象，可以返回一个指向heap的对象，或者指向一个local static对象</p>
</blockquote>
<h2 id="22-将成员变量设置为private"><a href="#22-将成员变量设置为private" class="headerlink" title="22. 将成员变量设置为private"></a>22. 将成员变量设置为private</h2><p>减少由于成员变量更改而导致的代码破坏量，比如一个public的变量名字修改了，那么很多使用这个变量的代码都要修改，因此使用封装最好（private，提供setter和getter）</p>
<h2 id="27-尽量少做转型"><a href="#27-尽量少做转型" class="headerlink" title="27. 尽量少做转型"></a>27. 尽量少做转型</h2><h3 id="c-新特性–-四种转型"><a href="#c-新特性–-四种转型" class="headerlink" title="c++新特性– 四种转型"></a>c++新特性– 四种转型</h3><p>const_cast<T>(expression)</T></p>
<p>dynamic_cast<T>(expression)</T></p>
<p>static_cast<T>(expression)</T></p>
<p>reinterpret_cast<T>(expression)</T></p>
<blockquote>
<p>基本概念：</p>
</blockquote>
<ul>
<li><p>const_cast<T>(expression):它是将cont类型转换成non-const类型</T></p>
</li>
<li><p>dynamic_cast<T>(expression)：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属于继承体系中的某个类型。成本较高</T></p>
<p> 只能用于含有虚函数的类转换，用于类向上和向下转换</p>
<p>​      <strong>向上转换：</strong>指子类向基类转换。  </p>
<p>​      <strong>向下转换：</strong>指基类向子类转换。</p>
<p>​      这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。</p>
<p>  dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</p>
</li>
<li><p>reinterpret_cast<T>(expression)：  reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。</T></p>
</li>
<li><p>static_cast<T>(expression): 最常用的转型方式，它可以用于任何的隐式转换，比如non-const转成const（不能反过来，只有const_cast有那个功能），也可以用于向上转换，但是向下转换不安全</T></p>
</li>
</ul>
<h1 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h1><p>参考博客： <a target="_blank" rel="noopener" href="https://www.cnblogs.com/skynet/p/3343726.html">https://www.cnblogs.com/skynet/p/3343726.html</a></p>
<h2 id="需要多少内存才能够表现一个object"><a href="#需要多少内存才能够表现一个object" class="headerlink" title="需要多少内存才能够表现一个object"></a>需要多少内存才能够表现一个object</h2><p>一般而言：</p>
<ul>
<li><p>其nonstatic data members</p>
</li>
<li><p>加上任何由于alignment（译注）的需求而填补（padding）上去的空间（可能存在members之间，也可能存在集合体边界）</p>
<blockquote>
<p>译注：alignment就是将数值调整到某数的倍数。在32位计算机上，通常alignment为4字节，以使bus的“运输量”达到最高效率</p>
</blockquote>
</li>
<li><p>加上为了支持virtual而由内部产生的任何额外负担</p>
</li>
</ul>
<blockquote>
<p>关于多态下的父类指针指向子类对象，以及将子类对象赋值给父类发生什么事情</p>
</blockquote>
<ul>
<li>通过父类的指针指向子类的对象，就可以实现多态的现象，但是父类的指针只能调用子类public继承的父类的内容，关于子类自己独有的member，无法使用父类的指针调用，我们可以将这个指针转换成子类的指针，就可以调用了</li>
<li>如果将子类的对象赋值给一个父类对象，就会出现“切割问题”，也就是子类会被切割塞入到较小的父类的base type内存中，对于派生类没有留下任何一个东西。（<strong>虚函数表依然是父类自己的虚函数表</strong>），因此这个多态也就没有了。</li>
</ul>
<h2 id="Default-Constructor的生成的四种情况"><a href="#Default-Constructor的生成的四种情况" class="headerlink" title="Default Constructor的生成的四种情况"></a>Default Constructor的生成的四种情况</h2><blockquote>
<p>如果一个类定义了其中一个构造函数，那么编译器就不会帮你构建任何一个构造函数了，所以如果子类</p>
</blockquote>
<p>【参考博客】<a target="_blank" rel="noopener" href="https://imzlp.com/posts/7666/">https://imzlp.com/posts/7666/</a></p>
<p>什么时候才会合成一个default constructor呢？当编译器需要它的时候才会合成构造函数</p>
<p>1.“带有Default Constructor”的Member Class Object（<strong>如果这个成员对象没有默认构造函数，也不会合成</strong>）</p>
<blockquote>
<p>结论： 如果一个class<strong>没有任何constructor</strong>,但是它包含一个member object，<strong>并且</strong>后者有default constructor，编译器才会给这个class合成一个构造函数，并且这个构造函数只有在调用的时候才会合成</p>
</blockquote>
<blockquote>
<p>如果我们定义了构造函数，但是内部有很多的member object ，那么这个class就会在自己的每一个constructor内调用每一个member object 的default constructor来初始化这个object</p>
<p>这个就是编译器的扩张。</p>
</blockquote>
<p>2.“带有Default Constructor”的Base class</p>
<p>如果一个类派生自一个带有默认构造函数的base class，然后自己没有任何一个构造函数，那么编译器就会给这个class生成一个默认构造函数，</p>
<p><strong>如果这个派生类有自己的构造函数，那么编译器就会扩张这个构造函数，调用父类的默认构造函数（父类的默认构造函数也有可能是编译器生成 的）</strong></p>
<p>3.“带有一个virtual function”的class</p>
<p>有两个扩张行为会在编译期间发生：</p>
<ol>
<li>一个 virtual function table (虚函数表) 会被编译器生成出来，内放 Class 的 virtual function 的地址 (函数指针的地址)</li>
<li>每一个 Class Object 中有一个额外的 Pointer Member (也就是 vptr) 会被编译器生成出来，内放指向下虚函数表的指针。</li>
</ol>
<p>对象 b 中包含了</p>
<ul>
<li><p>一个 Base 的完整对象：数据成员 x 和 Base 的 virtual function table，其中具有一个指向 Derived::func () 的指针</p>
</li>
<li><p>一个在 b 中定义的 Data Member (数据成员) z。</p>
</li>
</ul>
<p>假如我们使用 b 对象来调用 func：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">b.func()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>1.则该代码可以正确执行的前提是，<strong>编译器必须为对象 b 的 vptr 设定初始值</strong>，放置适当的 virtual Table 地址，<strong>对于类所定义的每一个的构造函数，编译器都会安插一些必要的代码来实现这个行为</strong>。</p>
<p>2.对于那些没有声明任何构造函数的类，编译器会为他们合成一个默认构造函数，以便正确的初始化每一个类对象的 vptr。</p>
<p>4.“带有一个virtual Base Class”的class</p>
<p>因为牵扯到这个菱形继承的问题，要有一个指针指向这个Base，所以子类在构造函数中要扩张构建这个变量。</p>
<p>有构造函数就扩展，没有就合成。</p>
<blockquote>
<p>总结：如果没有上面四种情况，就不会给他合成一个默认的构造函数</p>
<p>在合成的默认构造函数中，只有base class subobjects和member class会被初始化，而其他的nonstatic data member（整数、整数指针、整数数组等），因为这些初始化是对程序员需要的，而对于编译器不需要。</p>
</blockquote>
<p>所以：不是所有类都会生成默认构造函数，编译器合成的默认构造函数也不是会对class中的每一个成员初始化。</p>
<h2 id="Copy-Constructor的构造操作"><a href="#Copy-Constructor的构造操作" class="headerlink" title="Copy Constructor的构造操作"></a>Copy Constructor的构造操作</h2><p>copy构造函数即使显示定义了default 构造函数也会被编译器合成（在需要的时候）</p>
<blockquote>
<p>Bitwise Copy Semantics 位逐次拷贝</p>
</blockquote>
<p>如果一个class没有定义explicit copy constructor，那么是否会有一个编译器合成的实例别调用？</p>
<p><strong>这就取决于这个class是否展现了”bitwise copy semantics“ 而定了</strong>，下面的就是没有展示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()&#123;<br><br>    &#125;<br>    <span class="hljs-built_in">Derived</span>(string&amp; d)&#123;<br>        j = d;<br>        cout &lt;&lt; <span class="hljs-string">&quot;执行了&quot;</span>&lt;&lt;endl;<br>    &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::func()&quot;</span> &lt;&lt; endl; &#125;<br>    string j;<br>	<span class="hljs-type">int</span> z;<br>    <span class="hljs-type">int</span> t;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>这种情况下，编译器必须合成一个copy constructor，目的是为了调用string j的copy 构造函数，值得注意的一点是，在合成的copy构造函数中，是对所有的成员变量进行复制，如下。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Drived</span>(Drived&amp; d)&#123;<br>    j.string::<span class="hljs-built_in">string</span>(d.j);<br>    z = d.z;<br>    t = d.t;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>**什么时候不展现了”bitwise copy semantics“ **，分以下四种情况</p>
</blockquote>
<ol>
<li><p>当class内含有一个member object而后者的class声明一个copy constructor（这个可以是自己声明的，也可以是编译器生成的）</p>
</li>
<li><p>当class继承自一个base class，并且这个base存在一个copy constructor（可以是自己定义，也可以是编译器生成的）</p>
</li>
<li><p>当class声明了一个或者多个virtual function</p>
<blockquote>
<p>Drived d;</p>
<p>Drived f(d);这个会调用派生类的copy构造函数，然后会在派生类的构造函数调用父类的copy构造（子类的copy是编译器生成的）</p>
<p>在派生类中，有一个vptr，会直接复制过去</p>
<p>但是如果下面这种：</p>
<p>Base b(d);</p>
<p>这个就会发生切割问题，就是子类的成员被切割掉了，然后其他的会直接复制过去吗，包括这个vptr？</p>
<p>答案是vptr会有编译器生成的copy构造函数自己生成，然后其他的变量拷贝过去。</p>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="程序装换"><a href="#程序装换" class="headerlink" title="程序装换"></a>程序装换</h2><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>X xx；</p>
<p>foo(X xx);</p>
<p>编译器如何实现这个foo(X xx)函数的，首先它会生成一个临时变量，然后对这个临时变量进行copy构造，然后改写函数调用的操作，以便使用上述的临时对象,如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">X temp0<br>temp0.X::<span class="hljs-built_in">X</span>(xx);<br><span class="hljs-built_in">foo</span>(temp0);<br></code></pre></td></tr></table></figure>

<p>但是上面只做的一部分工作，在这个foo的声明上，此时要变成void foo(X&amp; xx)</p>
<h3 id="返回值的初始化"><a href="#返回值的初始化" class="headerlink" title="返回值的初始化"></a>返回值的初始化</h3><p>X foo();</p>
<p>X X = Foo();</p>
<p>更改函数的参数多一个返回值类型的引用，然后在return前执行这个参数的copy构造函数</p>
<p>别更改成这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( foo&amp; result )</span></span>&#123;<br>    X xx;<br>    xx.X::<span class="hljs-built_in">X</span>();<br>    <br>    result.X::<span class="hljs-built_in">X</span>(xx);<span class="hljs-comment">// 编译器产生的copy 构造操作</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br>因此上面的两句变成：<br>    X xx;<br>  <span class="hljs-built_in">foo</span>(xx);<br></code></pre></td></tr></table></figure>



<h2 id="Copy构造要还是不要"><a href="#Copy构造要还是不要" class="headerlink" title="Copy构造要还是不要"></a>Copy构造要还是不要</h2><h2 id="成员的初始化队伍"><a href="#成员的初始化队伍" class="headerlink" title="成员的初始化队伍"></a>成员的初始化队伍</h2><p>一般我们采用在构造函数后面通过<code>:</code>这个符号接着调用成员对象的构造函数进行直接初始化，而不是在这个构造函数体内采用赋值的方式进行初始化，这样就会先调用成员变量的默认构造函数，然后创建一个临时对象，然后再将临时对象赋值给成员变量操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">如果对word类的name初始化以赋值方式，编译器就会生成如下<br>    name.String::<span class="hljs-built_in">String</span>(); 先调用默认构造函数<br>    string temp = string（“hellop”）；生成临时对象<br>    name.string::<span class="hljs-keyword">operator</span>=(temp);<br>    temp.string::~<span class="hljs-built_in">string</span>();析构掉<br></code></pre></td></tr></table></figure>

<p>所以编译器扩充之后代码量较大，效率不高。</p>
<h2 id="内存对象布局-重要"><a href="#内存对象布局-重要" class="headerlink" title="内存对象布局(重要)"></a>内存对象布局(重要)</h2><h3 id="有用的命令"><a href="#有用的命令" class="headerlink" title="有用的命令"></a>有用的命令</h3><p><code>g++ -fdump-lang-class XXX.cpp</code> 这个命令可以生成对象的内存结构</p>
<p><code>objdump -S xxxx</code> 可以生成反汇编文件</p>
<p><code>c++filt xxxx</code> 可以查看汇编文件中的字符对应c++中的内容</p>
<p><code>size a.out</code> 查看一个文件的各个段的大小以及占用的磁盘空间</p>
<p><code>readelf -S a.out </code>查看可执行文件的段表</p>
<h3 id="内存对齐和字节对齐"><a href="#内存对齐和字节对齐" class="headerlink" title="内存对齐和字节对齐"></a>内存对齐和字节对齐</h3><h3 id="c-程序如何如何存储的"><a href="#c-程序如何如何存储的" class="headerlink" title="c++程序如何如何存储的"></a>c++程序如何如何存储的</h3><p>一般情况下，一个C可执行程序在内存中主要包含5个区域，分别是：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aWU6LeR55qE5qmY5a2Q,size_18,color_FFFFFF,t_70,g_se,x_16.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li>.text 代码段</li>
<li>.bss </li>
<li>.data</li>
<li>heap</li>
<li>stack</li>
</ul>
<ol>
<li>.text :他就是存放程序指令的地方，只读</li>
<li>.bss： 用来存放未初始化的全局变量或者静态变量，编译器全给初始化0</li>
<li>.data：用来存放已经初始化的全局变量或者静态变量以及常量数据</li>
<li>stack：存放函数调用相关的参数、局部变量的值，以及任务切换时的上下文环境。栈区是由操作系统进行操作和管理的区域</li>
<li>heap：动态内存分配区域，也就是molloc申请的内存区，使用free进行释放，堆内存的申请和管理全部由程序员来控制，容易发生内存泄漏。</li>
</ol>
<blockquote>
<p>【注意】：对于.bss在文件中是不体现出来的，不占用文件大小，<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39748622/article/details/125991569">https://blog.csdn.net/qq_39748622/article/details/125991569</a></p>
</blockquote>
<h3 id="Data-member布局"><a href="#Data-member布局" class="headerlink" title="Data member布局"></a>Data member布局</h3><p>目前各家编译器都是把一个以上的access sections 连锁在一起，依照声明的顺序，连接成一个区块</p>
<h3 id="Data-member的存取"><a href="#Data-member的存取" class="headerlink" title="Data member的存取"></a>Data member的存取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point3d origin<br>Point3d *pt = &amp;origin<br><br>   origin.x = <span class="hljs-number">0.0</span>;<br>   pt-&gt;x = <span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure>

<p>以上两种赋值方式的差别</p>
<p> 如果Point3d是一个Derived class那么指针的存取操作会被延迟到执行期，如果是origin，那就不会有这个问题。</p>
<p>以上两个需要进一步补充，下面，我们直接进入继承下的对象布局</p>
<h3 id="继承与Data-member"><a href="#继承与Data-member" class="headerlink" title="继承与Data member"></a>继承与Data member</h3><p>在C++继承模型中，一个derived class object表现出来的东西，是其自己members和base class(es) members的总和。</p>
<p>至于derived class members 和 base class members的布局顺序，则在c++ standard中没有指定，但是现实中大部分的编译器都是先把base的members先出现。</p>
<p><strong>在继承过程中，会涉及到边界调整</strong></p>
<h3 id="带有虚函数的继承"><a href="#带有虚函数的继承" class="headerlink" title="带有虚函数的继承"></a>带有虚函数的继承</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shichao1470/article/details/91563282">https://blog.csdn.net/shichao1470/article/details/91563282</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31442743/article/details/117689375">https://blog.csdn.net/qq_31442743/article/details/117689375</a> 这个展示了c++的程序存储位置</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1755489">https://cloud.tencent.com/developer/article/1755489</a></p>
<h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><p>当带有虚函数的继承时，会在父类和子类有以下的负担：</p>
<ul>
<li>导入一个和子类或者父类相关的virtual table，用来存放它声明的每一个虚函数的地址，这个虚函数表大小是所有虚函数的个数加上一两个slots，存放type_info等</li>
<li>在每一个class object中导入一个vptr，提供执行期间的链接，使得每一个obje能够找到相应的virtual table</li>
<li>加强constructor，使他能够为vptr赋初值，指向class对应的虚函数表</li>
<li>加强destructor，使他能够析构掉vptr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">stand</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504224026194.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>存储模型</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504225719867.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>我们看到，这个dog类，包含了一个vptr指向这个虚函数表的偏移16位的地方，然后下面就是一个个的函数指针。在gcc和64位的编译器上，vptr是一个long类型的指针，因为虚函数表存的也是一个个指针，指针大小在64位机器上是8个字节，所以我们要设置vptr为8字节的指针，方便我们取出8字节的内容（即正确取出8字节的函数指针，如果vptr是int*，那么我们只能取出4字节的函数地址，这显然是错误的）</p>
<blockquote>
<p>上面没有出现重写，下面是一个重写</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504230137136.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><blockquote>
<p>多继承无重写</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190414231512498.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> sleepType;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">stand</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell">Vtable for Animal<br>Animal::_ZTV6Animal: 4 entries<br>0     (int (*)(...))0<br>8     (int (*)(...))(&amp; _ZTI6Animal)<br>16    (int (*)(...))Animal::eat<br>24    (int (*)(...))Animal::run<br><br>Class Animal<br>   size=16 align=8<br>   base size=16 base align=8<br>Animal (0x0x7f87d2169420) 0<br>    vptr=((&amp; Animal::_ZTV6Animal) + 16)<br><br>Vtable for Sleeper<br>Sleeper::_ZTV7Sleeper: 4 entries<br>0     (int (*)(...))0<br>8     (int (*)(...))(&amp; _ZTI7Sleeper)<br>16    (int (*)(...))Sleeper::sleep<br>24    (int (*)(...))Sleeper::action<br><br>Class Sleeper<br>   size=16 align=8<br>   base size=12 base align=8<br>Sleeper (0x0x7f87d2169600) 0<br>    vptr=((&amp; Sleeper::_ZTV7Sleeper) + 16)<br><br>Vtable for Dog<br>Dog::_ZTV3Dog: 10 entries<br>0     (int (*)(...))0<br>8     (int (*)(...))(&amp; _ZTI3Dog)<br>16    (int (*)(...))Animal::eat<br>24    (int (*)(...))Animal::run<br>32    (int (*)(...))Dog::shout<br>40    (int (*)(...))Dog::stand<br>48    (int (*)(...))-16<br>56    (int (*)(...))(&amp; _ZTI3Dog)<br>64    (int (*)(...))Sleeper::sleep<br>72    (int (*)(...))Sleeper::action<br><br>Class Dog<br>   size=32 align=8<br>   base size=28 base align=8<br>Dog (0x0x7f87d217c1c0) 0<br>    vptr=((&amp; Dog::_ZTV3Dog) + 16)<br>Animal (0x0x7f87d2169720) 0<br>      primary-for Dog (0x0x7f87d217c1c0)<br>Sleeper (0x0x7f87d2169780) 16<br>      vptr=((&amp; Dog::_ZTV3Dog) + 64)<br><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504231424359.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>【总结】：<strong>我们可以看出，Dog把两个父类的虚函数表都赋值过来了，并且在第一个继承的父类中扩展添加自己的虚函数。</strong></p>
<blockquote>
<p>有重写的多继承</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> sleepType;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shut</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vtable <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTV6Animal: <span class="hljs-number">4</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><br>Class Animal<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7fde52d69420) <span class="hljs-number">0</span><br>    vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTV7Sleeper: <span class="hljs-number">4</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><br>Class Sleeper<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7fde52d69600) <span class="hljs-number">0</span><br>    vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTV3Dog: <span class="hljs-number">10</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::eat<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::action<br><span class="hljs-number">40</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::shut<br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">72</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::_ZThn16_N3Dog6actionEv<br><br>Class Dog<br>   size=<span class="hljs-number">32</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">28</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7fde52d7c1c0) <span class="hljs-number">0</span><br>    vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7fde52d69720) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7fde52d7c1c0)<br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7fde52d69780) <span class="hljs-number">16</span><br>      vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">64</span>)<br><br><br></code></pre></td></tr></table></figure>



<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504232732177.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>只要被子类重写的虚函数，都会添加到最左父类指向的格子中，上图子类重写了右边父类的action函数，该函数指针被添加到了左边父类的vptr指向的虚表中。而Sleeper中虚表的action位置则利用了一个thunk，跳转到重写的Dog : : action()。</p>
<h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><blockquote>
<p>菱形继承</p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504203000972.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span>&#123;<br>	  <span class="hljs-keyword">public</span>:<br>	  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	  <span class="hljs-keyword">private</span>:<br>	  	<span class="hljs-type">int</span> number;<br>&#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> : <span class="hljs-keyword">public</span> Creature&#123;<br>      <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>      <span class="hljs-keyword">private</span>:<br>          <span class="hljs-type">int</span> name;<br>          <span class="hljs-type">int</span> age;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span> : <span class="hljs-keyword">public</span> Creature&#123;<br>	 <span class="hljs-keyword">public</span>:<br>	 	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	 	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	 <span class="hljs-keyword">private</span>:<br>	 	<span class="hljs-type">int</span> sleepType;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shut</span><span class="hljs-params">()</span></span>&#123;&#125;<br> &#125;;<br><br></code></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vtable <span class="hljs-keyword">for</span> Creature<br>Creature::_ZTV8Creature: <span class="hljs-number">3</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI8Creature)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Class Creature<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b69420) <span class="hljs-number">0</span><br>    vptr=((&amp; Creature::_ZTV8Creature) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTV6Animal: <span class="hljs-number">5</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><br>Class Animal<br>   size=<span class="hljs-number">24</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">20</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e1a0) <span class="hljs-number">0</span><br>    vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b695a0) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e1a0)<br><br>Vtable <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTV7Sleeper: <span class="hljs-number">5</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><br>Class Sleeper<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e208) <span class="hljs-number">0</span><br>    vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b69720) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e208)<br><span class="hljs-comment">// Dog的对象布局</span><br>Vtable <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTV3Dog: <span class="hljs-number">12</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::action<br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::shut<br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-24</span><br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">72</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">80</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">88</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::_ZThn24_N3Dog6actionEv<br><br>    <span class="hljs-comment">// 下面是Dog的对象布局</span><br>Class Dog<br>   size=<span class="hljs-number">40</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">40</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7faf48b7b230) <span class="hljs-number">0</span><br>    vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e270) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7faf48b7b230)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b69840) <span class="hljs-number">0</span><br>        primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e270)<br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e2d8) <span class="hljs-number">24</span><br>      vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">72</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b698a0) <span class="hljs-number">24</span><br>        primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e2d8)  <br><br><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504234140138.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>【总结】：即基类Creature的数据成员和虚函数同时存在两份，这显然不是我们想要的</p>
<blockquote>
<p>下面是虚继承：</p>
<p>通过虚继承解决菱形继承的问题，即解决上面父类对象有两份的现象</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span>&#123;<br>	  <span class="hljs-keyword">public</span>:<br>	  	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	  <span class="hljs-keyword">private</span>:<br>	  	<span class="hljs-type">int</span> number;<br>&#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Creature&#123;<br>      <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>      <span class="hljs-keyword">private</span>:<br>          <span class="hljs-type">int</span> name;<br>          <span class="hljs-type">int</span> age;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Creature&#123;<br>	 <span class="hljs-keyword">public</span>:<br>	 	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	 	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	 <span class="hljs-keyword">private</span>:<br>	 	<span class="hljs-type">int</span> sleepType;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shut</span><span class="hljs-params">()</span></span>&#123;&#125;<br> &#125;;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vtable <span class="hljs-keyword">for</span> Creature<br>Creature::_ZTV8Creature: <span class="hljs-number">3</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI8Creature)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Class Creature<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f8916769420) <span class="hljs-number">0</span><br>    vptr=((&amp; Creature::_ZTV8Creature) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTV6Animal: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">16</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>VTT <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTT6Animal: <span class="hljs-number">2</span> entries<br><span class="hljs-number">0</span>     ((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">24</span>)<br><span class="hljs-number">8</span>     ((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">64</span>)<br><br>Class Animal<br>   size=<span class="hljs-number">32</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7f891660e1a0) <span class="hljs-number">0</span><br>    vptridx=<span class="hljs-number">0</span> vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">24</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f89167695a0) <span class="hljs-number">16</span> <span class="hljs-keyword">virtual</span><br>      vptridx=<span class="hljs-number">8</span> vbaseoffset=<span class="hljs-number">-24</span> vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">64</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTV7Sleeper: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">16</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>VTT <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTT7Sleeper: <span class="hljs-number">2</span> entries<br><span class="hljs-number">0</span>     ((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">24</span>)<br><span class="hljs-number">8</span>     ((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">64</span>)<br><br>Class Sleeper<br>   size=<span class="hljs-number">32</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7f891660e270) <span class="hljs-number">0</span><br>    vptridx=<span class="hljs-number">0</span> vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">24</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f8916769780) <span class="hljs-number">16</span> <span class="hljs-keyword">virtual</span><br>      vptridx=<span class="hljs-number">8</span> vbaseoffset=<span class="hljs-number">-24</span> vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">64</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTV3Dog: <span class="hljs-number">16</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">32</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::action<br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::shut<br><span class="hljs-number">56</span>    <span class="hljs-number">16</span><br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">72</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">80</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">88</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::_ZThn16_N3Dog6actionEv<br><span class="hljs-number">96</span>    <span class="hljs-number">0</span><br><span class="hljs-number">104</span>   (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-32</span><br><span class="hljs-number">112</span>   (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">120</span>   (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Construction vtable <span class="hljs-keyword">for</span> <span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7f891660e340 instance) in Dog<br>Dog::_ZTC3Dog0_6Animal: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">32</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-32</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Construction vtable <span class="hljs-keyword">for</span> <span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7f891660e3a8 instance) in Dog<br>Dog::_ZTC3Dog16_7Sleeper: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">16</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>VTT <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTT3Dog: <span class="hljs-number">7</span> entries<br><span class="hljs-number">0</span>     ((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">24</span>)<br><span class="hljs-number">8</span>     ((&amp; Dog::_ZTC3Dog0_6Animal) + <span class="hljs-number">24</span>)<br><span class="hljs-number">16</span>    ((&amp; Dog::_ZTC3Dog0_6Animal) + <span class="hljs-number">64</span>)<br><span class="hljs-number">24</span>    ((&amp; Dog::_ZTC3Dog16_7Sleeper) + <span class="hljs-number">24</span>)<br><span class="hljs-number">32</span>    ((&amp; Dog::_ZTC3Dog16_7Sleeper) + <span class="hljs-number">64</span>)<br><span class="hljs-number">40</span>    ((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">120</span>)<br><span class="hljs-number">48</span>    ((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">80</span>)<br><br>Class Dog<br>   size=<span class="hljs-number">48</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">28</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7f891677b230) <span class="hljs-number">0</span><br>    vptridx=<span class="hljs-number">0</span> vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">24</span>)<br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7f891660e340) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7f891677b230)<br>      subvttidx=<span class="hljs-number">8</span><br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f89167698a0) <span class="hljs-number">32</span> <span class="hljs-keyword">virtual</span><br>        vptridx=<span class="hljs-number">40</span> vbaseoffset=<span class="hljs-number">-24</span> vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">120</span>)<br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7f891660e3a8) <span class="hljs-number">16</span><br>      subvttidx=<span class="hljs-number">24</span> vptridx=<span class="hljs-number">48</span> vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">80</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f89167698a0) alternative-path<br></code></pre></td></tr></table></figure>



<blockquote>
<p><strong>一定要注意内存对齐</strong></p>
</blockquote>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504235614359.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>这个图的number和sleepType位置反了</strong></p>
<h3 id="多继承父指针和子类指针转化时情况"><a href="#多继承父指针和子类指针转化时情况" class="headerlink" title="多继承父指针和子类指针转化时情况"></a>多继承父指针和子类指针转化时情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base的构造&quot;</span> &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">Base</span>(Base&amp; b)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了Base的copy&quot;</span>&lt;&lt;endl;<br>    &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::func()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了Base的析构函数&quot;</span> &lt;&lt;endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-comment">// string s;</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br> <span class="hljs-keyword">public</span>:<br> 	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br> 	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-keyword">private</span>:<br> 	<span class="hljs-type">int</span> sleepType;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> :<span class="hljs-keyword">public</span> Base,<span class="hljs-keyword">public</span> AA &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()&#123;<br>    &#125;<br>    <span class="hljs-comment">// Derived(Derived&amp; d)&#123;</span><br>        <br>    <span class="hljs-comment">//     cout &lt;&lt; &quot;执行了&quot;&lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    ~<span class="hljs-built_in">Derived</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了Drived的析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br>	<span class="hljs-comment">// virtual void func() &#123; cout &lt;&lt; &quot;B::func()&quot; &lt;&lt; endl; &#125;</span><br>    <span class="hljs-comment">// string j;</span><br>	<span class="hljs-comment">// int z;</span><br>    <span class="hljs-comment">// int t;</span><br>&#125;;<br><span class="hljs-comment">// void (*p)(void);</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Derived * d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    AA *a = d;<br>    cout &lt;&lt; d &lt;&lt;endl;  <span class="hljs-comment">// 0x55555556aeb0</span><br>    cout &lt;&lt; a &lt;&lt;endl;  <span class="hljs-comment">// 0x55555556aec0</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>Drived 继承 Base ，和AA，由上可以看到a和d地址偏移16，也就是我们上述分析的偏移了两个int和vptr。</strong></p>
</blockquote>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="函数的各种调用方式"><a href="#函数的各种调用方式" class="headerlink" title="函数的各种调用方式"></a>函数的各种调用方式</h3><h4 id="非静态成员函数"><a href="#非静态成员函数" class="headerlink" title="非静态成员函数"></a>非静态成员函数</h4><p>既然他叫成员函数，那么成员函数也会被转成非成员函数，主要转换步骤</p>
<ul>
<li>改写函数原型，安插一个额外的参数在member function中，这个额外参数就是<strong>this指针</strong>，这个指针不能指向别的对象，因此他是Person * const p；这种形式的</li>
<li>对每一个非静态成员数据都是通过这个this指针完成的</li>
<li>将成员函数改写成一个外部函数，然后给这个函数重新mangling处理，也就是重新设置名字，对于数据成员也是重新命名</li>
</ul>
<h4 id="虚拟成员函数"><a href="#虚拟成员函数" class="headerlink" title="虚拟成员函数"></a>虚拟成员函数</h4><p>如果normalize()是一个虚拟函数，那么对于以下的调用</p>
<p>ptr-&gt;normalize()；</p>
<p>会被转换成如下：</p>
<p>（* ptr-&gt;vptr[1]）(ptr);</p>
<ul>
<li>vprt 是虚函数表指针，这个虚函数表指针的名称不一定知识vptr，还有可能也被mangling（重命名），因为在一个复杂的继承体系中，可能存在多个vptr</li>
<li>1是代表虚函数表项的索引，关联到normalize（）函数</li>
<li>第二个ptr指的是this指针</li>
</ul>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul>
<li><strong>静态成员函数的主要特征是它没有this指针</strong></li>
<li>它不能直接存取class中的非静态成员（数据和函数都不行）</li>
<li>它不能够被声明为const volatile或者virtual</li>
<li>它不需要经由class object 调用</li>
</ul>
<h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++ 新特性"></a>C++ 新特性</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46873777/article/details/122948389?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_46873777/article/details/122948389?spm=1001.2014.3001.5502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58450087/article/details/124510851?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_58450087/article/details/124510851?spm=1001.2014.3001.5502</a></p>
<h1 id="C-静态链接和动态链接"><a href="#C-静态链接和动态链接" class="headerlink" title="C++ 静态链接和动态链接"></a>C++ 静态链接和动态链接</h1><h2 id="源代码到可执行文件过程"><a href="#源代码到可执行文件过程" class="headerlink" title="源代码到可执行文件过程"></a>源代码到可执行文件过程</h2><p>源代码到可执行文件，一般会经历预处理、编译、汇编、链接这几个操作</p>
<ul>
<li>预处理主要是对一些宏定义进行文本替换，对include进行处理，对条件编译指令进行处理，删除所有的注释，添加行号和文件标识，方便在调试和编译错误时显示行号</li>
<li>编译：编译阶段是将预处理后的文件进行语法分析和语义解析与优化生成对应的汇编代码</li>
<li>汇编：汇编就是将汇编文件解析成机器指令，生成目标文件</li>
<li>链接：</li>
</ul>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接是通过链接器，将多个目标文件链接成一个可执行文件。静态链接是发生在程序运行前就完成的，它主要做了两件事：</p>
<ul>
<li><strong>空间与地址分配</strong>：将多个目标文件中的相同的段进行合并，然后为新的段分配虚拟内存地址，并在section table中记录每个段在新的文件中的偏移量，即VMA和file off信息，然后将每个目标文件中的符号表进行重计算和合并，放到一个符号表中（即重新计算每个符号属于哪个段，以及<strong>每个符号的虚拟地址 – 因为符号只有一个）</strong>；</li>
<li><strong>符号解析与重定位</strong>：基于上一步和每个section的重定位表，我们可以对符号进行重定位，将要重定位的地方修改为正确的虚拟地址。<strong>重定位表中记录了重定位的位置以及重定位符号在符号表中的下标等信息</strong>。      <strong>重定位的地方有很多，可能多个重定位地方对应相同的符号。</strong></li>
</ul>
<blockquote>
<p>符号表：记录和每个符号的名字，所在的段，和在每个段中的偏移位置（链接后直接记录的是虚拟地址）</p>
<p>重定位表：重定位表记录了所有的要重定位的位置，即重定位位置属于哪个段，重定位的符号在符号表中的下标。这样就能够将这个重定位的位置替换对应的符号的真实虚拟地址了。</p>
</blockquote>
<blockquote>
<p>静态链接带来的弊端：</p>
</blockquote>
<p>静态链接会直接将其他的目标文件的段合到一起而形成一个新的可执行文件，这样就会导致形成的可执行文件中包含了大量的目标文件的副本。造成磁盘和内存空间的浪费。</p>
<p>而且当其中一个目标文件修改之后，必须重新链接成新的可执行文件。</p>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><blockquote>
<p> 为什么要引入动态连接</p>
</blockquote>
<p>在静态链接中，多个目标文件进行链接的时候会在可执行文件中合并所有目标文件中的相同的段，也就是最终的可执行文件是包含了所有目标文件的一个副本。这样就会造成空间的浪费，因为在内存和磁盘中会有很多目标文件的副本存在。并且当参与静态链接的目标文件发生改变的时候，需要重新进行链接，这对于大量使用此目标文件的程序的运行更新带来很多麻烦。因此，针对于这两个现象，引入了动态链接技术，动态链接能够将目标文件的链接推迟到运行阶段，而不是发生在程序的装载前。但是这样也会导致运行时链接降低了程序的运行效率。</p>
<blockquote>
<p>共享模块的在编译的时候，目标地址是不确定的（就是它里面的一些重定位符号），只有当链接的时候才会确定这个地址。（比如共享模块访问自己模块中的全局变量，共享模块的.data会被复制一块然后映射到进程的虚拟空间中，当共享模块发生重定位时，由于每个进程可能为共享模块分配的虚拟空间不同，由于重定位时会发生指令变化，将可重定位地方转成对应的地址，这样由于不同进程中.data中各个变量虚拟地址不同，就会导致这个共享模块无法在所有进程共享。）</p>
<p><strong>简而言之就是：在共享模块中的代码有采用绝对地址访问变量的指令，在重定位时，由于各个进程为共享模块分配的虚拟空间不一样，导致重定位时每个进程访问同种变量时地址不一致，因此这就无法实现共享模块指令的共享。</strong></p>
</blockquote>
<blockquote>
<ol>
<li>装载时重定位：就是在发生装载的时候才进行重定位操作。但是这个方法不能实现指令在内存中的共享，依然需要占用很多内存对于多个进程使用同一个共享模块</li>
<li>地址无关代码：这个就是用来解决动态模块中<strong>有绝对地址引用</strong>的方法，并且实现了共享模块指令在进程间的共享</li>
</ol>
</blockquote>
<blockquote>
<p>下面我们就介绍一下这个地址无关代码：</p>
<ul>
<li>基本思想就是：将指令中那些需要被修改的部分分离出来，和数据部分放在一起</li>
<li>将.data段单独复制一份出来并映射到自己进程的虚拟空间</li>
<li>这样其他的指令是可以在进程间共享的</li>
</ul>
</blockquote>
<p>我们进行分类讨论这个指令寻址方式：</p>
<ul>
<li><p>模块内数据访问：采用的是相对寻址</p>
</li>
<li><p>模块内数据的访问与调用：采用的是相对寻址</p>
</li>
<li><p>模块间的数据访问：</p>
<blockquote>
<p>对于模块间的数据访问，通过采用的GOT（global offset table）全局偏移表实现，在GOT表中记录了要访问的其他模块的变量的地址（当然被调用的共享模块中的.data已经被复制一份并映射到自己进程的虚拟空间中了），这样指令中访问其他模块的变量的指令就是直接访问这个GOT表了，通过相对寻址，这就实现了地址代码无关的指令了（因为所有模块中都没有绝地地址寻址了），都相当于转换成了模块内的相对寻址了。</p>
<ul>
<li>我们在编译的时候就可以确定GOT相对当前指令的偏移量，然后根据变量在GOT中的偏移量就可以确定这个变量位于GOT那个地方（由编译器规定每个变量的位置）然后在装载的时候，就可以将变量的实际虚拟地址给填充到这个GOT中。然后就可以通过这个GOT进行间接寻址了。</li>
</ul>
</blockquote>
</li>
<li><p>模块间的函数访问与调用：</p>
<blockquote>
<p>这个也是通过GOT进行实现的，存放函数地址。</p>
</blockquote>
</li>
</ul>
<p>【动态链接带来的缺点】：</p>
<ul>
<li>在动态链接下，程序的链接是发生在运行时期的，他会装载所有相关的共享模块，然后进行符号查找与重定位工作，这些都降低了程序初始运行的速度</li>
<li>并且，动态链接中一些模块间数据的访问是要通过GOT表进行间接寻址的，先要找到GOT表，然后确定访问变量的地址，然后再根据地址去访问变量。</li>
</ul>
<blockquote>
<p>我们如何对动态链接进行优化呢？</p>
</blockquote>
<ul>
<li>延迟绑定</li>
</ul>
<p>因为在程序运行前，就将所有的函数进行符号查找和重定位操作，但是有些函数可能从始至终都没有使用过，所以我们可以在函数的第一次使用的时候才进行绑定（符号查找和重定位）</p>
<p>【具体原理】：</p>
<p>在elf中维护了一个PLT表，对于函数的调用是通过这个PLT进行调用的，而不是之前的那个GOT表了，但是实际就是先通过PLT再通过GOT进行调用。PLT表和GOT表的填充都是在运行时进行填充的。</p>
<blockquote>
<p>我们现在开始说一下这个动态链接的具体过程</p>
</blockquote>
<p>先回顾一下静态链接中elf文件加载过程：</p>
<p>就是先读取elf header，然后进行文件的格式版本检查等操作，然后根据Program header table读取所有的段进入内存，并完成物理空间分配和地址映射操作，执行完成这些之后，就将eip指向程序的入口地址。</p>
<p>但是在动态链接中不是这样的：</p>
<p>当加载完成所有的段后，它会把eip指向动态链接器程序入口地址，动态连接器其实也是一个共享模块，然后对当前的可执行文件进行动态链接操作，然后执行完成之后，再把eip指向可执行文件的入口地址。</p>
<ul>
<li><p>动态链接器存在哪里？</p>
<p>动态链接模块在可执行文件中.inter段（interpreter）这个段记录了这个链接器的地址</p>
</li>
<li><p>.dynamic段是什么</p>
<p>他是专门用于动态链接的，在这个段中记录了动态链接符号表、动态链接重定位表位置等等</p>
<p>它和静态链接中ELF文件中文件头差不多，记录了这些符号表、重定位表信息</p>
</li>
</ul>
<blockquote>
<p>什么是动态符号表？.dynsym表</p>
</blockquote>
<p>在目标文件中，符号表记录了这个文件中的所有定义的符号的信息，比如这个符号的名字，这个符号在段中的偏移量等信息，在静态链接结束后，就会在符号表中记录了这个符号的地址信息。</p>
<p>动态符号表其实和静态符号表差不多</p>
<p><strong>在动态符号表中记录了动态链接模块中符号的导入和导出关系。</strong>动态符号表只记录了动态链接的符号，对于那些模块内部的符号存在.symtab中，.symtab中包含了.dynsym表信息</p>
<blockquote>
<p>什么是动态链接重定位表？</p>
</blockquote>
<p>主要是用来重定位.got和.got.plt段中的地址。因为这两个段记录了每个引用的全局变量和函数的地址。我们需要在装载完之后进行重定位这些变量的地址。</p>
<p>主要步骤和静态链接差不多，就是先去符号表中获取这个符号对应的地址，然后将地址填入到指定的.got或.got.plt位置处。</p>
<blockquote>
<p>下面我介绍一下动态链接的步骤于与实现</p>
</blockquote>
<h1 id="Gcc基本使用"><a href="#Gcc基本使用" class="headerlink" title="Gcc基本使用"></a>Gcc基本使用</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>【参考博客】<a target="_blank" rel="noopener" href="https://blog.csdn.net/IT_Mitchell/article/details/83932742">编译阶段+链接阶段+运行原理</a></p>
<p>gcc编译的四大过程：</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq56qB54yb6L-b6L-b6L-b,size_20,color_FFFFFF,t_70,g_se,x_16.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p> gcc -E hello.c -o hello.i  //-E只对其预处理，其注释被删除，且宏也被替代之后删除，</p>
</blockquote>
<blockquote>
<p> gcc -S hello.i -o hello.s // -S将.i文件生成.s汇编文件</p>
</blockquote>
<blockquote>
<p>gcc -c hello.s -o hello.o  //-c汇编文件，不链接，汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
</blockquote>
<blockquote>
<p>gcc hello.o -o hello // 链接阶段，<strong>这里才会分配地址空间</strong></p>
</blockquote>
<h2 id="反汇编等命令"><a href="#反汇编等命令" class="headerlink" title="反汇编等命令"></a>反汇编等命令</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38048756/article/details/115517983">https://blog.csdn.net/qq_38048756/article/details/115517983</a></p>
<blockquote>
<p>objdump -S a    // 其中a为a.out文件，反汇编之后会有地址的分配，</p>
<p>objdump -S person.o // 后面那个.o可以要也可以不要，看你具体生成的文件，这个反汇编生成的.s文件是没有地址分配的。</p>
</blockquote>
<h1 id="基本知识（汇总）"><a href="#基本知识（汇总）" class="headerlink" title="基本知识（汇总）"></a>基本知识（汇总）</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_31442743/article/details/116119490">https://blog.csdn.net/qq_31442743/article/details/116119490</a>  c++面试高频题-速记版</p>
<h2 id="const-和static"><a href="#const-和static" class="headerlink" title="const 和static"></a>const 和static</h2><p><a target="_blank" rel="noopener" href="https://www.yuque.com/orwell/vkefvt/axhgel#Uy4F0">https://www.yuque.com/orwell/vkefvt/axhgel#Uy4F0</a></p>
<h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><p>static（静态）主要有三个作用：</p>
<p>1.修饰局部变量，成为静态局部变量</p>
<p>2.修饰全局变量，成为静态全局变量</p>
<p>3.修饰函数，成为静态函数</p>
<blockquote>
<p><strong>static只能在类外进行初始化，因为静态成员属于类的，而不是对象的，所以不能在构造函数等地方进行初始化，不然的话，每次创建对象的时候都会更改这个static的值</strong></p>
<ul>
<li>但是常量静态成员可以在类内初始化</li>
<li>关键字static只出现类的内部。</li>
<li>在类外定义且初始化</li>
</ul>
</blockquote>
<blockquote>
<p>静态成员函数</p>
</blockquote>
<p>不考虑类情况：</p>
<ul>
<li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li>
<li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li>
<li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li>
</ul>
<p>考虑类： 静态成员函数是类中的特殊成员函数</p>
<ul>
<li>静态成员函数没有this指针，就是在编译的时候，不会产生this指针参数，普通的非静态成员函数是有this指针的，当我们调用的时候，系统会给这个对象的起始地址作为this指针给到函数，实现不同对象复用函数代码的隔离性</li>
<li>静态函数可以通过类和对象访问</li>
<li>静态成员函数只能访问静态函数/对象，不能访问非静态成员函数/对象</li>
<li>使用静态函数主要是为了处理静态成员变量。</li>
<li><strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li>
</ul>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul>
<li>不考虑类的情况<ul>
<li>const常量必须在定义的时候必须初始化，之后再也无法更改</li>
<li>const形参可以接收const和非const的实参</li>
</ul>
</li>
<li>考虑类的情况<ul>
<li><code>const成员变量</code>：不能在类内定义外部初始化，只能通过构造函数初始化列表进行初始化和类内声明时初始化(但是这个由于const属于对象数据，如果在类内声明后就初始化，那所有的对象都是一样的，通过初始化列表初始化可以为不同的类制定不同的数据，所以不建议直接初始化)</li>
<li><code>const成员函数</code>：不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值–<strong>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this</strong>*，因此不能const和static关键字同时修饰函数。因为static是没有this指针的</li>
<li>const对象不可以调用非const成员函数；非const对象都可以调用；</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>当const在函数名前面的时候修饰的是函数返回值，在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。修饰谁，谁就不能发生修改！</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span> </span>&#123; <br>	xxxx<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>常量指针和指针常量</p>
</blockquote>
<p>const int * p //表示常量指针–无法修改指针指向的空间的内容，所指向的变量是个const</p>
<p>int * const p // 表示这个指针不能更改指向的空间，但是可以改变指向空间的内容</p>
<h2 id="内存字节对齐"><a href="#内存字节对齐" class="headerlink" title="内存字节对齐"></a>内存字节对齐</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62932195/article/details/125821103">https://blog.csdn.net/qq_62932195/article/details/125821103</a></p>
<p>为了提高cpu的读取效率，会使数据存放进行对齐。</p>
<p>对齐的规律：</p>
<ul>
<li><strong>数据类型自身的对齐值</strong>：就是基本数据类型的自身对齐值，比如char类型的自身对齐值为1字节，int类型的自身对齐值为4字节。</li>
<li><strong>指定对齐值</strong>：预编译命令#pragma pack （value）指定的对齐值value。</li>
<li><strong>结构体或者类的自身对齐值</strong>：其成员中自身对齐值最大的那个值，比如以上的struct A的对齐值为4。</li>
<li><strong>数据成员、结构体和类的有效对齐值</strong>：自身对齐值和指定对齐值中较小的那个值。</li>
</ul>
<h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><p>c++将内存空间分为<strong>堆、栈、自由存储区、全局/静态变量区、常量存储区和代码区，</strong>他比c内存模型多了一个自由存储区。</p>
<p>或则说可以分为文本段（主要存放我们编写的代码，属于read only）、Data段（主要存放一些初始化的静态、全局变量和常量等）、bss段主要用来存放一些未初始化的静态、全局变量和常量（一般它不占文件大小，只有加载到内存后才会分配空间，它记录在elf header里面）、堆（主要是在运行时期申请和分配的空间）、栈（主要存放一些函数参数和局部变量这些）。</p>
<blockquote>
<p>那么自由存储区和堆的区别是什么？</p>
</blockquote>
<p>堆是C语言的关键语，是操作系统所维护的一块特殊内存，它提供了内存动态分配的功能。用户可以使用malloc进行堆内存的申请，使用free实现堆内存的释放。</p>
<p>而自由存储区是c++的抽象概念。C++将使用new/delete申请和释放的区域称为自由存储区。因此，自由存储区的实际位置和new/delete 申请释放的位置有关。 大部分编译器的new申请空间基于malloc实现的，默认在堆上实现自由存储区。但是用户也可以通过重载new关键字实现在其他区域的自由存储。</p>
<p>总之：自由存储区不等于堆，它只是C++的一个抽象概念，位置在哪取决于new/delete的实现，堆是操作系统维护的一块特殊内存。</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230329105118345.png" srcset="/img/loading.gif" lazyload alt="image-20230329105118345"></p>
<h2 id="STL内存池"><a href="#STL内存池" class="headerlink" title="STL内存池"></a>STL内存池</h2><p>一般来说，我们使用new运算符的时候，它会执行两个操作，一个是operator new （即分配空间），然后是构造对象，对于delete运算符，先析构对象再调用operator delete释放内存</p>
<p>但是在STL中：</p>
<ul>
<li>内存的<code>申请和释放</code>由<code>alloc::allocate()</code>和<code>alloc::deallocate()</code>这两个函数负责,<ul>
<li>在头文件<code>&lt;stl_alloc.h&gt;</code>中</li>
</ul>
</li>
<li>对于对象的<code>构造和析构</code>则由<code>::construct()和::destroy()</code>负责<ul>
<li>在construct中，会调用placement new去构造对象</li>
<li>在destroy中，直接调用对象的析构函数析构对象</li>
<li>在头文件<code>&lt;stl_construct.h&gt;</code>中</li>
</ul>
</li>
</ul>
<p>这两个头文件都在<code>&lt;memory&gt;</code>文件中</p>
<blockquote>
<p>下面我们讲一下这个STL中的内存申请与释放原理</p>
</blockquote>
<p>为了减少这个小型区块可能造成的内存碎块的问题，SGI设计了双层空间配置器</p>
<ul>
<li>第一级配置器直接采用malloc和free进行内存的申请和释放</li>
<li>第二级配置器采用维护一个内存池进行空间的分配</li>
</ul>
<blockquote>
<p>第一级配置器：</p>
</blockquote>
<p>第一级配置器以malloc、free、realloc()等C函数进行内存的申请、释放、重配置操作，并且设计了类似C++ new-handler机制（对于operator new也是封装了malloc，为什么不直接使用operator new呢，因为STL不能直接使用C++ new-handler机制，所以不能使用，所以自己设计了一个new-handler机制）</p>
<blockquote>
<p>第二级配置器</p>
</blockquote>
<p>SGI的二级配置器的做法是，如果申请的区块足够大，则给一级配置器处理，如果申请的内存块小于128KB，那么以内存池进行管理</p>
<p>二级配置器会维护16个链表，每个链表负责管理8、16、24一直到128为8的倍数的空间，它的节点是一个联合体，维护空间的时候可以看成一个节点(只包含一个next)，分配出去空间的时候，就是一个char数组了，用来存储数据。</p>
<p>同时还有一个空闲的内存池，由两个指针<code>start_free</code>和<code>end_free</code>两个指针维护</p>
<p>它的空间配置流程：</p>
<ol>
<li>对于申请空间：<ul>
<li>如果大于128kb就走一级配置器，否则走二级</li>
<li>一般申请的空间会是20*2个要申请的空间大小，然后1个返回给用户，19个挂在指定的链表上，然后剩下的20个作为内存池使用</li>
<li>首先我们会根据申请的空间找到对应的free_list节点，然后看看这个链表中有没有剩余的空间<ul>
<li>如果这个链表不为空，则将这个链表中取下一块内存分配给用户，并将free_list数组中的头节点指向新的空闲节点</li>
<li>如果链表为空，我们就先去这个内存池中去找对应的内存，然后申请20*2个，不够40，就有多少分多少，然后第一个给用户，剩余的放在指定的链表中维护</li>
<li>如果这个内存池没了，就重新使用malloc进行申请</li>
<li>如果整个heap空间没了，就会在freelist中找剩余的空间进行分配</li>
</ul>
</li>
</ul>
</li>
<li>对于释放空间就是上面的逆过程。</li>
</ol>
<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><h2 id="值、引用、指针传递"><a href="#值、引用、指针传递" class="headerlink" title="值、引用、指针传递"></a>值、引用、指针传递</h2><blockquote>
<p>值传递</p>
</blockquote>
<p>在栈上压入参数的时候，会copy一份实参数据到栈上，对于栈上对象的更改不会影响实参本身</p>
<blockquote>
<p>指针传递</p>
</blockquote>
<p>指针传递实质也是值传递，只不过这个值是地址罢了，copy了一份指针的内容到栈上，这两个同时指向一个对象，所以可以通过栈上的指针来改变对象的内容</p>
<blockquote>
<p>引用传递</p>
</blockquote>
<p>引用的本质是指针常量，不会发生这个对象的拷贝构造，但是会有这个指针的拷贝，就是在栈上也会开辟空间，但是这个引用不能指向别人，对于那个指针传递，传进来的指针可以改变指向，但是无法改变实参指针的指向。</p>
<blockquote>
<p>指针返回和引用返回</p>
</blockquote>
<blockquote>
<p>对于返回值是引用还是指针，一定要保证这个引用和指针指向的内容在函数结束之后还存在，不能是局部变量（在栈上申请的局部变量不能使用引用或者指针返回），在堆上的可以使用指针返回（前提是没有delete掉，但是最好别这样干，因为很可能导致内存泄漏，也可以使用引用返回，但是无法delete）。</p>
</blockquote>
<h2 id="几种指针类型"><a href="#几种指针类型" class="headerlink" title="几种指针类型"></a>几种指针类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>]  <span class="hljs-comment">// 表示指向一个指针数组  即 (int*) p[10];数组都是指针</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>] <span class="hljs-comment">// 表示一个指向一个二维数组的指针，每行10个元素，如下代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>   <span class="hljs-comment">// 表示是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</span></span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>  <span class="hljs-comment">// 是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">1</span>][<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>];<br>    p = a; <span class="hljs-comment">// p可以看成一个指针的指针，指向一个 指向数组元素的指针数组</span><br>    cout &lt;&lt; *(*p +<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 1  *p得到第一个数组的指针，p+2得到第3个数组的指针</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="new-delete-和-malloc-free"><a href="#new-delete-和-malloc-free" class="headerlink" title="new/delete 和 malloc/free"></a>new/delete 和 malloc/free</h2><blockquote>
<p>相同点：</p>
</blockquote>
<p>都是用来申请动态内存的。</p>
<blockquote>
<p>不同点</p>
</blockquote>
<p>new/delete 是c++的关键字，new不需要自己计算内存大小，他会自动计算，而malloc需要自己计算</p>
<p>new是类型安全的，int *p = new int[100];正确，只能是int申请int的，不能int申请long之类的。</p>
<p><code>new关键字</code>：</p>
<ul>
<li>先调用operator new标准库函数进行空间申请，然后再调用对象的构造函数进行构造对象</li>
</ul>
<p><code>delete关键字</code>：</p>
<ul>
<li>先调用指针所指对象的析构函数进行析构对象，然后调用operator delete标准库函数进行内存释放</li>
</ul>
<p><strong>而malloc和free都是直接申请空间和释放操作，就是operator new和operator delete的操作，而不会构造对象和析构对象</strong></p>
<p><em><em>malloc和free返回的指针式void</em> 类型的，而new和delete式返回的具体的类型的指针</em>*</p>
<p>对于new之后，可以直接free，但是不会析构对象，只会释放函数</p>
<h3 id="malloc是如何申请内存的"><a href="#malloc是如何申请内存的" class="headerlink" title="malloc是如何申请内存的"></a>malloc是如何申请内存的</h3><p>malloc申请内存的时候，会有两种方式向操作系统申请堆内存</p>
<ul>
<li>方式一：通过brk()系统调用从堆中分配内存 <ul>
<li>通过brk()函数将堆顶指针向高地址移动，获取新的内存空间。</li>
</ul>
</li>
<li>方式二：通过mmap()系统调用在文件映映射区进行分配<ul>
<li>同mmap函数在文件映射区分配一块内存。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>什么场景下mallco函数会通过brk来申请内存空间？什么场景下用mmap申请</strong></p>
</blockquote>
<ul>
<li>当用户分配的内存小于128KB的时候，使用brk申请内存</li>
<li>当用户申请的内存高于128KB的时候，使用mmap申请内存</li>
</ul>
<p>不同的malloc实现，阈值也是不同的</p>
<ul>
<li>使用brk申请空间，他会一次性申请较多的空间，然后执行free后也不会将申请的空间归还给操作系统，只有当进程结束的时候才会将空间还给操作系统<ul>
<li>malloc（1）会申请一大块内存，使用brk，剩下的内存可以作为内存池下次使用。</li>
</ul>
</li>
<li>使用mmap申请空间，free之后会直接将空间还给操作系统。</li>
</ul>
<blockquote>
<p><strong>malloc分配的是物理内存吗？</strong></p>
</blockquote>
<p>malloc分配的是虚拟内存。</p>
<p>当分配的虚拟内存空间没有被访问的时候，他是不会分配物理空间的，只有当用户访问了分配的虚拟空间，这个时候就会触发缺页异常，然后操作系统就会申请相应的物理页内存，并建立虚拟内存和物理内存的映射关系</p>
<blockquote>
<p>为什么free函数只传入一个内存地址，为什么能够知道要释放多大的空间</p>
</blockquote>
<p><strong>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</strong></p>
<p>这多出来的16字节就是存储这块内存块的信息，比如内存大小之类的</p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/cb6e3ce4532ff0a6bfd60fe3e52a806e.png" srcset="/img/loading.gif" lazyload alt="图片"></p>
<p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。</p>
<h3 id="malloc和free底层实现"><a href="#malloc和free底层实现" class="headerlink" title="malloc和free底层实现"></a>malloc和free底层实现</h3><h2 id="Java和C-区别"><a href="#Java和C-区别" class="headerlink" title="Java和C++区别"></a>Java和C++区别</h2><p>java的代码首先会经过一次编译形参字节码，也就是.class文件，这个.class文件在运行时会被jvm加载到内存并解释成字节码。而c++只需要一次编译链接就形成了机器码，所以程序执行的速度C++相对快点</p>
<p>但是java程序可以跨平台，通过在不同的平台上安装不同版本的jvm，就能够将.class文件解释成对应的机器码进行执行。</p>
<p>c++中包含指针，而java程序没有指针，他只有引用。</p>
<p>java程序是纯面向对象语言，所有的函数和变量都必须在类中定义，而C++可以有全局的函数和变量，可以面向过程</p>
<p>C++是需要自己管理内存的，而Java中的jvm是有自己垃圾回收机制，不用自己释放内存。</p>
<p>C++的运算符可以重载，而java的运算符不能重载。</p>
<p>C++程序适用于桌面程序和底层硬件控制之类的程序，而java适合web应用，因为其相关的web开发的框架十分多。</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2019-03/157819.htm">https://www.linuxidc.com/Linux/2019-03/157819.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yaxuan88521/article/details/127333854">https://blog.csdn.net/yaxuan88521/article/details/127333854</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58450087/article/details/124353529?spm=1001.2014.3001.5502%E3%80%90%E8%AF%A6%E7%BB%86%E3%80%91">https://blog.csdn.net/weixin_58450087/article/details/124353529?spm=1001.2014.3001.5502【详细】</a></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/84e80cdb0785e2711c677bcc943e05c7.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<ul>
<li><p>进程是资源分配的最小单位，一个进程可以有多个线程，每个线程执行不同的任务</p>
</li>
<li><p>而线程是cpu调度和分配的最小单位（cpu调度的就是一个个task_struct结构，每个线程和进程具有一个task_struct结构标识），它被包含在进程之中，是进程中的实际运行单位</p>
</li>
<li><p>每个task_struct中包含一个pid用来标识自己，然后还有一个tgid用来标识自己隶属于哪个进程（也就是线程组id），通过这个就可以共享这个进程的内存空间。</p>
</li>
<li><p>一个进程至少包含一个线程，进程是线程的容器</p>
</li>
<li><p>进程在创建子进程的时候，是拷贝整个内存空间，后面进行优化成了写时拷贝</p>
</li>
<li><p>而线程本身不具有内存空间，它和创建它的进程共享内存空间</p>
</li>
<li><p>进程有自己独立的地址空间，一个进程崩溃时，一般不会影响其他进程，而线程只是有自己的堆栈，但没有独立的地址空间，多个线程共享进程的内存空间，一个线程崩溃后，整个进程崩溃</p>
</li>
<li><p>线程之间的通信更加方便，因为他们共享进程的地址空间，可以访问全局变量和静态变量这些，而进程间的通信比较复杂。</p>
</li>
</ul>
<blockquote>
<p>为什么线程的切换比进程的切换的代价小？</p>
</blockquote>
<p>在切换进程的时候，会导致TLB的缓存失效，而对于线程的切换来说则不会影响TLB，所以在地址转换过程就比较慢了，开销就比较大了。</p>
<h2 id="内存泄漏、检测和解决办法"><a href="#内存泄漏、检测和解决办法" class="headerlink" title="内存泄漏、检测和解决办法"></a>内存泄漏、检测和解决办法</h2><blockquote>
<p> 什么是内存泄漏？</p>
</blockquote>
<ul>
<li>内存泄漏是指程序动态申请内存后，没有及时的释放掉不再使用的内存的情况。内存泄漏并不是指内存在物理上消失，而是指应用程序在分配某段内存后，由于某种原因，失去了对这块内存的控制。</li>
</ul>
<blockquote>
<p>产生内存泄漏的几种原因：</p>
</blockquote>
<ul>
<li>new 和delete没有成对使用，new完之后，没有及时delete，以及使用new申请的是数组空间，要使用delete + [] 进行释放，不然只会释放一个。</li>
<li>在继承关系中，基类的析构函数没有设计为虚函数<ul>
<li>对于析构过程，一般来说，对于子类的析构一般会先调用子类的析构函数，然后调用父类的析构函数</li>
<li>但是对于基类对象指针指向子类对象，如果没有采用虚析构设计，就会导致只析构父类对象，不会析构子类对象，因为无法通过父类指针来调用子类独有的方法和变量</li>
</ul>
</li>
</ul>
<blockquote>
<p>解决办法</p>
</blockquote>
<ul>
<li><p>手动释放:malloc和new之后一定要及时的free和delete，对于new数组，要使用delete数组的形式</p>
</li>
<li><p>使用智能指针，智能指针是资源获取即初始化的一种体现，使用智能指针管理我们的内存，可以在对象销毁时进行释放内存</p>
</li>
</ul>
<blockquote>
<p>如何检测内存泄漏？</p>
</blockquote>
<p>在Linux上比较常用的内存泄漏检测工具是<code>valgrind</code>，所以咱们就以valgrind为工具，进行检测。</p>
<h2 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_56673429/article/details/124837626">https://blog.csdn.net/qq_56673429/article/details/124837626</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46873777/article/details/123279167">https://blog.csdn.net/weixin_46873777/article/details/123279167</a></p>
<p>智能指针一般指的是std::unique_ptr，std::shared_ptr,weak_ptr</p>
<blockquote>
<p>shared_ptr：共享智能指针</p>
</blockquote>
<p>共享智能指针是指多个此智能指针可以同时指向管理同一块区域。</p>
<p>【如何让共享智能指针指向一块区域（初始化）：】</p>
<ul>
<li>通过构造函数</li>
<li>std::make_shared辅助函数</li>
<li>reset函数</li>
</ul>
<p>【获取原始指针？？？】：</p>
<p><strong>对于基础类型来说，通过操作智能指针和操作原始指针效果一样。但是如果共享智能指针管理的是一个对象，那么就需要取出管理的对象的原始指针，然后基于原始指针进行操作，可以使用get()方法获取原始指针</strong></p>
<p>【指定删除器】：</p>
<p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就被智能指针释放掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，<strong>这个删除操作对应的函数被称之为删除器</strong>，<strong>这个删除器函数本质是一个回调函数</strong>，我们只需要进行实现，其调用是由智能指针完成的。</p>
<blockquote>
<p>unique_ptr：独占智能指针</p>
</blockquote>
<p>他不允许其他的智能指针共享其内部的指针，也就是无法进行拷贝和复制，在unique_ptr中，拷贝构造函数的=号操作符都被标识为delete了</p>
<p>使用和共享智能指针基本一样</p>
<blockquote>
<p>weak_ptr：弱引用的智能指针</p>
</blockquote>
<p>它的存在主要是解决共享智能指针存在的循环引用的问题。它不能够操作资源，它只能判断资源是否有效，主要是配合shared_ptr进行预防循环引用，当指向一个和shared_ptr指向的对象时，并不会引起这个计数器的增加。</p>
<h2 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h2><ul>
<li>C++中的new和delete进行内存的申请和释放，不同于C的malloc和free</li>
<li>C++可以进行函数重载，C不能</li>
<li>C++中新增了引用</li>
<li>c的结构中只有变量，而c++的结构中可以有成员变量和成员函数</li>
<li>c++是面向对象的，而c是面向过程的。</li>
<li>C++比C多了一些关键字，如bool、using、namespace等</li>
</ul>
<h2 id="C-的直接初始化、拷贝初始化、赋值"><a href="#C-的直接初始化、拷贝初始化、赋值" class="headerlink" title="C++的直接初始化、拷贝初始化、赋值"></a>C++的直接初始化、拷贝初始化、赋值</h2><p>我们先确定一下什么是初始化，什么是赋值操作</p>
<ul>
<li><p>初始化就是，<strong>创建变量的时候赋予其初值</strong>（如果使用=号初始化对象就是拷贝初始化，否则就是直接初始化）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">string  str1 = <span class="hljs-string">&quot;first&quot;</span>;    <span class="hljs-comment">//拷贝初始化，编译器允许把这句话改写为string str(“first”)，但是string类必须有public的拷贝(移动)构造函数</span><br><span class="hljs-function">string  <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;     <span class="hljs-comment">//直接初始化</span><br><span class="hljs-function">string  <span class="hljs-title">str3</span><span class="hljs-params">(str2)</span></span>;      <span class="hljs-comment">//直接初始化  -------- 这个不是拷贝，而是直接初始化</span><br>string  str4 = <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">//拷贝初始化</span><br>string  str5 = str4;        <span class="hljs-comment">//拷贝初始化</span><br><span class="hljs-function">string  <span class="hljs-title">str6</span> <span class="hljs-params">(<span class="hljs-string">&quot;strr&quot;</span>)</span></span>;       <span class="hljs-comment">//直接初始化</span><br><br>【结论】：上面凡是使用了=号就是拷贝构造函数的调用，没有使用=号就是直接初始化。<br></code></pre></td></tr></table></figure></li>
<li><p>赋值就是：已经存在了这个变量，我们需要将其当前的值擦除掉，然后赋予新的值</p>
</li>
</ul>
<blockquote>
<p> 什么时候会出现临时变量呢？</p>
</blockquote>
<p>通常在以下三种情况会产生临时对象</p>
<ul>
<li><strong>以值传递的方式给函数传值</strong><ul>
<li>以值的形式传递参数，会调用拷贝构造函数产生一个副本，然后之后都是对这个副本进行操作</li>
</ul>
</li>
<li>类型转换</li>
<li>函数需要返回一个对象时<ul>
<li>当函数返回一个对象的时候，就会在栈中创建一个临时对象，用来存储函数的返回值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>RVO–<strong>return value optimization</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nbu_dahe/article/details/119142610">https://blog.csdn.net/nbu_dahe/article/details/119142610</a></p>
</blockquote>
<p>现在的返回值优化手段，可以省去了临时对象的产生。</p>
<p>如果没有返回值优化，那么就会有临时对象的产生。</p>
<blockquote>
<p>例子：明白各个初始化的构造函数的调用</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">P</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">P</span>(<span class="hljs-type">const</span> P&amp; p)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = p.a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">P</span>(<span class="hljs-type">int</span> c)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = c;<br>        cout &lt;&lt; <span class="hljs-string">&quot;普通构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function">P <span class="hljs-title">f1</span><span class="hljs-params">(P p)</span></span>&#123;<br>    <span class="hljs-function">P <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    P p = <span class="hljs-number">10</span>; <span class="hljs-comment">// 只输出了普通构造    == P p(10);</span><br>    P m = p; <span class="hljs-comment">// 只输出了拷贝构造     == P m(p);</span><br>    <span class="hljs-function">P <span class="hljs-title">d</span><span class="hljs-params">(m)</span></span>; <span class="hljs-comment">// 只输出了拷贝构造</span><br>    P e = <span class="hljs-built_in">P</span>(); <span class="hljs-comment">//  只输出了默认构造  == P e();</span><br>    P f = <span class="hljs-built_in">P</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 只输出了普通构造 == P f(10);</span><br>    <span class="hljs-comment">// P k = f1(f); // RVO (return value optimization) 优化之后，不会产生临时对象了</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><blockquote>
<p>函数重载的条件</p>
</blockquote>
<ul>
<li>函数名必须相同</li>
<li>函数的参数的顺序、类型、个数满足一个不同就行</li>
</ul>
<p>对于函数的返回值可以相同也可以不同，<strong>但是不能作为函数重载的判断条件</strong>。即不能有函数名相同，参数也相同，只有返回值不同的函数重载</p>
<ul>
<li><strong>C语言不支持函数重载</strong></li>
</ul>
<blockquote>
<p>函数重写</p>
</blockquote>
<p>函数重写是指派生类将基类的名字和参数都相同的虚函数在自己类中进行重新定义，派生类重写的函数必须和父类的对应的虚函数的参数，返回值，函数名称一致。</p>
<blockquote>
<p>重载和重写的区别</p>
</blockquote>
<p>重载一般是函数水平关系体现，而重写是父类和子类垂直关系的体现。重载要求函数名相同，参数的类型、个数、顺序不同，返回值可以相同也可以不同，但是重写必须是子类重写的父类的虚函数，函数名称、参数、返回值全都相同。</p>
<h2 id="volatile、mutable和explicit关键字"><a href="#volatile、mutable和explicit关键字" class="headerlink" title="volatile、mutable和explicit关键字"></a>volatile、mutable和explicit关键字</h2><blockquote>
<p>volatile关键字</p>
</blockquote>
<p>用它来修饰变量，表示修饰的变量不希望编译器对访问该变量的代码进行优化，每次都从这个变量的实际内存中读取内容（有时候会将变量缓存在cpu的寄存器中直接访问）</p>
<p>在多线程中，如果多个线程都对一个变量进行访问，可以将这个变量设置为volatile类型的，每次都是从该变量的实际内存地址进行读取数据而不是读取寄存器中的备份。这个volatile变量修饰的变量能够实现每个线程对其的修改使得别的线程可见。如果不用这个修饰的共享变量，编译器会对一些访问此变量的代码进行优化，可能会将这个变量缓存在cpu的寄存器中，导致自己对这个数据的读取的修改先从寄存器开始，这就会导致实际内存地址的值没有改变，自己线程对此变量的修改没有实现别的线程立即可见。</p>
<blockquote>
<p>mutable关键字</p>
</blockquote>
<p>它和C++中的const意思相反，在一个const修饰的函数中，这个函数是可以访问和修改这个mutable修饰的变量的。</p>
<ul>
<li>在const修饰的函数中，可以修改它修饰的变量</li>
<li>在const修饰的对象时，可以修改它修饰的变量</li>
</ul>
<blockquote>
<p>explicit关键字</p>
</blockquote>
<p>explicit关键字修饰的类的构造函数，是不能发生隐士类型转换的，只能是显示的进行类型转换。</p>
<blockquote>
<p>所谓的隐士类型转换，就是当我们的构造函数自由一个参数的时候，我们用一个这个参数的类型的值去初始化一个对象，这个时候会发生<strong>先调用这个构造函数，然后再调用拷贝构造函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;be invoked&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A a)</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 符合隐式转换规则，自动执行隐式转换，符合拷贝构造函数的调用时机（用实参初始化形参）；最终被转换为func(A(1))的形式。</span><br>    A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 执行了隐式转换，等价于A a(1)；&#x27;=&#x27; 调用了默认拷贝构造函数。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>如果我们用explicit关键字修饰了这个构造函数，就不能够发生隐士类型转换了。</p>
<ul>
<li><strong>explicit关键字只能修饰构造函数，并且构造函数的没有默认值的参数个数为1个</strong></li>
</ul>
<h2 id="const修饰成员函数的本质"><a href="#const修饰成员函数的本质" class="headerlink" title="const修饰成员函数的本质"></a>const修饰成员函数的本质</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>这个本质是const修饰了this指针，this指针本质是一个指针常量，被const修饰后，它就不能改变指向和通过指针改变所指的内容</strong></p>
</blockquote>
<h2 id="C-的string和C的char"><a href="#C-的string和C的char" class="headerlink" title="C++的string和C的char*"></a>C++的string和C的char*</h2><p>C++的string类是继承自basic_string,其实就是对char*的封装，然后增加了容量，长度等属性</p>
<p>string是可以进行动态扩容的，每次扩容都是申请一块比原来空间2倍大的空间，然后将内容复制过去，然后释放原来的空间。</p>
<h2 id="C-函数调用的压栈过程"><a href="#C-函数调用的压栈过程" class="headerlink" title="C++函数调用的压栈过程"></a>C++函数调用的压栈过程</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1134295-ce2aa08820b11888.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>每一个函数在执行的时候，操作系统都会为其在栈空间上维护一个栈帧，栈帧基址存在ebp中，栈顶基址存在esp中，当我们调用一个函数的时候，现在调用函数中从右向左将参数压入栈中，然后接着将eip寄存器中的地址压入到栈中，也就是等会调用完这个函数之后要返回的地址，然后将ebp压入到栈中，然后将ebp更新为esp中的值，形成了新的栈帧，然后eip指向要调用的函数地址，开始执行被调用函数，将临时变量存储在栈中。出栈的时候，就是刚才的逆过程，恢复调用函数的栈帧，将栈中的数据pop到ebp，eip中，恢复调用函数的状态。</p>
<blockquote>
<p>对于虚函数来说</p>
<ul>
<li>先找到this指针，然后获取这个对象的虚函数表指针，找到虚函数表之后，再找到这个函数的地址</li>
</ul>
</blockquote>
<h2 id="移动构造和移动赋值"><a href="#移动构造和移动赋值" class="headerlink" title="移动构造和移动赋值"></a>移动构造和移动赋值</h2><ul>
<li>默认构造函数</li>
<li>拷贝构造函数</li>
<li>移动构造函数（move和右值引用）</li>
<li>普通有参构造函数</li>
</ul>
<blockquote>
<p><strong>什么是移动构造函数</strong></p>
</blockquote>
<p>介绍这个构造函数之前，我们先了解以下C++11新特性移动语义和右值引用的知识</p>
<blockquote>
<p>什么是右值引用</p>
</blockquote>
<p>我们之前说的引用都是左值引用，C++11引入了右值引用的概念，就是给右值取别名。左值引用和右值引用都是给变量其别名，只不过两个取别名的对象特性不同。</p>
<p>【使用】：<code>左值引用是用&amp;，而右值引用使用&amp;&amp;</code></p>
<p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230401204507804.png" srcset="/img/loading.gif" lazyload alt="image-20230401204507804"></p>
<p>举个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a =<span class="hljs-number">10</span>; <span class="hljs-comment">// a是左值，可以取地址和赋值</span><br>    <span class="hljs-type">int</span>&amp; la = a; <span class="hljs-comment">// 左值引用</span><br>    <br>    <span class="hljs-type">int</span> &amp;&amp; ra = <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 右值引用，函数返回的值是一个临时变量，是一个右值</span><br>   <br>&#125;<br></code></pre></td></tr></table></figure>

<p>【总结】：</p>
<ul>
<li><p>左值</p>
<ul>
<li>普通类型的变量，可以取地址</li>
<li><code>const修饰的常量</code>，可以取地址，也是变量 const int&amp; a = 100;</li>
<li>加了const的左值，既可以引用左值，也可以引用右值</li>
</ul>
</li>
<li><p>右值</p>
<ul>
<li>纯右值：基本类型的常量或临时变量，如 a+b，10，20这个字面常量</li>
<li>将亡值：自定义类型的临时对象用完自动析构，如：函数以值的形式返回一个对象</li>
</ul>
</li>
</ul>
<p>【引用是可以取地址的，对于左值引用来说，取得地址就是变量的地址，对于右值引用来说，取的地址也是右值的地址】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">【左值引用不能给右值取别名，右值引用也不能给左值取别名。】<br> 【左值可以通过<span class="hljs-built_in">move</span>()赋值给右值引用，右值可以在左值加上<span class="hljs-type">const</span>赋值给左值引用--&gt; <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a  =<span class="hljs-number">100</span>;】<br><span class="hljs-comment">//  int&amp;&amp; c = a;//右值引用不能给左值取别名</span><br><span class="hljs-comment">//  int&amp; d = add(3, 4);//左值引用不能给右值取别名</span><br>	<span class="hljs-type">int</span>&amp;&amp; e = <span class="hljs-built_in">move</span>(a);<span class="hljs-comment">//当对左值加move的时候可以,这样e就可以改变a的值了</span><br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; f = <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<span class="hljs-comment">//当对引用加const后可以取别名</span><br><br></code></pre></td></tr></table></figure>



<blockquote>
<p>什么是右值引用的移动语义</p>
</blockquote>
<p>【<strong>什么是移动语义？</strong>】</p>
<p><strong><code>移动语义</code> ：就是将一个对象的资源移动到另一个对象中的方式，可以有效的减少拷贝，减少资源的浪费，提高效率。</strong></p>
<p>我们在进行深拷贝的时候，一般对于对象中的指针变量，我们会重新开辟一块空间，然后将指针指向的内容复制过去，然后将这个新内存的地址赋给新的对象的指针。但是如果对于一个临时变量来说，比如函数返回的临时变量，我们使用深拷贝，就会再开辟新的空间，将临时对象的中指针变量指向的内存复制过去。这样就会在操作中占用较多的空间，我们可以直接进行浅拷贝，然后再将临时对象的指针指向NULL，这样在临时对象被析构的时候就不会释放那个空间，也减少了新空间的开辟，提升了效率</p>
<p>下面我们就介绍以下什么是移动构造和移动赋值</p>
<blockquote>
<p>移动构造和移动赋值</p>
</blockquote>
<p>其实就是将上面的移动语义思想应用在构造函数和赋值上面</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;&quot;</span>)<br>		:_str(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>])<br>		, _size(<span class="hljs-number">0</span>)<br>	&#123;<br>		<span class="hljs-built_in">strcpy</span>(_str, str);<br>		_str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>	&#125;<br>	<span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; s)<br>		:_str(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(s._str) + <span class="hljs-number">1</span>])<br>		, _size(s._size)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;深拷贝&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-built_in">strcpy</span>(_str, s._str);<br>	&#125;<br>           <span class="hljs-built_in">String</span>(String&amp;&amp; s)  <span class="hljs-comment">// 移动构造，如果参数是右值的话，就会调用移动构造，而不是调用拷贝构造</span><br>            :_str(s._str)<br>            &#123;<br>                <span class="hljs-comment">// 对于将亡值，内部做移动拷贝</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;移动拷贝&quot;</span> &lt;&lt; endl;<br>                s._str = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>	String&amp; <span class="hljs-keyword">operator</span>=(String&amp; s)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>		&#123;<br>			cout &lt;&lt; <span class="hljs-string">&quot;深拷贝&quot;</span> &lt;&lt; endl;<br>			<span class="hljs-keyword">delete</span> _str;<br>			_str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(s._str) + <span class="hljs-number">1</span>];<br>			<span class="hljs-built_in">strcpy</span>(_str, s._str);<br>			_size = s._size;<br>			_str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>		&#125;<br><br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br>    <br>            String&amp; <span class="hljs-keyword">operator</span>=(String&amp;&amp; s) <span class="hljs-comment">// 移动赋值，如果参数是右值，就会调用移动赋值，不会调用深拷贝赋值</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;移动赋值&quot;</span> &lt;&lt; endl;<br>            _str = s._str;<br>            _size = s._size;<br>            s._str = <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>	~<span class="hljs-built_in">String</span>()<br>	&#123;<br>		<span class="hljs-keyword">delete</span> _str;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">char</span>* _str;<br>	<span class="hljs-type">size_t</span> _size;<br>&#125;;<br><span class="hljs-function">String <span class="hljs-title">func</span><span class="hljs-params">(String&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(str)</span></span>;<br>	<span class="hljs-keyword">return</span> tmp; <span class="hljs-comment">// 这里也是会调用移动构造进行创建临时对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;123&quot;</span>)</span></span>;<span class="hljs-comment">// </span><br>	<span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br>	<span class="hljs-function">String <span class="hljs-title">s3</span><span class="hljs-params">(func(s1))</span></span>;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>【总结：】</p>
<ul>
<li><strong>对于支持深拷贝的类，我们可以提供移动构造和移动赋值操作</strong></li>
<li><strong>这样就可以在参数为右值的时候，通过调用移动构造或移动赋值减少深拷贝带来的额外空间分配和复制操作，提升效率</strong></li>
</ul>
<p><strong>【<code>对于函数返回值的时候是return temp还是return std::move(temp)呢</code>，如下的类型1和类型2】</strong></p>
<p><strong>可以直接参考这篇博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/dreamvyps/article/details/82467608">https://blog.csdn.net/dreamvyps/article/details/82467608</a></strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类型一</span><br><span class="hljs-function">std::string <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> str;   <span class="hljs-comment">// 这里编译器会做优化，也是调用了一次移动构造</span><br>&#125;<br> <br><span class="hljs-comment">// 类型二</span><br><span class="hljs-function">std::string <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str); <span class="hljs-comment">// 这里是自己手动进行将左值改成右值，然后调用了移动构造</span><br>&#125;<br> <br><span class="hljs-comment">// 类型三</span><br><span class="hljs-function">std::string&amp; <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str);<br>&#125;<br> <br><span class="hljs-comment">// 类型四：运行期崩溃</span><br><span class="hljs-function">std::string&amp;&amp; <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Moveable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Moveable</span>():<span class="hljs-built_in">h</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct &quot;</span> &lt;&lt; endl;<br>    &#125;   <br> <br>    ~<span class="hljs-built_in">Moveable</span>() &#123;<br>        <span class="hljs-keyword">delete</span> h;<br>    &#125;   <br>    <br>    <span class="hljs-built_in">Moveable</span>(<span class="hljs-type">const</span> Moveable&amp; m): <span class="hljs-built_in">h</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*m.h)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;   <br> <br>    <span class="hljs-built_in">Moveable</span>(Moveable&amp;&amp; m): <span class="hljs-built_in">h</span>(m.h) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>        m.h = <span class="hljs-literal">nullptr</span>;<br>    &#125;   <br>    <br>    <span class="hljs-type">int</span>* h;<br>&#125;;<br> <br><span class="hljs-function">Moveable <span class="hljs-title">GetTemp</span><span class="hljs-params">()</span> </span>&#123;<br>    Moveable tmp;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    Moveable a = <span class="hljs-built_in">GetTemp</span>(); <span class="hljs-comment">// 我们关闭返回值优化(RVO)，这里会调用一次默认构造函数，两次移动构造函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>还有一种技术是RVO技术，返回值优化技术。对于连续出现拷贝构造函数或者移动构造函数，就会调用一次构造。</p>
<p><code>-fno-elide-constructors</code>使用这个可以关闭RVO技术。</p>
<p>【对于RVO和move的关系】</p>
<ul>
<li>对于return obj<ul>
<li>结果就是调用了一次构造和析构，相当于外部对象直接使用了栈的对象</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Obj</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;construct \n&quot;</span>);<br>    &#125;   <br><br>    ~<span class="hljs-built_in">Obj</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;destructor\n&quot;</span>);<br>    &#125;   <br>    <br>    <span class="hljs-built_in">Obj</span>(<span class="hljs-type">const</span> Obj&amp; o) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;copy constructor\n&quot;</span>);<br>    &#125;    <br>&#125;;<br><br><span class="hljs-function">Obj <span class="hljs-title">ReturnObj</span><span class="hljs-params">()</span> </span>&#123;<br>    Obj obj;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Obj obj = <span class="hljs-built_in">ReturnObj</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>对于return move(obj)<ul>
<li>结果就是先默认构造，然后调用移动构造，然后调用两次析构</li>
<li>使用move强制生成了临时对象，但是只是调用了一次移动构造，</li>
<li>这是因为ROV的结果，如果没有ROV会调用两次移动构造</li>
</ul>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dreamvyps/article/details/97394411?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-97394411-blog-120302300.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-97394411-blog-120302300.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&utm_relevant_index=3">参考博客</a></p>
<blockquote>
<p><strong>move：</strong> 当需要用右值引用引用一个左值时，可以通过move来获得绑定到左值上的右值引⽤。C++11中，std::move()函数位于 头文件中，该函数名字具有迷惑性，它并不搬移任何东西，唯一的功能就是将一个<code>左值强制转化为右值引用</code>，然后实现移动语义。</p>
</blockquote>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><h2 id="什么是一致性哈希"><a href="#什么是一致性哈希" class="headerlink" title="什么是一致性哈希"></a>什么是一致性哈希</h2><blockquote>
<p>普通hash会带来什么问题？</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/120814088">https://blog.csdn.net/a745233700/article/details/120814088</a></p>
</blockquote>
<p>普通hash一般在增加和删除一些节点的时候，对于key的映射关系的影响十分大。</p>
<p>比如我们举一个图片负载均衡缓存中几台服务器中的例子，我们通过普通hash将图片进行hash，然后通过取余，获得这个图片应该存放的位置。如果此时我们将增加一个服务器，那么我们取余的数就变了，之前的映射关系也都没了。如果一台服务器宕机了，我们的余数也发生了变化，这样就会导致映射关系发生变化</p>
<p>如果想要恢复映射关系，必须将所有的数据都重新映射。</p>
<blockquote>
<p>一致性hash</p>
</blockquote>
<p>一致性hash就是为了解决在增加或者减少一个节点的时候，能够尽可能的减少key的映射关系的改变</p>
<p>一致性hash算法将整个hash值空间按照顺时针方向组织成一个虚拟的圆环，然后对节点进行hash。比如我们继续举这个服务器的例子。我们根据服务器的ip进行hash，然后得到在环上的位置。</p>
<p>然后我们对每个图片hash取余，然后得到在hash环上的位置，得到之后，我们就顺时针的进行在hash环上找，找到第一个遇到的服务器对应的位置，然后就将这个放到指定的服务器中。<strong>如果有一个服务器宕机了，我们可以重新将这些图片hash，然后继续顺时针的找到下一个可以放的服务器，这样我们就不用更改之前已经映射完成的图片了。</strong>如果我们增加了一个节点，也是一样。不用像普通hash那样所有的值都rehash一下。</p>
<p>【总结】：<strong>一致性hash的优点就是在增加或者减少桶节点的时候，能够尽可能少的减少对已有映射关系的改变。</strong></p>
<blockquote>
<p>hash环的缺点：hash环的倾斜</p>
</blockquote>
<p>就是节点的分布在hash环上不均匀，节点较少的时候，出现在hash环上局部聚集分布现象，这种现象就是hash环的倾斜。<strong>导致大量的数据存在了一个节点中</strong>。</p>
<p>因此引入虚拟节点，就是在hash环上，让一个实际的节点对应在hash环上多个位置，这样就能够使得缓存被均匀分布的概率大了些。</p>
<h2 id="C-从代码到执行经历什么"><a href="#C-从代码到执行经历什么" class="headerlink" title="C++从代码到执行经历什么"></a>C++从代码到执行经历什么</h2><blockquote>
<p>源代码到可执行程序中间要经历什么步骤</p>
</blockquote>
<ul>
<li>预处理</li>
<li>编译</li>
<li>汇编</li>
<li>链接</li>
</ul>
<p>一般一个C/C++程序到可执行程序都要经历这几个阶段</p>
<blockquote>
<p>预处理：</p>
<ul>
<li>将所有的宏定义指令进行文本替换操作</li>
<li>对条件编译指令进行处理</li>
<li>处理所有的include指令，将文件内容复制到它所在的地方。</li>
<li>删除所有的注释</li>
<li>添加行号和文件标识，方便调试和编译错误时显示行号</li>
</ul>
</blockquote>
<blockquote>
<p>编译：</p>
<ul>
<li>将预处理完成的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件</li>
<li>优化包括循环优化，还有就是利用寄存器存放有关变量的值进行访问优化，因为寄存器的速度远大于内存的访问速度。但是如果假如volatile不会产生访问优化。</li>
</ul>
</blockquote>
<blockquote>
<p>汇编：</p>
<ul>
<li>将汇编代码转换成目标机器指令的过程，最总得到一个目标文件。</li>
<li>目标文件中至少有两个段，代码段和数据段</li>
</ul>
<p>在unix中，主要有三种类型的目标文件</p>
<ul>
<li>可重定位文件：这个文件中包含了适合其他的目标文件链接来创建一个可执行或者共享的目标文件的代码和数据</li>
<li>共享的目标文件：这种文件存放了适合于在两种上下文里链接的代码和数据。第一种事链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。</li>
<li>可执行文件：它是一个可以被操作系统识别和当作一个进程来运行的文件</li>
</ul>
</blockquote>
<blockquote>
<p>链接：</p>
<p>我们单独来说一下这个链接</p>
</blockquote>
<h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><h2 id="几种典型的锁"><a href="#几种典型的锁" class="headerlink" title="几种典型的锁"></a>几种典型的锁</h2><blockquote>
<p>互斥锁：互斥锁保证一次只能有一个线程获取互斥锁，获取锁的线程才能执行某些动作，即对共享变量进行修改。</p>
<ul>
<li>一个线程在抢夺互斥锁的时候，如果没有获取到互斥锁，就会放弃CPU进入睡眠状态，等到锁的状态发生改变后，操作系统调度到这个线程进而获取这个互斥锁。</li>
<li>常用的互斥锁 mutex</li>
</ul>
</blockquote>
<blockquote>
<p>条件变量：condition_valuable</p>
<ul>
<li>条件变量一般配合互斥锁使用，用来实现多线程之间的同步效果</li>
<li>当一个线程不满足一定条件的时候，会使用条件变量来阻塞这个线程，释放互斥锁，而不是一直循环的判断条件是否满足</li>
<li>当一个线程更改了条件之后就会利用这个条件变量来唤醒正在阻塞的线程</li>
</ul>
</blockquote>
<blockquote>
<p>自旋锁：</p>
<ul>
<li>自旋锁就是在互斥锁锁的基础上，如果一个线程没有获取到这个锁，那么就会一直循环的去申请获取，一直到获取到锁或者线程的时间片使用完毕</li>
<li>一般可以适当的自旋有利于锁的获取。</li>
</ul>
</blockquote>
<blockquote>
<p>信号量和互斥锁和条件变量的区别</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_53762042/article/details/119704477">https://blog.csdn.net/weixin_53762042/article/details/119704477</a></p>
</blockquote>
<p>【互斥锁】</p>
<ul>
<li>他是为了保护共享资源某一时刻只能被一个线程操作，一个线程获取了互斥锁，另外的线程就无法获取了，只有当这个线程释放这个锁，其他线程才有机会获取，并且互斥锁的释放只能由获取它的线程释放。</li>
</ul>
<p>【信号量】</p>
<ul>
<li>信号量更多的是用于线程或进程间的同步操作，信号量的本质是一个非负的整数计数器，用来控制对公共资源的访问。只要信号量大于0，其他的线程就可以进行操作其控制的共享资源。</li>
</ul>
<p>信号量可以用来互斥也可以用来同步操作；对信号量+1可以称为P操作，对信号量-1可以称为V操作</p>
<ul>
<li>互斥操作：<ul>
<li><strong>一般只设置一个信号量</strong>，相当于互斥锁的加强版，当信号量只取0和1的时候，就相当于互斥锁</li>
<li>信号量的获取和释放都由一个线程完成</li>
</ul>
</li>
<li>同步操作<ul>
<li><strong>一般设置多个信号量</strong>，在一个线程中我们可以对一个信号量进行P操作，然后对另一个信号量进行V操作，这样就能使得其他正在等待第二个信号量的线程能够获取信号量进行P操作</li>
<li>一个线程可以对一个信号量进行P操作，对另一个信号量进行V操作</li>
</ul>
</li>
</ul>
<p>【条件变量】</p>
<ul>
<li>条件变量一般配合互斥锁使用，实现线程同步的功能，和信号量的功能基本一致，但是条件变量可以唤醒所有正在等待的线程’</li>
<li>条件变量一般是一个线程因为某个条件不成立会挂起这个线程，然后等待别的线程修改条件使得条件成立并唤醒等待的线程。条件的检测是在互斥锁的保护下进行的，当条件为假的时候就会挂起这个线程处于阻塞状态，然后等待别的线程修改条件成立并唤醒自己，获取互斥锁重新判断条件。</li>
</ul>
<p>c++中通过互斥锁和条件变量可以实现和C中的信号量相同的作用。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/c/">#c++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++基础知识</div>
      <div>http://example.com/2023/04/13/C++基础知识/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bollcode</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月13日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/04/21/%E4%B8%AD%E6%96%AD/" title="linux中断">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">linux中断</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" title="网络协议">
                        <span class="hidden-mobile">网络协议</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
