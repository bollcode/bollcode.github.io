<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>linux内核锁实现</title>
    <link href="/2023/06/13/%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/06/13/%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>参考：</p><ul><li><a href="https://tupelo-shen.github.io/2020/04/12/Linux%E5%86%85%E6%A0%B833-%E4%BF%A1%E5%8F%B7%E9%87%8F/">https://tupelo-shen.github.io/2020/04/12/Linux%E5%86%85%E6%A0%B833-%E4%BF%A1%E5%8F%B7%E9%87%8F/</a></li><li><a href="https://blog.csdn.net/u012603457/article/details/52971894">https://blog.csdn.net/u012603457/article/details/52971894</a></li><li><a href="https://www.freesion.com/article/29121050058/">https://www.freesion.com/article/29121050058/</a></li><li><a href="https://blog.51cto.com/ab3813/1764509">https://blog.51cto.com/ab3813/1764509</a></li></ul><p>linux提供了两种信号量</p><ul><li>一个是内核信号量</li><li>一个是用户态使用的信号量（遵循<code>System V IPC</code>信号量要求）</li></ul><p>这里我只讲linux内核中的信号量。</p><h3 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h3><p>信号量在linux中是一个结构变量，其源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore</span> &#123;</span><br>    <span class="hljs-type">raw_spinlock_t</span>      lock;  <span class="hljs-comment">// 用来保护这个等待队列</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        count;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">wait_list</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="信号量机制："><a href="#信号量机制：" class="headerlink" title="信号量机制："></a>信号量机制：</h4><p>信号量是一种同步机制，用于对资源的保护，和互斥锁相似，但是他们的实现机制和用处是不一样的。信号量使用的数据结构是struct semaphore，包含三个数据成员：count是共享计数值、lock保护信号量的spinlock锁 、wait_list是当前信号量的等待队列。</p><p>信号量中有一个共享计数值，当其小于0的时候，表示现在资源全被占用了，此时需要将想获取资源的进程放到他的等待队列中，处于休眠等待（这个状态不能中断），当某个进程释放信号量的时候，就会唤醒等待队列中的第一个进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">down(sem);<br>...临界区...<br>up(sem);<br></code></pre></td></tr></table></figure><blockquote><p>对于信号量的减少和增加必须是原子操作，不然就会导致信号量出现错误，为保证信号量的一致性，需要原子操作。</p></blockquote><ul><li>对于单核来说：原子操作就是一个指令的执行，比如inc，可以实现对信号量count的原子增加</li><li><strong>对于多核来说：有时候一条指令涉及多个寄存器等的操作，这个时候一条指令不能保证对一个变量（一块内存）的原子操作（比如inc需要先将变量读入寄存器，再写入寄存器，再写入内存）。采用了<code>lock</code>指令，这个指令可以对总线加锁，导致只有一个cpu使用总线。</strong></li></ul><h4 id="down操作"><a href="#down操作" class="headerlink" title="down操作"></a>down操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">    <br><span class="hljs-type">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> semaphore *sem)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);<br>    <span class="hljs-keyword">if</span> (likely(sem-&gt;count &gt; <span class="hljs-number">0</span>))<br>        sem-&gt;count--;<br>    <span class="hljs-keyword">else</span><br>        __down(sem);<br>    raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);<br>&#125;<br><span class="hljs-comment">// 如下：</span><br>down:<br>    movl $sem-&gt;count,%ecx<br>    lock; decl (%ecx);<br>    jns <span class="hljs-number">1f</span><br>    lea %ecx, %eax<br>    pushl %edx<br>    pushl %ecx<br>    call __down<br>    popl %ecx<br>    popl %edx<br><span class="hljs-number">1</span>:<br></code></pre></td></tr></table></figure><p>这个down操作，就是将sem-&gt;count进行减一操作，为了保证这个减一操作是原子操作，因此使用了<code>lock</code>指令。如果此时信号量小于0，说明获取信号量失败，需要进入等待队列，此时会调用<code>__down()</code>函数,对于这个__down()函数，后面被down_interruptible()函数代替了，这个函数就是将这个获取信号量失败的进程放到等待队列中，并且使用信号量中lock变量来保证对等待队列操作的安全性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> noinline <span class="hljs-type">void</span> __sched __down(<span class="hljs-keyword">struct</span> semaphore *sem)<br>&#123;<br>    __down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> __sched __down_common(<span class="hljs-keyword">struct</span> semaphore *sem, <span class="hljs-type">long</span> state, <span class="hljs-type">long</span> timeout)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span> =</span> current;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">semaphore_waiter</span> <span class="hljs-title">waiter</span>;</span><br> <br>    list_add_tail(&amp;waiter.<span class="hljs-built_in">list</span>, &amp;sem-&gt;wait_list);<br>    waiter.task = task;<br>    waiter.up = <span class="hljs-literal">false</span>;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (signal_pending_state(state, task))<br>            <span class="hljs-keyword">goto</span> interrupted;<br>        <span class="hljs-keyword">if</span> (unlikely(timeout &lt;= <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">goto</span> timed_out;<br>        __set_task_state(task, state);<br>        raw_spin_unlock_irq(&amp;sem-&gt;lock);<br>        timeout = schedule_timeout(timeout);<br>        raw_spin_lock_irq(&amp;sem-&gt;lock);<br>        <span class="hljs-keyword">if</span> (waiter.up)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br> timed_out:<br>    list_del(&amp;waiter.<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> -ETIME;<br> <br> interrupted:<br>    list_del(&amp;waiter.<span class="hljs-built_in">list</span>);<br>    <span class="hljs-keyword">return</span> -EINTR;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="up操作"><a href="#up操作" class="headerlink" title="up操作"></a>up操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">movl $sem-&gt;count,%ecx<br>    lock; incl (%ecx)<br>    jg <span class="hljs-number">1f</span>               <span class="hljs-comment">// 标号1后面的f字符表示向前跳转，如果是b表示向后跳转</span><br>    lea %ecx,%eax<br>    pushl %edx<br>    pushl %ecx<br>    call __up<br>    popl %ecx<br>    popl %edx<br><span class="hljs-number">1</span>:·<br></code></pre></td></tr></table></figure><p>这个up操作，就是将sem-&gt;count进行加一操作，这个加一操作是原子性的。并且在加1操作之后，如果此时count小于0，表示现在队列中有进程等待，需要进行唤醒操作，调用__up()函数，这个函数就会将等待队列中的第一个进程进行唤醒，这个过程也是使用lock变量进行保护的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__((regparm(<span class="hljs-number">3</span>))) <span class="hljs-type">void</span> __up(<span class="hljs-keyword">struct</span> semaphore *sem)<br>&#123;<br>    wake_up(&amp;sem-&gt;wait);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p><a href="https://tupelo-shen.github.io/2020/04/05/Linux%E5%86%85%E6%A0%B828-%E8%87%AA%E6%97%8B%E9%94%81/">https://tupelo-shen.github.io/2020/04/05/Linux%E5%86%85%E6%A0%B828-%E8%87%AA%E6%97%8B%E9%94%81/</a></p><blockquote><p>自旋锁的思想：自旋锁的概念比较简单，就是加锁失败后就会一直处于忙等待状态，就是会一直去请求锁，此时cpu处于一直运行状态。</p><p>自旋锁主要适用于多CPU中，并且自旋锁锁住的临界区足够小，没必要将进程休眠了，也就是获得自旋锁的进程很快就释放了锁。</p></blockquote><h3 id="自旋锁结构"><a href="#自旋锁结构" class="headerlink" title="自旋锁结构"></a>自旋锁结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_spinlock</span> &#123;</span><br>    <span class="hljs-type">arch_spinlock_t</span> raw_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> break_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ...<br>&#125; <span class="hljs-type">raw_spinlock_t</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_spinlock</span> <span class="hljs-title">rlock</span>;</span><br>        ...<br>    &#125;;<br>&#125; <span class="hljs-type">spinlock_t</span>;<br></code></pre></td></tr></table></figure><p>spinlock_t主要使用了 raw_spinlock结构，这个结构中</p><ul><li>raw_lock 表示自旋锁的状态，依赖于具体的架构实现，为1时表示可以获取锁，为0时不可获取锁</li><li>break_lock表示进程正在忙等待锁</li></ul><h3 id="锁的操作"><a href="#锁的操作" class="headerlink" title="锁的操作"></a>锁的操作</h3><h4 id="spin-lock-上锁操作"><a href="#spin-lock-上锁操作" class="headerlink" title="spin_lock()上锁操作"></a>spin_lock()上锁操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">spin_lock</span><span class="hljs-params">(<span class="hljs-type">spinlock_t</span> *lock)</span><br>&#123;<br>    spin_lock(&amp;lock-&gt;rlock);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>spin_lock(&amp;lock-&gt;rlock)</code>是一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> spin_lock(lock) _spin_lock(lock)</span><br></code></pre></td></tr></table></figure><p>_spin_lock(lock)这个函数有两个版本：</p><ul><li>一个时UP单核</li><li>一个是SMP多核</li></ul><p>我们这里只看多核的：</p><h4 id="spin-lock-lock-函数"><a href="#spin-lock-lock-函数" class="headerlink" title="_spin_lock(lock)函数"></a><strong><code>_spin_lock(lock)</code>函数</strong></h4><p>这个函数其实就是真正的上锁操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> _spin_lock(<span class="hljs-type">raw_spinlock_t</span> *lock)<br>&#123;<br>    <span class="hljs-comment">//禁止抢占</span><br>    preempt_disable();<br>    <span class="hljs-comment">//这个函数在没有定义自旋锁调试的时候是空函数，我们不去管它</span><br>    spin_acquire(&amp;lock-&gt;dep_map, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _RET_IP_);<br>    <span class="hljs-comment">//相当于_raw_spin_lock(lock)</span><br>    LOCK_CONTENDED(lock, _raw_spin_trylock, _raw_spin_lock);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>首先会调用preempt_disable()函数，这个函数是为禁止内核抢占的</strong>。</p><p><a href="https://blog.csdn.net/kasalyn/article/details/11473885">https://blog.csdn.net/kasalyn/article/details/11473885</a></p><ul><li>主要是防止出现当一个进程获得锁的时候，另一个进程获取CPU的执行权，也想获取锁，导致死锁现象。</li></ul><p><strong>LOCK_CONTENDED是一个通用的加锁流程，</strong></p><ul><li><pre><code class="c">#define LOCK_CONTENDED(_lock, try, lock) \    lock(_lock)相当于： _raw_spin_lock（lock）；</code></pre></li><li><p>~~~c<br>static inline void __raw_spin_lock(raw_spinlock_t *lock)<br>{</p><pre><code class="hljs">asm volatile(&quot;\n1:\t&quot;         //原子减，如果不为负，跳转到3f，3f后面没有任何指令，即为退出         // 这里如果不为原子操作，那么就会使得多个cpu同时获取锁         LOCK_PREFIX &quot; ; decb %0\n\t&quot;         &quot;jns 3f\n&quot;         &quot;2:\t&quot;         &quot;rep;nop\n\t&quot;           //比较0与lock-&gt;slock的值,如果lock-&gt;slock不大于0，跳转到标号2，即继续重复执行nop         &quot;cmpb $0,%0\n\t&quot;         &quot;jle 2b\n\t&quot;             //如果lock-&gt;slock大于0，跳转到标号1，重新判断锁的slock成员         &quot;jmp 1b\n&quot;         &quot;3:\n\t&quot;         : &quot;+m&quot; (lock-&gt;slock) : : &quot;memory&quot;);</code></pre><p>}</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br>- 其上面的意思和下面相似：<br><br>~~~c<br><span class="hljs-keyword">static</span> inline <span class="hljs-keyword">void</span> __raw_spin_lock(raw_spinlock_t *<span class="hljs-keyword">lock</span>)<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(--<span class="hljs-keyword">lock</span>-&gt;slock == <span class="hljs-number">0</span>) <span class="hljs-comment">// 汇编代码中有lock指令前缀，此操作是原子的</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span>((<span class="hljs-built_in">int</span>)<span class="hljs-keyword">lock</span>-&gt;slock &lt;= <span class="hljs-number">0</span>)&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>主要就是对lock进行原子减一操作，然后判断是否获取到自旋锁，如果没有获取到自旋锁就忙等。</p></blockquote><h3 id="spin-unlock-解锁操作"><a href="#spin-unlock-解锁操作" class="headerlink" title="spin_unlock() 解锁操作"></a>spin_unlock() 解锁操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> spin_unlock(lock)       _spin_unlock(lock)</span><br></code></pre></td></tr></table></figure><p>解锁操作源码如下：</p><p><code>_spin_unlock(lock)</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __lockfunc _spin_unlock(<span class="hljs-type">spinlock_t</span> *lock)<br>&#123;<br>    _raw_spin_unlock(lock); <span class="hljs-comment">// 释放锁</span><br>    preempt_enable(); <span class="hljs-comment">// 允许内核抢占</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta"># <span class="hljs-keyword">define</span> _raw_spin_unlock(lock)     __raw_spin_unlock(&amp;(lock)-&gt;raw_lock)</span><br></code></pre></td></tr></table></figure><p><code> __raw_spin_unlock(&amp;(lock)-&gt;raw_lock)</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __raw_spin_unlock(<span class="hljs-type">raw_spinlock_t</span> *lock)<br>&#123;<br>    <span class="hljs-comment">// 其实就是将锁变量设置为1，因为自旋锁只有两种状态0和1</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movb $1,%0&quot;</span> : <span class="hljs-string">&quot;+m&quot;</span> (lock-&gt;slock) :: <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上我们就介绍了基本的linux内核自旋锁原理，当然还有很多关于自旋锁的操作，我们这里没讲，后面再进行详细补充。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>在linux中，互斥锁是一个睡眠锁，获取不到则进程就会睡眠，并且引发调度，互斥锁可以使用信号量实现，也可以使用自旋锁来实现，下面将讲基于自旋锁实现的互斥量的方式。</p><p><a href="https://blog.csdn.net/qq_41598937/article/details/129652105">https://blog.csdn.net/qq_41598937/article/details/129652105</a></p><p><a href="https://zhuanlan.zhihu.com/p/563710092">https://zhuanlan.zhihu.com/p/563710092</a></p><p><a href="https://blog.csdn.net/weixin_43836778/article/details/124613559?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_43836778/article/details/124613559?spm=1001.2014.3001.5502</a></p><p><a href="https://www.jianshu.com/p/a7ddb2998b3b">https://www.jianshu.com/p/a7ddb2998b3b</a></p><h3 id="互斥锁结构"><a href="#互斥锁结构" class="headerlink" title="互斥锁结构"></a>互斥锁结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> &#123;</span><br>   <span class="hljs-type">atomic_t</span>  count; <span class="hljs-comment">//引用计数器,1: 所可以利用,小于等于0：该锁已被获取，需要等待</span><br>   <span class="hljs-type">spinlock_t</span>  wait_lock;<span class="hljs-comment">//自旋锁类型，保证多cpu下，对等待队列访问是安全的。</span><br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">wait_list</span>;</span> <span class="hljs-comment">//等待队列，如果该锁被获取，任务将挂在此队列上，等待调度。</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><ul><li>其中count是一个原子变量，对于他的加减都是原子操作，在x86上的原理就是lock指令和xchg指令保证的。等会我们就看一下关于这个atomic_t变量的原子操作源码。</li><li>对于wait_lock是用来保护多cpu下的wait_list的</li></ul><h3 id="上锁解锁操作"><a href="#上锁解锁操作" class="headerlink" title="上锁解锁操作"></a>上锁解锁操作</h3><blockquote><p>上锁</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __sched <span class="hljs-title function_">mutex_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> mutex *lock)</span><br>&#123;<br>    might_sleep();<br><br>    <span class="hljs-keyword">if</span> (!__mutex_trylock_fast(lock))<br>        __mutex_lock_slowpath(lock);<br>&#125;<br>EXPORT_SYMBOL(mutex_lock);<br></code></pre></td></tr></table></figure><p><code>__mutex_trylock_fast</code>这个用来进行加锁操作的，如果加锁失败就会进入<code>__mutex_lock_slowpath(lock)</code>;这个函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> noinline <span class="hljs-type">void</span> __sched<br>__mutex_lock_slowpath(<span class="hljs-keyword">struct</span> mutex *lock)<br>&#123;<br>    __mutex_lock(lock, TASK_UNINTERRUPTIBLE, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, _RET_IP_);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __sched<br>__mutex_lock(<span class="hljs-keyword">struct</span> mutex *lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> state, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> subclass,<br>         <span class="hljs-keyword">struct</span> lockdep_map *nest_lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip)<br>&#123;<br><span class="hljs-keyword">return</span> __mutex_lock_common(lock, state, subclass, nest_lock, ip, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>会调用一个 <code>__mutex_lock_common(lock, state, subclass, nest_lock, ip, NULL, false)</code>函数，这个函数是互斥锁加锁的核心函数。</p><ul><li>首先会先关闭这个内核抢占preempt_disable，然后多次尝试获取锁，如果获取不到锁就会进入到等待队列中睡眠，然后调度其他的进程工作。</li><li>然后获取这个wait_list的自旋锁，防止多个cpu同时操作这个等待队列</li><li>atomic_xchg(&amp;lock-&gt;count, 0) == 1，atomic_xchg是将lock-&gt;count和0进行交换，并且返回之前的值，如果之前的值为1说明上锁成功，如果为0，上锁失败。对于atomic_xchg这个函数是封装了原子操作的。我们等会看一下它的源码，在x86下通过lock指令和xchg指令实现的。</li><li>如果上锁成功，就会将自己从等待进程中删除，然后释放自旋锁，打开抢占。</li><li>如果上锁失败，就会将自己放入到等待队列中，更改进程状态，释放自旋锁，然后自动释放cpu使用权，并打开抢占等操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">int</span> __sched<br>__mutex_lock_common(<span class="hljs-keyword">struct</span> mutex *lock, <span class="hljs-type">long</span> state, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> subclass,<br>            <span class="hljs-keyword">struct</span> lockdep_map *nest_lock, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ip, <br>            <span class="hljs-keyword">struct</span> ww_acquire_ctx *ww_ctx, <span class="hljs-type">const</span> <span class="hljs-type">bool</span> use_ww_ctx)<br>&#123;  <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">task</span> =</span> current;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex_waiter</span> <span class="hljs-title">waiter</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br>    <span class="hljs-type">int</span> ret;<br><br>    preempt_disable(); <span class="hljs-comment">// 上锁前，关闭抢占，防止出现死锁</span><br>    mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="hljs-number">0</span>, nest_lock, ip);<br>    spin_lock_mutex(&amp;lock-&gt;wait_lock, flags); <span class="hljs-comment">// 加锁，操作wait队列</span><br><br>    <span class="hljs-comment">/* once more, can we acquire the lock? */</span><br>    <span class="hljs-keyword">if</span> (MUTEX_SHOW_NO_WAITER(lock) &amp;&amp; (<span class="hljs-type">atomic_xchg</span>(&amp;lock-&gt;count, <span class="hljs-number">0</span>) == <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">goto</span> skip_wait; <span class="hljs-comment">// 成功说明获取到锁了，则不用执行wait队列的操作了</span><br><br>    debug_mutex_lock_common(lock, &amp;waiter);<br>    debug_mutex_add_waiter(lock, &amp;waiter, task_thread_info(task));<br><br>    <span class="hljs-comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span><br>    list_add_tail(&amp;waiter.<span class="hljs-built_in">list</span>, &amp;lock-&gt;wait_list);<br>    waiter.task = task;<br><br>    lock_contended(&amp;lock-&gt;dep_map, ip);<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Lets try to take the lock again - this is needed even if</span><br><span class="hljs-comment">         * we get here for the first time (shortly after failing to</span><br><span class="hljs-comment">         * acquire the lock), to make sure that we get a wakeup once</span><br><span class="hljs-comment">         * it&#x27;s unlocked. Later on, if we sleep, this is the</span><br><span class="hljs-comment">         * operation that gives us the lock. We xchg it to -1, so</span><br><span class="hljs-comment">         * that when we release the lock, we properly wake up the</span><br><span class="hljs-comment">         * other waiters:</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (MUTEX_SHOW_NO_WAITER(lock) &amp;&amp;<br>            (<span class="hljs-type">atomic_xchg</span>(&amp;lock-&gt;count, <span class="hljs-number">-1</span>) == <span class="hljs-number">1</span>)) <span class="hljs-comment">// 唤醒后再次尝试拿锁</span><br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * got a signal? (This code gets eliminated in the</span><br><span class="hljs-comment">         * TASK_UNINTERRUPTIBLE case.)</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;<br>            ret = -EINTR;  <br>            <span class="hljs-keyword">goto</span> err;<br>        &#125;<br>       <span class="hljs-comment">// 设置进程状态</span><br>        __set_task_state(task, state);<br>       <span class="hljs-comment">/*do&#x27;t get the lock, go to sleep: */</span><br>       spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);<br>       schedule_preempt_disabled();<br>       spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);<br>&#125;<br>   <span class="hljs-comment">// 已经获取到锁了，等待队列里删除自己</span><br>   mutex_remove_waiter(lock, &amp;waiter, current_thread_info());<br>    <span class="hljs-comment">/* set it to 0 if there are no waiters left: */</span><br>    <span class="hljs-keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))<br>        <span class="hljs-type">atomic_set</span>(&amp;lock-&gt;count, <span class="hljs-number">0</span>);<br>    debug_mutex_free_waiter(&amp;waiter);<br><br>skip_wait:<br>    <span class="hljs-comment">/* got the lock - cleanup and rejoice! */</span><br>    lock_acquired(&amp;lock-&gt;dep_map, ip);<br>    mutex_set_owner(lock);<br>    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);<br>    <span class="hljs-comment">// 打开抢占</span><br>    preempt_enable();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>err:<br>    mutex_remove_waiter(lock, &amp;waiter, task_thread_info(task));<br>    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);<br>    debug_mutex_free_waiter(&amp;waiter);<br>    mutex_release(&amp;lock-&gt;dep_map, <span class="hljs-number">1</span>, ip);<br>    preempt_enable();<br>    <span class="hljs-keyword">return</span> ret;<br></code></pre></td></tr></table></figure><blockquote><p>解锁：</p></blockquote><p>基本思想就是将count原子加1，如大于0，结束，如果不大于0，就跳转到__mutex_unlock_slowpath()</p><p>函数，这个函数会将等待队列中的第一个进程唤醒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs asm">#define __mutex_fastpath_unlock(count, fail_fn)         \<br>do &#123;                                \<br>    unsigned int dummy;                 \<br>                                \<br>    typecheck(atomic_t *, count);               \<br>    typecheck_fn(void (*)(atomic_t *), fail_fn);        \<br>                                \<br>    asm volatile(LOCK_PREFIX &quot;   incl (%%eax)\n&quot;        \<br>             &quot;   jg 1f\n&quot;               \<br>             &quot;   call &quot; #fail_fn &quot;\n&quot;           \<br>             &quot;1:\n&quot;                 \<br>             : &quot;=a&quot; (dummy)             \<br>             : &quot;a&quot; (count)              \<br>             : &quot;memory&quot;, &quot;ecx&quot;, &quot;edx&quot;);         \<br>&#125; while (0)<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">  __visible <span class="hljs-type">void</span><br> __mutex_unlock_slowpath(<span class="hljs-type">atomic_t</span> *lock_count)<br> &#123;<br>     __mutex_unlock_common_slowpath(lock_count, <span class="hljs-number">1</span>);<br> &#125;<br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>__mutex_unlock_common_slowpath(<span class="hljs-type">atomic_t</span> *lock_count, <span class="hljs-type">int</span> nested)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex</span> *<span class="hljs-title">lock</span> =</span> container_of(lock_count, <span class="hljs-keyword">struct</span> mutex, count);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><br>    <span class="hljs-comment">/*  </span><br><span class="hljs-comment">     * some architectures leave the lock unlocked in the fastpath failure</span><br><span class="hljs-comment">     * case, others need to leave it locked. In the later case we have to</span><br><span class="hljs-comment">     * unlock it here</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (__mutex_slowpath_needs_to_unlock())<br>        <span class="hljs-type">atomic_set</span>(&amp;lock-&gt;count, <span class="hljs-number">1</span>); <br><br>    spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);<br>    mutex_release(&amp;lock-&gt;dep_map, nested, _RET_IP_);<br>    debug_mutex_unlock(lock);<br><br>    <span class="hljs-keyword">if</span> (!list_empty(&amp;lock-&gt;wait_list)) &#123;<br>        <span class="hljs-comment">/* get the first entry from the wait-list: */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mutex_waiter</span> *<span class="hljs-title">waiter</span> =</span><br>                list_entry(lock-&gt;wait_list.next,<br>                       <span class="hljs-keyword">struct</span> mutex_waiter, <span class="hljs-built_in">list</span>);<br><br>        debug_mutex_wake_waiter(lock, waiter);<br><br>        wake_up_process(waiter-&gt;task);<br>    &#125;   <br><br>    spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="atomic-xchg-函数"><a href="#atomic-xchg-函数" class="headerlink" title="atomic_xchg()函数"></a>atomic_xchg()函数</h3><p><strong>atomic_xchg()函数是将新值存入到atomic_t类型的变量，然后将变量的旧值返回，它是基于<code>xchg</code>指令实现的</strong></p><p><a href="https://blog.csdn.net/qb_2008/article/details/6840808">https://blog.csdn.net/qb_2008/article/details/6840808</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title function_">atomic_xchg</span><span class="hljs-params">(<span class="hljs-type">atomic_t</span> *v, <span class="hljs-type">int</span> new)</span><br>&#123;<br><span class="hljs-keyword">return</span> xchg(&amp;v-&gt;counter, new);<br>&#125;<br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xchg(ptr, v)\</span><br><span class="hljs-meta">((__typeof__(*(ptr)))__xchg((unsigned long)(v), (ptr), sizeof(*(ptr))))</span><br> <br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __xchg(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x, <span class="hljs-keyword">volatile</span> <span class="hljs-type">void</span> *ptr,<br>   <span class="hljs-type">int</span> size)<br>&#123;<br><span class="hljs-keyword">switch</span> (size) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;xchgb %b0,%1&quot;</span></span><br><span class="hljs-params">     : <span class="hljs-string">&quot;=q&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;m&quot;</span> (*__xg(ptr)), <span class="hljs-string">&quot;0&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;xchgw %w0,%1&quot;</span></span><br><span class="hljs-params">     : <span class="hljs-string">&quot;=r&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;m&quot;</span> (*__xg(ptr)), <span class="hljs-string">&quot;0&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;xchgl %k0,%1&quot;</span></span><br><span class="hljs-params">     : <span class="hljs-string">&quot;=r&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;m&quot;</span> (*__xg(ptr)), <span class="hljs-string">&quot;0&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;xchgq %0,%1&quot;</span></span><br><span class="hljs-params">     : <span class="hljs-string">&quot;=r&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;m&quot;</span> (*__xg(ptr)), <span class="hljs-string">&quot;0&quot;</span> (x)</span><br><span class="hljs-params">     : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于atomic_t类型的变量的其他的操作函数，大部分使用的是<code>lock</code>指令实现的</strong>,而对于arm架构来说，他们的原子操作，基本上是采用<code>ldrex  </code>和 <code>strex   </code>这两个指令实现的。</p><p><a href="http://svip.hehjyx.com/blog/ATOMIC_atomic_xchg/">http://svip.hehjyx.com/blog/ATOMIC_atomic_xchg/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进程调度</title>
    <link href="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <url>/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><p>一个cpu在同一个时刻只能运行一个进程，如果内存中存在多个进程，那么cpu以怎样的顺序来运行这些进程呢？这个工作是由操作系统控制的，操作系统应采用怎么策略来调度这些进程在cpu上执行呢？下面我们将介绍几个进程调度的算法。</p><h2 id="进程分类"><a href="#进程分类" class="headerlink" title="进程分类"></a>进程分类</h2><p>linux将进程分为实时进程和非实时进程，其中非实时进程进一步划分为交互式进程和批处理进程</p><ul><li><strong>实时进程</strong>：实时进程是指进程响应时间尽可能的短，以达到实时的效果，可以根据优先级抢占或阻塞。典型的实时进程有音视频控制，自动设备实时控制等。</li><li><strong>非实时进程</strong>：<ul><li><strong>交互式进程</strong>：主要与用户进行交互，等待用户的键盘或鼠标输入。典型的交互式进程是shell、文本编辑和图形应用程序。</li><li><strong>批处理进程</strong>：运行在后台，不和用户交互。由于不需要与用户实时交互响应，所以经常受到调度程序的慢待。典型的批处理进程是编译程序、数据库搜索等。</li></ul></li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p><a href="https://www.xiaolincoding.com/os/4_process/process_base.html#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">【参考博文】</a></p><h3 id="FIFO-先来先服务算法"><a href="#FIFO-先来先服务算法" class="headerlink" title="FIFO 先来先服务算法"></a>FIFO 先来先服务算法</h3><p>每次从就绪队列中找出最先进入队列的进程然后来运行，知道这个进程运行完之后才会选择下一个进程运行，但是这个会造成一个单个进程长时间占用cpu，导致其他进程要等待较长时间。</p><p><img src="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/24-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.jpg" alt="FCFS 调度算法"></p><h3 id="最短作业优先算法"><a href="#最短作业优先算法" class="headerlink" title="最短作业优先算法"></a>最短作业优先算法</h3><p>他会选择运行时间较短的进程来运行，这会导致运行时间较长的进程无法获得cpu资源。而且我们也很难计算出一个进程到底会运行多长时间。</p><p><img src="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/25-%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95.jpg" alt="SJF 调度算法"></p><h3 id="RR-时间片轮转算法"><a href="#RR-时间片轮转算法" class="headerlink" title="RR 时间片轮转算法"></a>RR 时间片轮转算法</h3><p>RR – round robin 时间片轮转算法，这个算法就是操作系统为每个进程分配一个时间片，当正在运行的程序时间片使用完后，就会发生重新调度，停止此时正在运行的进程，并将进程加入到就绪队列中，选择另一个就绪进程运行，这个选择算法可以是FIFO。</p><p>时间片轮转带来的弊端就是时间片的大小设置问题，如何设置的小，导致需要频繁切换进程，并且一个运行时间短的进程可能需要轮转多次，如果设置较大，就会导致对短作业进程响应时间变长。</p><h3 id="HPF-最高优先级调度算法"><a href="#HPF-最高优先级调度算法" class="headerlink" title="HPF 最高优先级调度算法"></a>HPF 最高优先级调度算法</h3><p>每个进程的调度是有优先级的，通过为每个进程设置不同的调度优先级，当从就绪队列中寻找进程时，会选择出优先级最高的进程进行执行。这个优先级可以在创建进程的时候就将其设置好，也可以在运行期间更改其优先级。</p><h3 id="多级反馈队列算法"><a href="#多级反馈队列算法" class="headerlink" title="多级反馈队列算法"></a>多级反馈队列算法</h3><p>这个算法是结合时间片轮转算法和最高优先级算法实现的。</p><ul><li>多级：就是维护了多个就绪队列，每个队列的优先级从高到低并且时间片是从小到大</li><li>反馈：如果有新的进程加入到了比自己优先级高的队列中，那么就会停止现在的进行，去执行优先级高的进程。</li></ul><p><img src="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/28-%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97.jpg" alt="多级反馈队列"></p><p>这样的好处时，当来了一个新的进程时，能够第一时间处理它，并且因为高优先级队列时间片短，如果是一个短时间任务，那么就可以提前将其处理掉，如果是一个长时间任务，就会逐级放到低优先级的队列中，并逐步增大他的时间片就可以保证长时间任务有较长的时间运行。比较好的兼顾了长短时间进程。</p><h3 id="CFS-完全公平调度算法"><a href="#CFS-完全公平调度算法" class="headerlink" title="CFS 完全公平调度算法"></a>CFS 完全公平调度算法</h3><p><a href="https://www.jianshu.com/p/673c9e4817a8">https://www.jianshu.com/p/673c9e4817a8</a></p><p><a href="https://code84.com/735504.html">https://code84.com/735504.html</a></p><h2 id="进程调度过程"><a href="#进程调度过程" class="headerlink" title="进程调度过程"></a>进程调度过程</h2><p><a href="https://mp.weixin.qq.com/s/6as3ZB5s-H9jKtxAorGIfg">https://mp.weixin.qq.com/s/6as3ZB5s-H9jKtxAorGIfg</a></p><p><a href="https://ty-chen.github.io/linux-kernel-schedule/">https://ty-chen.github.io/linux-kernel-schedule/</a></p><p>linux的调度策略主要分为实时进程和普通进程。实时进程要求尽快返回结果，而普通进程没那么高的要求。在task_struct中有一个<code>policy</code>变量表示调度策略，调度优先级有<code>prio, static_prio, normal_prio, rt_priority</code>几个,y优先级其实就是一个数值，对于实时进程，优先级是0-99，对于普通进程，优先级是100-139，优先级越小级别越高。</p><p>对于实时进程采用的调度策略为FIFO和RR，这个和policy有关，对于普通进程采用的是CFS调度策略；</p><h3 id="什么是CFS策略："><a href="#什么是CFS策略：" class="headerlink" title="什么是CFS策略："></a>什么是CFS策略：</h3><p>CFS是为每一个进程安排了一个虚拟进程时间vruntime，如果一个任务在运行，那么随着一个个时钟的tick的到来，就会改变这个任务的vruntime值，然后判断是否可以发生调度操作。CFS策略的运行队列是一个根据vruntime生产的红黑树，vruntime越小，就会优先获得执行权。vruntime的计算和进程的权重有关，并且优先级高的进程会获得更多的执行时间，这个权重由一个nice值来决定的，nice值的范围是[-20,20]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> sched_prio_to_weight[<span class="hljs-number">40</span>] = &#123;<br> <span class="hljs-comment">/* -20 */</span>     <span class="hljs-number">88761</span>,     <span class="hljs-number">71755</span>,     <span class="hljs-number">56483</span>,     <span class="hljs-number">46273</span>,     <span class="hljs-number">36291</span>,<br> <span class="hljs-comment">/* -15 */</span>     <span class="hljs-number">29154</span>,     <span class="hljs-number">23254</span>,     <span class="hljs-number">18705</span>,     <span class="hljs-number">14949</span>,     <span class="hljs-number">11916</span>,<br> <span class="hljs-comment">/* -10 */</span>      <span class="hljs-number">9548</span>,      <span class="hljs-number">7620</span>,      <span class="hljs-number">6100</span>,      <span class="hljs-number">4904</span>,      <span class="hljs-number">3906</span>,<br> <span class="hljs-comment">/*  -5 */</span>      <span class="hljs-number">3121</span>,      <span class="hljs-number">2501</span>,      <span class="hljs-number">1991</span>,      <span class="hljs-number">1586</span>,      <span class="hljs-number">1277</span>,<br> <span class="hljs-comment">/*   0 */</span>      <span class="hljs-number">1024</span>,       <span class="hljs-number">820</span>,       <span class="hljs-number">655</span>,       <span class="hljs-number">526</span>,       <span class="hljs-number">423</span>,<br> <span class="hljs-comment">/*   5 */</span>       <span class="hljs-number">335</span>,       <span class="hljs-number">272</span>,       <span class="hljs-number">215</span>,       <span class="hljs-number">172</span>,       <span class="hljs-number">137</span>,<br> <span class="hljs-comment">/*  10 */</span>       <span class="hljs-number">110</span>,        <span class="hljs-number">87</span>,        <span class="hljs-number">70</span>,        <span class="hljs-number">56</span>,        <span class="hljs-number">45</span>,<br> <span class="hljs-comment">/*  15 */</span>        <span class="hljs-number">36</span>,        <span class="hljs-number">29</span>,        <span class="hljs-number">23</span>,        <span class="hljs-number">18</span>,        <span class="hljs-number">15</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>进程的运行时间：</p><p>分配给进程的时间 = 调度周期*进程权重/(所有进程权重之和) </p></li><li><p>vruntime计算：NICE_0_LOAD 是nice为0的值，对于不同的nice值，vruntime是不同的</p><p> vruntime = 进程的运行时间 * NICE_0_LOAD/ 进程的权重  // vruntime是进程的运行时间进行加权运算得到的。权重越大，增长的越慢，这样就会使得权重较大的进程获得更多的执行时间，这样就保证了相对的公平性。</p><p> vruntime = 调度周期*NICE_0_LOAD/(所有进程权重之和)</p></li></ul><p>CFS的思想就是让每个进程的vruntime相互追赶，vruntime的增长速度随着权重的增大而减慢，这样就能够使得权重较大的进程获得更多的执行时间，每次都是从运行队列中选择一个vruntime最小的进程来执行。CFS中的红黑树key是vruntime-min_vruntime，而不是这个vruntime，这是为了防止溢出的。</p><h3 id="调度器、调度实体、调度队列等"><a href="#调度器、调度实体、调度队列等" class="headerlink" title="调度器、调度实体、调度队列等"></a>调度器、调度实体、调度队列等</h3><blockquote><p>调度器：sched_class</p></blockquote><p>和调度器相关的是一个sche_class类，也叫调度类，它有几个实现，这个调度类就是去指向调度的，对于不同的调度策略有着不同的调度类实例。</p><p><img src="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20230506205938924.png" alt="image-20230506205938924"></p><ul><li><code>stop_sched_class</code> 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li><li><code>dl_sched_class</code> 就对应上面的 <code>deadline</code> 调度策略；</li><li><code>rt_sched_class</code> 就对应 <code>RR</code> 算法或者 <code>FIFO</code> 算法的调度策略，具体调度策略由进程的 <code>task_struct-&gt;policy</code> 指定；</li><li><code>fair_sched_class</code> 就是普通进程的调度策略；</li><li><code>idle_sched_class</code> 就是空闲进程的调度策略。</li></ul><p>我们已经有了调度类了，那么要调度的实体是什么呢？是task_struct吗？是task_struct中的一个sched_entity，它包含了vruntime和权重等。</p><blockquote><p>调度实体：sched_entity</p><ul><li>包含了这个vruntime和权重等信息</li></ul></blockquote><ul><li><code>struct sched_entity se</code>：普通任务调度实体</li><li><code>struct sched_rt_entity rt</code>：实时调度实体</li><li><code>struct sched_dl_entity dl</code>：<code>DEADLINE</code>调度实体</li></ul><blockquote><p>运行队列：</p></blockquote><p><img src="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image-20230506210240325.png" alt="image-20230506210240325"></p><p>对于普通进程来说，每次都是从cfs_rq中选择一个vruntime较小的一个调度实体，然后选择对应的进程进行运行。</p><blockquote><p>总结：</p></blockquote><ul><li>每个CPU都有一个<code>struct rq</code>结构体，里面会有着<code>cfs_rq</code>, <code>rt_rq</code>等一系列队列</li><li>每个队列由一个红黑树组织，红黑树里每一个节点为一个任务实体<code>sched_entity</code></li><li>每一个任务实体<code>sched_entity</code>对应于一个任务<code>task_struct</code></li><li>在<code>task_struct</code>中对应的<code>sched_class</code>会根据不同策略申明不同的对应处理函数，处理实际的调度工作</li></ul><p><img src="/2023/06/13/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/c14aceec16294b949ed1521820f8c348.png" alt="img"></p><h3 id="CFS调度过程"><a href="#CFS调度过程" class="headerlink" title="CFS调度过程"></a>CFS调度过程</h3><p>CFS调度器，当一个进程的状态是可运行状态时，使用<code>enqueue_task_fair</code>函数将任务入队到CFS队列，当一个进程的状态是其他状态时，使用<code>dequeue_task_fair</code>函数将任务从CFS队列中出队操作。</p><p>其实就是将task_struct对应的sched_entiry插入和删除在红黑树中。</p><blockquote><p>任务调度：</p><ul><li>_schedule()函数</li><li>pick_next_task()函数</li><li>context_switch()函数</li></ul></blockquote><p>当发生任务切换的时候，就会调用<code>_schedule()</code>函数，然后选择出对应的调度器，比如cfs调度器，调用<code>pick_next_task_fair()</code>函数选择下一个要运行的进程，然后再调用<code>context_switch()</code>函数切换进程环境。</p><p>对于这个进程切换时进程的上下文环境如何保存和恢复的我已经在中断那一篇讲过了。</p><blockquote><p>CFS的tick</p></blockquote><p>在每次时钟中断的时候，都会触发一个scheduler_tick()函数，这个函数会获取当前CPU的rq运行队列，并且获得当前的任务curr，然后调用该任务的sched_class类的task_tick函数，对于CFS调度器来说，他会更新这个任务的vruntime、运行时间等属性，然后再判断是不是可以发生调度了。如果此时vruntime不是运行队列中最小的了，那么就会将vruntime小的那个任务进行运行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux文件系统</title>
    <link href="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="什么是文件系统"><a href="#什么是文件系统" class="headerlink" title="什么是文件系统"></a>什么是文件系统</h2><p>【维基】<strong>文件系统</strong>是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用<strong>文件</strong>和<strong>树形目录</strong>的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。</p><p>Linux支持很多类型的文件系统，ext2、ext3、ext4以及FAT32/FAT16、NFS等，为了兼容这些文件系统，Linux引入了VFS（virtual file system）虚拟文件系统，屏蔽不同文件系统的操作。</p><p>我们今天主要介绍ext系列的文件系统</p><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>我们知道磁盘的最小单位是一个扇区，一个扇区的大小是512字节，在linux文件系统中，是以block来作为最小的数据管理单位的。一个block是4KB，就是8个扇区。为管理磁盘空间，引入了inode（index node）和superblock等概念，一个inode就是对应了一个具体的存储磁盘中的文件基本信息（文件大小，占用的block地址等）。文件系统通过block来管理磁盘空间，那么是采用什么方式记录空闲的block呢？我们知道可以采用空闲链表法和位图法，这里采用的是位图法。对于superblock是记录了格式化这个硬盘的文件系统的元信息。</p><h3 id="文件系统的磁盘结构"><a href="#文件系统的磁盘结构" class="headerlink" title="文件系统的磁盘结构"></a>文件系统的磁盘结构</h3><p>文件系统前面有一个启动扇区（boot sector），这个扇区中存储了开机管理程序，就是加载linux内核进入内存中的。接着就是superblock（超级块）、数据块位图、inode位图、inode列表、数据块block，基本布局如下所示：</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230512171459420.png" alt="image-20230512171459420"></p><p><code>superblock</code>：超级块，存储了文件系统的元信息</p><p><code>block位图</code>：记录了这个分区的数据块blcok的使用状况</p><p><code>inode位图</code>：记录了inode列表的使用情况</p><p><code>inode列表</code>：存储了一定数量的inode，每一个inode都是对应了一个文件。</p><p><code>数据块blocks</code>: 真正存储文件内容的区域</p><p>为了表示更大的空间，文件系统的结构如下：</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230513165626931.png" alt="image-20230513165626931"></p><p>其中superblock和快组描述符表是全局变量，包含了文件系统的元信息，有多少个inode，多少个数据块等信息。</p><p>为了防止superblock和快组描述符表所在磁盘空间损坏而丢失，会在每个快组中存放这两块内容（根据不同的策略而定，有的是随机找几个快组存放）。</p><h4 id="inode-结构"><a href="#inode-结构" class="headerlink" title="inode 结构"></a>inode 结构</h4><p>在inode中存储了文件的一些基本信息，但是不包含文件名，它主要是记录了这个文件占用的blocks情况,文件的大小等，在inode中存在着直接索引和间接索引指向一个个block编号。</p><p>其结构示意图如图：</p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/73349c0fab1a92d4e1ae0c684cfe06e2.jpeg" alt="img" style="zoom:25%;"><p>前12个可以直接索引block块号，后面三个索引分别是一级索引，二级索引和三级索引，这样就能够实现一个inode可以对应较多的blocks，实现存储较大的文件。</p><h4 id="目录的存储格式"><a href="#目录的存储格式" class="headerlink" title="目录的存储格式"></a>目录的存储格式</h4><p>为了便于文件的查找，我们必须有索引，也就是文件目录。每个目录也是一个文件，也对应一个inode，只不过这个文件目录中存储的内容和普通的文件不同而已。普通文件的对应的blocks中存储的就是文件数据内容；而目录文件对应的blocks存储的是每个目录项的信息（文件名，文件的inode编号等），在blcoks中整齐排放的。基本结构如下：</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230513170900730.png" alt="image-20230513170900730"></p><p>但是为了能够快速的找到某个文件，采用了hash索引：</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230513171005442.png" alt="image-20230513171005442"></p><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p>虚拟文件系统VFS(virtual file system)，是为了兼容较多版本文件系统而提供的一层抽象的文件系统接口。</p><p>我们先看一下文件系统使用的基本流程：</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-ad1d59c51719a9a1c3067cff31d0f8b9_r.jpg" alt="img"></p><p>VFS是在linux上抽象一个通用的文件系统模型，通过提供统一的文件操作的接口，让我们不用去在意每个具体文件系统的实现。在VFS中，提供了几个核心的数据结构，分别是superblock、inode、dentry、file。</p><p>除此之外，还有一些文件系统的概念，比如文件描述符等，接下来我们就介绍一下这些概念和其之间的关系。</p><ul><li><p><code>superblock</code>超级块：这个用于保存一个文件系统的元数据，记录了对应的文件系统的基本信息，它和磁盘上的哪个superblock基本一致，一个superblock对应一个文件系统。这个superblock是常驻内存并被缓存的。</p></li><li><p><code>dentry</code>目录项：目录项的引入主要是用来根据文件路径查找文件的。目录项记录了文件名、inode编号和此目录项和其他目录项的关系。一般查找文件路径都是通过这个dentry进行的。不够这个denrty只存在与内存，不存在于磁盘中。</p></li><li><p><code>file</code>: 每打开一个文件，就会生成一个file对象，所有打开的文件的file形成了一个打开文件表，这个打开文件表是一个系统级变量，不属于某个进程的，记录了所有打开的文件。同一个文件可以被多次打开产生多个file。</p></li><li><p><code>inode</code>：这个和磁盘的inode基本对应，是一个文件的唯一标识，它记录了对应的文件的在磁盘中的地址。</p></li><li><p><code>file_operations</code>: 这个结构是一系列函数指针的集合，比如open、read、write等文件操作函数，这个是在file对象中的，每个打开的文件都有一个file_operations属性，用来对文件的操作，不同的文件系统的打开的file的file_operations中的函数指针不同，实现了对不同文件系统的兼容。</p></li><li><p><code>address_space</code>模块，它表示一个文件在页缓存中已经缓存了的物理页。它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么address_space可以说关联了内存系统和文件系统。我们会在文章后面继续讨论。</p></li></ul><p>对于file结构，它是代表了一个打开的文件，VFS在此结构定义了针对于file操作的方法file_operatrions:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// include/linux/fs.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>    ......<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>    *<span class="hljs-title">f_op</span></span><br><span class="hljs-class">&#125;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>    ......<br>    <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>    <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>            ......<br>    <span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br>    <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>    <span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意 VFS 是抽象的</strong>，所以它的 file_operations 里定义的 read、write 都只是函数指针， 实际中需要具体的文件系统来实现，例如 ext4 等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ext4_file_operations</span> =</span> &#123;<br>    .llseek         = ext4_llseek,<br>    .read           = do_sync_read,<br>    .write          = do_sync_write,<br>    .aio_read       = generic_file_aio_read,<br>    .aio_write      = ext4_file_write,<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述各模块结构以及之间的关系：</p></blockquote><ul><li><p><code>inode</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span><span class="hljs-keyword">struct</span> inode &#123;  <br><span class="hljs-number">2.</span>    .....<br><span class="hljs-number">3.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span>    <span class="hljs-title">i_hash</span>;</span>     <span class="hljs-comment">/* 散列表，用于快速查找inode */</span>  <br><span class="hljs-number">4.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">i_list</span>;</span>        <span class="hljs-comment">/* 索引节点链表 */</span>  <br><span class="hljs-number">5.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">i_sb_list</span>;</span>  <span class="hljs-comment">/* 超级块链表超级块  */</span>  <br><span class="hljs-number">6.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>    <span class="hljs-title">i_dentry</span>;</span>   <span class="hljs-comment">/* 目录项链表 */</span>  <br><span class="hljs-number">7.</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>        i_ino;      <span class="hljs-comment">/* 节点号 */</span>  <br><span class="hljs-number">8.</span>    <span class="hljs-type">atomic_t</span>        i_count;        <span class="hljs-comment">/* 引用计数 */</span>  <br><span class="hljs-number">9.</span>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>        i_nlink;    <span class="hljs-comment">/* 硬链接数 */</span>  <br><span class="hljs-number">10.</span>    <span class="hljs-type">uid_t</span>            i_uid;          <span class="hljs-comment">/* 使用者id */</span>  <br><span class="hljs-number">11.</span>    <span class="hljs-type">gid_t</span>            i_gid;          <span class="hljs-comment">/* 使用组id */</span>  <br><span class="hljs-number">12.</span>    <span class="hljs-type">umode_t</span>          i_mode;            <span class="hljs-comment">/* 文件访问权限 */</span><br><span class="hljs-number">13.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span>        <span class="hljs-title">i_atime</span>;</span>    <span class="hljs-comment">/* 最后访问时间 */</span>  <br><span class="hljs-number">14.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span>        <span class="hljs-title">i_mtime</span>;</span>    <span class="hljs-comment">/* 最后修改时间 */</span>  <br><span class="hljs-number">15.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span>        <span class="hljs-title">i_ctime</span>;</span>    <span class="hljs-comment">/* 最后改变时间 */</span>  <br><span class="hljs-number">16.</span>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span>    *<span class="hljs-title">i_op</span>;</span>  <span class="hljs-comment">/* 索引节点操作函数 */</span>  <br><span class="hljs-number">17.</span>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span>    *<span class="hljs-title">i_fop</span>;</span>    <span class="hljs-comment">/* 缺省的索引节点操作 */</span>  <br><span class="hljs-number">18.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span>    *<span class="hljs-title">i_sb</span>;</span>              <span class="hljs-comment">/* 相关的超级块 */</span>  <br><span class="hljs-number">19.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>    *<span class="hljs-title">i_mapping</span>;</span>     <span class="hljs-comment">/* 相关的地址映射 */</span>  <br><span class="hljs-number">20.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span>    <span class="hljs-title">i_data</span>;</span>         <span class="hljs-comment">/* 设备地址映射 */</span>  <br><span class="hljs-number">21.</span>    .....<br>&#125;; <br></code></pre></td></tr></table></figure></li><li><p><code>dentry</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span><span class="hljs-keyword">struct</span> dentry &#123;<span class="hljs-comment">//目录项结构  </span><br><span class="hljs-number">2.</span>  <br><span class="hljs-number">3.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">d_inode</span>;</span>           <span class="hljs-comment">/*相关的索引节点*/</span>  <br><span class="hljs-number">4.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">d_parent</span>;</span>         <span class="hljs-comment">/*父目录的目录项对象*/</span>  <br><span class="hljs-number">5.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span> <span class="hljs-title">d_name</span>;</span>              <span class="hljs-comment">/*目录项的名字*/</span>  <br><span class="hljs-number">6.</span>   <br><span class="hljs-number">7.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">d_subdirs</span>;</span>      <span class="hljs-comment">/*子目录*/</span>  <br><span class="hljs-number">8.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span> *<span class="hljs-title">d_op</span>;</span>  <span class="hljs-comment">/*目录项操作表*/</span>  <br><span class="hljs-number">9.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">d_sb</span>;</span>        <span class="hljs-comment">/*文件超级块*/</span>  <br><span class="hljs-number">10.</span>   ...<br><span class="hljs-number">11.</span>&#125;;  <br><span class="hljs-number">12.</span>  <br><span class="hljs-number">13.</span><span class="hljs-keyword">struct</span> dentry_operations &#123;  <br><span class="hljs-number">14.</span>    <span class="hljs-comment">//判断目录项是否有效;  </span><br><span class="hljs-number">15.</span>    <span class="hljs-type">int</span> (*d_revalidate)(<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> nameidata *);  <br><span class="hljs-number">16.</span>    <span class="hljs-comment">//为目录项生成散列值;  </span><br><span class="hljs-number">17.</span>    <span class="hljs-type">int</span> (*d_hash) (<span class="hljs-keyword">struct</span> dentry *, <span class="hljs-keyword">struct</span> qstr *);  <br><span class="hljs-number">18.</span>    ……  <br><span class="hljs-number">19.</span>&#125;;  <br></code></pre></td></tr></table></figure></li><li><p><code>file</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span>  <br><span class="hljs-number">2.</span>    ……  <br><span class="hljs-number">3.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span>        <span class="hljs-title">f_list</span>;</span>        <span class="hljs-comment">/*文件对象链表*/</span>  <br><span class="hljs-number">4.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span>          *<span class="hljs-title">f_dentry</span>;</span>       <span class="hljs-comment">/*相关目录项对象*/</span>  <br><span class="hljs-number">5.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span>        *<span class="hljs-title">f_vfsmnt</span>;</span>       <span class="hljs-comment">/*相关的安装文件系统*/</span>  <br><span class="hljs-number">6.</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">f_op</span>;</span>           <span class="hljs-comment">/*文件操作表*/</span>  <br><span class="hljs-number">7.</span>    ……  <br><span class="hljs-number">8.</span>&#125;;  <br><span class="hljs-number">9.</span>   <br><span class="hljs-number">10.</span><span class="hljs-keyword">struct</span> file_operations &#123;  <br><span class="hljs-number">11.</span>    ……  <br><span class="hljs-number">12.</span>    <span class="hljs-comment">//文件读操作  </span><br><span class="hljs-number">13.</span>    <span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);  <br><span class="hljs-number">14.</span>    <span class="hljs-comment">//文件写操作  </span><br><span class="hljs-number">15.</span>    <span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *); <br><span class="hljs-number">16.</span>    <span class="hljs-type">int</span> (*readdir) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">void</span> *, <span class="hljs-type">filldir_t</span>);  <br><span class="hljs-number">17.</span>    <span class="hljs-comment">//文件打开操作  </span><br><span class="hljs-number">18.</span>    <span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);  <br><span class="hljs-number">19.</span>    ……  <br><span class="hljs-number">20.</span>&#125;;  <br></code></pre></td></tr></table></figure></li></ul><p>我们可以看到file包含一个dentry指针，对应一个dentry，dentry中包含一个inode指针和superblock指针，inode中包含了一个超级块指针和一系列文件信息。</p><p>所以他们之间的关系是：</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230514172549700.png" alt="image-20230514172549700"></p><h2 id="进程和文件系统"><a href="#进程和文件系统" class="headerlink" title="进程和文件系统"></a>进程和文件系统</h2><p>我们都知道进程在内存中用一个task_struct标识。在task_struct中有一个file_struct类型的属性，记录了这个进程打开的所有文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span> &#123;</span><br><span class="hljs-type">atomic_t</span> count; <span class="hljs-comment">/* 共享该表的进程数 */</span><br><span class="hljs-type">rwlock_t</span> file_lock; <span class="hljs-comment">/* 保护以下的所有域,以免在tsk-&gt;alloc_lock中的嵌套*/</span><br><span class="hljs-type">int</span> max_fds; <span class="hljs-comment">/*当前文件对象的最大数*/</span><br><span class="hljs-type">int</span> max_fdset; <span class="hljs-comment">/*当前文件描述符的最大数*/</span><br><span class="hljs-type">int</span> next_fd; ／*已分配的文件描述符加<span class="hljs-number">1</span>*/<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> ** <span class="hljs-title">fd</span>;</span> <span class="hljs-comment">/* 指向文件对象指针数组的指针 */</span><br>fd_set *close_on_exec; <span class="hljs-comment">/*指向执行exec( )时需要关闭的文件描述符*/</span><br>fd_set *open_fds; <span class="hljs-comment">/*指向打开文件描述符的指针*/</span><br>fd_set close_on_exec_init;<span class="hljs-comment">/* 执行exec( )时需要关闭的文件描述符的初 值集合*/</span><br>fd_set open_fds_init; <span class="hljs-comment">/*文件描述符的初值集合*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> * <span class="hljs-title">fd_array</span>[32];</span><span class="hljs-comment">/* 文件对象指针的初始化数组*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>它有一个fd指针数组，指向每一个被此进程打开的file，通常我们说的文件描述符就是文件描述符数组的下标。当我们打开一个文件的时候，就会返回一个文件描述符（int类型的），就是file指针数组的下标。每次我们操作某个文件的时候，就是通过这个下标找到对应的file，然后通过他的file_operations进行操作文件。</p><p>前面我们说过了有一个打开文件表，它是一个系统级别变量，这个fd数组中村的就是file对象的指针。</p><blockquote><p>关系如下：</p></blockquote><ul><li><strong>fd和file和inode之间的关系</strong></li></ul><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/v2-cf92d0efa3aafd0f6ebd537337bb1801_r.jpg" alt="img"></p><ul><li><p><strong>task_struct和file、inode之间的关系。</strong></p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230515185115440.png" alt="image-20230515185115440"></p></li></ul><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230514225314909.png" alt="image-20230514225314909"></p><ol><li>多个进程可以同时指向一个打开文件对象（文件列表表项），例如父进程和子进程间共享文件对象；</li><li>一个进程可以多次打开一个文件，生成不同的文件描述符，每个文件描述符指向不同的文件列表表项。但是由于是同一个文件，inode唯一，所以这些文件列表表项都指向同一个inode。通过这样的方法实现文件共享（共享同一个磁盘文件）；</li></ol><h2 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a>Page Cache</h2><p><a href="https://www.cnblogs.com/ywang-wnlo/p/16110410.html">https://www.cnblogs.com/ywang-wnlo/p/16110410.html</a></p><p><a href="https://blog.csdn.net/u010039418/article/details/115773253">https://blog.csdn.net/u010039418/article/details/115773253</a></p><p>Page Cache。它的中文译名叫页高速缓存。它是 Linux 内核使用的主要磁盘高速缓存，是一个纯内存的工作组件。Linux 内核使用搜索树来高效管理大量的页面。有了它，Linux 就可以把一些磁盘上的文件数据保留在内存中，然后来给访问相对比较慢的磁盘来进行访问加速。当用户要访问的文件的时候，如果要访问的文件 block 正好存在于 Page Cache 内，那么 Page Cache 组件直接把数据从内核态拷贝到用户进程的内存中就可以了。如果不存在，那么会申请一个新页，发出缺页中断，然后用磁盘读取到的 block 内容来填充它 ，下次直接使用。</p><blockquote><p>关于PageCache 和 inode等之间的关系，如下图：</p></blockquote><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAwMzk0MTg=,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p><p>PageCache在linux中采用一个address space结构来实现的，每一个文件都对应一个file和inode和address space，address space存在于inode之中，但是它所对应的缓存的页面组成了一个基树，基本结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>*<span class="hljs-title">host</span>;</span><span class="hljs-comment">//pagecache的所有者，inode或者block device</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span><span class="hljs-title">i_pages</span>;</span><span class="hljs-comment">/* cached pages */</span><br><span class="hljs-type">atomic_t</span>i_mmap_writable;<span class="hljs-comment">/* count VM_SHARED mappings */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_root_cached</span><span class="hljs-title">i_mmap</span>;</span><span class="hljs-comment">/* tree of private and shared mappings */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rw_semaphore</span><span class="hljs-title">i_mmap_rwsem</span>;</span><span class="hljs-comment">/* protect tree, count, list */</span><br><span class="hljs-comment">/* Protected by the i_pages lock */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nrpages;<span class="hljs-comment">//包含的页面数量</span><br><span class="hljs-comment">/* number of shadow or DAX exceptional entries */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>nrexceptional;<br><span class="hljs-type">pgoff_t</span>writeback_index;<span class="hljs-comment">/* writeback starts here */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space_operations</span> *<span class="hljs-title">a_ops</span>;</span><span class="hljs-comment">/* methods */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<span class="hljs-comment">/* error bits */</span><br><span class="hljs-type">spinlock_t</span>private_lock;<span class="hljs-comment">/* for use by the address_space */</span><br><span class="hljs-type">gfp_t</span>gfp_mask;<span class="hljs-comment">/* implicit gfp mask for allocations */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span><span class="hljs-title">private_list</span>;</span><span class="hljs-comment">//一般用来放metadata buffers，但ext4不使用该变量</span><br><span class="hljs-type">void</span>*private_data;<span class="hljs-comment">//同上</span><br>...<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><code>radix_tree_root</code> 和 <code>radix_tree_node</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_root</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>            height;<span class="hljs-comment">//从叶节点向上计算出的树高度</span><br>        <span class="hljs-type">gfp_t</span>                   gfp_mask;<span class="hljs-comment">//内存申请的标识</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span>  __<span class="hljs-title">rcu</span> *<span class="hljs-title">rnode</span>;</span><span class="hljs-comment">//子节点指针</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> &#123;</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    height;<span class="hljs-comment">/* Height from the bottom */</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    count;<span class="hljs-comment">//子节点个数</span><br>        <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">radix_tree_node</span> *<span class="hljs-title">parent</span>;</span><span class="hljs-comment">//父节点指针</span><br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu_head</span>;</span><span class="hljs-comment">//用于节点释放的RCU链表</span><br>        &#125;;<br>        <span class="hljs-type">void</span> __rcu      *slots[RADIX_TREE_MAP_SIZE];<span class="hljs-comment">//指向存储数据指针</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS];<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>address space的基树结构如下，每个槽存储的就是指向page的指针。</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230522222547398.png" alt="image-20230522222547398"></p><blockquote><p>读取文件的基本流程就是：</p><p>先在缓存中找对应的page，如果找到了直接将内容复制到用户空间</p><p>如果没有找到就从磁盘中读取一个页，并在内核中申请一个物理页作为缓存页，并将内容读取到这个物理页中，然后再将内容复制到用户空间。</p></blockquote><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Center.png" alt="img"></p><blockquote><p>page cache回写机制</p></blockquote><p><a href="https://www.cnblogs.com/ywang-wnlo/p/writeback.html">https://www.cnblogs.com/ywang-wnlo/p/writeback.html</a></p><h2 id="打开文件过程"><a href="#打开文件过程" class="headerlink" title="打开文件过程"></a>打开文件过程</h2><p><a href="https://www.jianshu.com/p/f3f5a33f2c59">https://www.jianshu.com/p/f3f5a33f2c59</a></p><p>我们直接从系统调用开始讲。</p><p>打开文件的基本思路就是，先申请一个空闲的fd，然后创建一个file，然后解析路径，找到inode，然后初始化file，返回fd。</p><p>我么知道linux kernel 中，我们打开一个文件使用的是filp_open()这个kernel api实现的，这个函数只是简单的封装，具体的实现是do_filp_open()函数，这个函数会得到一个fd对应的struct nameidata结构，然后使用nameidata_to_filp()函数返回一个struct file结构。</p><blockquote><p> 我们看一下这个<code>do_filp_open()</code>函数：</p><ul><li>这个函数返回了一个file*，也就是打开的文件在内存中的存在形式。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> file *<span class="hljs-title function_">do_filp_open</span><span class="hljs-params">(<span class="hljs-type">int</span> dfd, <span class="hljs-keyword">struct</span> filename *pathname,</span><br><span class="hljs-params">        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> open_flags *op)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nameidata</span> <span class="hljs-title">nd</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">filp</span>;</span><br>    set_nameidata(&amp;nd, dfd, pathname);<br>    filp = path_openat(&amp;nd, op, flags | LOOKUP_RCU);<br>......<br>    restore_nameidata();<br>    <span class="hljs-keyword">return</span> filp;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到一个nameidata结构，这个结构主要包含了路径相关的path，last，root，inode等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nameidata</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span><span class="hljs-title">path</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span><span class="hljs-title">last</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span><span class="hljs-title">root</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span>*<span class="hljs-title">inode</span>;</span> <span class="hljs-comment">/* path.dentry.d_inode */</span><br>......<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>path结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span> *<span class="hljs-title">mnt</span>;</span>  <span class="hljs-comment">// 挂载相关</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">dentry</span>;</span> <span class="hljs-comment">// 对应的目录项</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>我们在上面的函数中看到，最终返会file的是path_openat函数，这个函数的大致流程如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> file *<span class="hljs-title function_">path_openat</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nameidata *nd,</span><br><span class="hljs-params">            <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> open_flags *op, <span class="hljs-type">unsigned</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    <span class="hljs-type">int</span> error;<br>    file = alloc_empty_file(op-&gt;open_flag, current_cred());<br>......<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = path_init(nd, flags);<br>        <span class="hljs-keyword">while</span> (!(error = link_path_walk(s, nd)) &amp;&amp;<br>            (error = do_last(nd, file, op)) &gt; <span class="hljs-number">0</span>) &#123;<br>            nd-&gt;flags &amp;= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);<br>            s = trailing_symlink(nd);<br>        &#125;<br>        terminate_walk(nd);<br>......<br></code></pre></td></tr></table></figure><ul><li>首先<code>alloc_empty_file</code>生成一个空的file结构体，由slab分配器分配，然后初始化这个nameidata结构，准备进行路径解析与查找</li><li>然后调用这个<code>link_path_walk</code>()对路径进行逐层的查找，这个函数里面有一个大循环，不断的逐层处理，知道处理到最后一层，然后调用dolast()函数</li><li>调用这个<code>do_last()</code>获取文件对应的inode，并<strong>利用inode属性初始化file，比如file中的file_operations变量。</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Handle the last step of open()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_last</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> nameidata *nd,</span><br><span class="hljs-params">           <span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> open_flags *op)</span><br>&#123;<br>......<br>    error = lookup_fast(nd, &amp;path, &amp;inode, &amp;seq);<br>......<br>    error = lookup_open(nd, &amp;path, file, op, got_write);<br>......<br>    error = vfs_open(&amp;nd-&gt;path, file);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p><code>do_last()</code>函数如其名字一样，完成了最后一部分的解析和处理工作。首先调用<code>lookup_fast()</code>查找文件路径最后一部分对应的<code>dentry</code>，接着使用<code>lookup_open()</code>判断是否需要创建新的<code>dentry</code>，最终将<code>dentry</code>赋值给<code>path</code>。最后调用<code>vfs_open()</code>真正的打开文件。</p><p><code>lookup_open()</code>对于dentry的查找，首先会去缓存中查找，如果缓存中查找不到在创建一个新的dentry变量，并将生成的dentry赋值到path变量中。</p><p><strong><code>vfs_open</code>是最有一步，就是调用open函数，它其实调用的是<code>f_op-&gt;open</code>函数，也就是调用具体的文件系统的open函数，如<code>ext4_file_open()</code>，这个file结构中的f_op变量来自于inode中的f_ops变量</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vfs_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> path *path, <span class="hljs-keyword">struct</span> file *file,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">dentry</span> =</span> d_real(path-&gt;dentry, <span class="hljs-literal">NULL</span>, file-&gt;f_flags, <span class="hljs-number">0</span>);<br>......<br>  file-&gt;f_path = *path;<br>  <span class="hljs-keyword">return</span> do_dentry_open(file, d_backing_inode(dentry), <span class="hljs-literal">NULL</span>, cred);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">do_dentry_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *f,</span><br><span class="hljs-params">        <span class="hljs-keyword">struct</span> inode *inode,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> (*open)(<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *),</span><br><span class="hljs-params">        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> cred *cred)</span><br>&#123;<br>......<br>    f-&gt;f_mode = OPEN_FMODE(f-&gt;f_flags) | FMODE_LSEEK |<br>        FMODE_PREAD | FMODE_PWRITE;<br>    path_get(&amp;f-&gt;f_path);<br>    f-&gt;f_inode = inode;<br>    f-&gt;f_mapping = inode-&gt;i_mapping;<br>......<br>    f-&gt;f_op = fops_get(inode-&gt;i_fop);  <span class="hljs-comment">// 从这一步就可以看出了。来自inode中的i_fop</span><br>......<br>    open = f-&gt;f_op-&gt;open;<br>......<br>    error = open(inode, f);<br>......<br>    f-&gt;f_flags &amp;= ~(O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC);<br>    file_ra_state_init(&amp;f-&gt;f_ra, f-&gt;f_mapping-&gt;host-&gt;i_mapping);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>......<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">ext4_file_operations</span> =</span> &#123;<br>......<br>    .open    = ext4_file_open,<br>......<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>流程总结：</p></blockquote><ul><li>对每个<code>task_struct</code>建立一个文件描述符表管理该任务对应的文件</li><li>使用<code>mount, vfsmount</code>和<code>dentry</code>建立虚拟文件系统和实际文件系统的关联</li><li>创建<code>file</code>结构体来表述<code>dentry</code>和<code>mount</code>，并建立和文件描述符的关系以便使用</li><li>通过<code>dentry</code>查找对应<code>inode</code>，分配<code>file</code>结构体并完成初始化工作</li><li>通过虚拟文件系统和实际文件系统的映射，调用实际文件系统如ext4对应的函数完成打开操作</li></ul><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/8070294bacd74e0ac5ccc5ac88be1bb9.png" alt="img"></p><blockquote><p>对于文件的读写，就是利用 返回的fd找到对应的file，然后利用file-&gt;f_ops-&gt;read()即可。</p></blockquote><h2 id="文件的挂载"><a href="#文件的挂载" class="headerlink" title="文件的挂载"></a>文件的挂载</h2><p><a href="https://juejin.cn/post/7035656232987787272">https://juejin.cn/post/7035656232987787272</a></p><p>什么是文件的挂载？</p><p>在linux操作系统中一切皆文件，任何设备也被看成一个个文件，并且每个硬件设备都有自己的一套文件系统（文件目录结构）。在linux访问这些硬件设备的文件时，必须将linux本身的文件目录和硬件设备的文件目录合二为一，这个过程就是挂载。挂载后，通过访问硬件设备挂载的目录就相当于访问此硬件设备。</p><p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件。</p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230515215820454.png" alt="image-20230515215820454"></p><p><img src="/2023/06/13/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image-20230515215831504.png" alt="image-20230515215831504"></p><p>我们在根目录下创建了一个新的目录/sdb-u用来挂载U盘的文件系统，效果如上，接下来我么访问U盘文件，就可以按照正常的文件访问就行了。</p><blockquote><p>挂载的原理以及流程如下：</p></blockquote><p>首先会将要挂载的文件系统进行注册，比如ext4文件系统：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">register_filesystem(&amp;ext4_fs_type); <span class="hljs-comment">// 注册文件系统</span><br><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span> <span class="hljs-title">ext4_fs_type</span> =</span> &#123;<br>    .owner    = THIS_MODULE,<br>    .name    = <span class="hljs-string">&quot;ext4&quot;</span>,<br>    .mount    = ext4_mount,<br>    .kill_sb  = kill_block_super,<br>    .fs_flags  = FS_REQUIRES_DEV,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>mount</code>和<code>vfs_mount</code>结构</li></ul><p>每挂载一个文件系统，就会生成一个对应的mount和vfs_mount结构，标识挂载的文件系统。mount中有一个vfsmount,他们用来存储被挂载的属于原来文件系统的dentry和挂载后的文件系统的根目录dentry。vfsmount还包含了指向挂载的文件系统的superblock指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">mnt_root</span>;</span><span class="hljs-comment">/* root of the mounted tree */</span>   <span class="hljs-comment">// 属于挂载的文件系统的根目录的dentry</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span> *<span class="hljs-title">mnt_sb</span>;</span><span class="hljs-comment">/* pointer to superblock */</span><br>    <span class="hljs-type">int</span> mnt_flags;<br>&#125; __randomize_layout;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mount</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hlist_node</span> <span class="hljs-title">mnt_hash</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mount</span> *<span class="hljs-title">mnt_parent</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span> *<span class="hljs-title">mnt_mountpoint</span>;</span>  <span class="hljs-comment">// 挂载的属于原来文件系统的entry</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vfsmount</span> <span class="hljs-title">mnt</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">mnt_rcu</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">llist_node</span> <span class="hljs-title">mnt_llist</span>;</span><br>    &#125;;<br>......<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">mnt_mounts</span>;</span><span class="hljs-comment">/* list of children, anchored here */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">mnt_child</span>;</span><span class="hljs-comment">/* and going through their mnt_child */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">mnt_instance</span>;</span><span class="hljs-comment">/* mount instance on sb-&gt;s_mounts */</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mnt_devname;<span class="hljs-comment">/* Name of device e.g. /dev/dsk/hda1 */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">mnt_list</span>;</span><br>......<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><blockquote><p>挂载的基本流程：</p></blockquote><p>例如/dev/sdb块设备被mount到/mnt/alan目录，那么当用户执行”mount /dev/sdb /mnt/alan“命令的时候，linux会对/mnt/alan路径进行解析，然后找到alan目录对应的dentry，然后将这个dentry标识为DCACHE_MOUNTED，表示这个目录是个挂载目录，对他的访问是屏蔽的。内核会为这个挂载的文件系统创建一个superblock在内存中，并创建一个表示此文件目录的根目录的dentry：s_root，挂载的文件系统的文件都是通过这个dentry进行访问的。同时内核还会创建一个mount和vfsmount结构对象，vfsmount存储了指向s_root对应的dentry变量 mnt_root，以及指向的superblock的指针等信息，并将这个vfsmount对象放在hash表中，基于path计算hash值，当我们解析到alan的dentry时，它的dentry是DCACHE_MOUNTED，就从hash表中获取vfdmount进而获取mnt_root对应的dentry（实现了dentry的重定向），继续解析下去。</p><p>具体函数调用这里就不贴了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux内核启动与初始化</title>
    <link href="/2023/06/13/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2023/06/13/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux内核启动与初始化"><a href="#Linux内核启动与初始化" class="headerlink" title="Linux内核启动与初始化"></a>Linux内核启动与初始化</h1><h2 id="BIOS到bootloader程序"><a href="#BIOS到bootloader程序" class="headerlink" title="BIOS到bootloader程序"></a>BIOS到bootloader程序</h2><p>当我们按下电源的时候，cpu中的cs和eip寄存器就会装载固定的值，这个其实就是BIOS程序的所在的物理地址。BIOS叫做基本输入输出系统，主要是在用来加载引导程序，然后由引导程序加载内核镜像。</p><p><img src="/2023/06/13/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/image-20230608164749115.png" alt="image-20230608164749115"></p><p>当进入BIOS程序的时候，cpu处于实模式下，程序可以任意的访问物理地址，寻址采用cs+eip方式进行寻址，cs代表段基址，eip表示段内偏移量。BIOS还负责初始化一些硬件设备，包括cpu、内存，同时初始化中断向量表，中断向量表位于最低端，里面装着BIOS的中断服务程序，对于bootloader的int13就是调用的bios中断服务程序控制磁盘的，但是它主要的功能就是加载位于MBR引导扇区的bootloader程序。</p><p><strong>BIOS将会把位于位于磁盘第一扇区的bootloader程序读取到内存<code>0x7c00</code>地址处。</strong>后面会将其复制到0x90000处。</p><h2 id="bootloader程序"><a href="#bootloader程序" class="headerlink" title="bootloader程序"></a>bootloader程序</h2><p>bootloader程序位于磁盘的第一个扇区，叫做引导扇区MBR，它负责将内核镜像加载到内存中来。bootloader会配合一些辅助代码进行加载内核。会将内核程序加载到0x100000处。</p><p>bootloader会使用<code>int 13</code>(触发BIOS中断服务)指令从磁盘读入setup程序（辅助程序）和内核映像。然后跳转到setup程序并做好执行内核程序的准备，包括对内核映像的解压缩，解除压缩之后就将内核映像加载到了<code>0x100000</code>(1MB)处。BIOS进入bootloader时cpu处于实模式，在经过bootloader和setup程序后就会进行保护模式，如何进入保护模式呢？</p><p>后面进入保护模式后，寻址采用段式寻址方式，有一个段描述符表GDT，其地址在GDTR寄存器中，段描述符中包含了关于段的访问权限（特权级检查）和段基址等信息。CS寄存器此时变成了段选择子，不再是段基址寄存器了，它的高13位表示段选择子，低3位标识CPL。</p><p>当加载完内核程序之后，就会跳转到内核程序的入口去了，自此，cpu的控制器就交给了操作系统了。但是此时我们还没有开启分页模式。</p><h2 id="内核运行与初始化"><a href="#内核运行与初始化" class="headerlink" title="内核运行与初始化"></a>内核运行与初始化</h2><p>bootloader程序将辅助程序setup和内核映像加载到了内核后，就开始进入了setup辅助程序的运行。这里我们将实模式转为保护模式，初始化IDT和GDT等工作，然后跳转到内核入口地址。</p><p>在setup.s中初始化IDT中断描述符表和GDT全局描述符表，并将其地址存在IDTR和GDTR寄存器中。</p><p>打开A20地址线，进入保护模式，此时的寻址范围为32地址线了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ASM">#boot/setup.s<br>mov ax，#0x0001！protected mode（PE）bit<br>lmsw ax！This is it！<br>jmpi 0，8！jmp offset 0 of segment 8（cs）<br></code></pre></td></tr></table></figure><p>完成这些之后，就跳转到了内核的head.s程序中，head.s是进入内核main程序的最后一步，在head里面会初始化各个段寄存器，解压内核映像到0x100000处，完成临时内核页表的创建，打开分页模式（将页表地址存放在cr3寄存器中），跳转到main函数，进行下一步初始化。</p><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><p>前面我们从实模式进入到了保护模式，并开启了分页模式，接下来进入到了内核的main()中，先开始执行一些类初始化动作。</p><p><code>start_kernel()</code>上来就会运行 <code>set_task_stack_end_magic(&amp;init_task)</code>创建初始进程。<code>init_task</code>的定义是 <code>struct task_struct init_task = INIT_TASK(init_task)</code>。它是系统创建的第一个进程，我们称为 <code>0 号进程</code>。<strong>这是唯一一个没有通过 <code>fork</code> 或者 <code>kernel_thread</code>产生的进程，是进程列表的第一个</strong>。</p><p><code>init_task</code>是静态定义的一个进程，也就是说当内核被放入内存时，它就已经存在，它没有自己的用户空间，一直处于内核空间中运行，并且也只处于内核空间运行。<strong>0号进程用于包括内存、页表、必要数据结构、信号、调度器、硬件设备等的初始化。</strong>当它执行到最后（剩余初始化）时，将<code>start_kernel</code>中所有的初始化执行完成后，会在内核中启动一个<code>kernel_init</code>内核线程和一个<code>kthreadd</code>内核线程，<code>kernel_init</code>内核线程执行到最后会通过<code>execve</code>系统调用执行转变为我们所熟悉的<code>init</code>进程，而<code>kthreadd</code>内核线程是内核用于管理调度其他的内核线程的守护线程。在最后<code>init_task</code>将变成一个idle进程，用于在CPU没有进程运行时运行它，它在此时仅仅用于空转。</p><h4 id="中断初始化-–-trap-init"><a href="#中断初始化-–-trap-init" class="headerlink" title="中断初始化 – trap_init()"></a>中断初始化 – trap_init()</h4><p>我们前面已经设置了中断向量表，但是中断描述符中并没有指向具体的中断服务函数，这里我们将设置中断向量表中的每一项对应的中断服务函数地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//设置系统的硬件中断 中断位于kernel/asm.s 或 system_call.s</span><br>    set_trap_gate(<span class="hljs-number">0</span>,÷_error);<span class="hljs-comment">//0中断，位于/kernel/asm.s 19行</span><br>    set_trap_gate(<span class="hljs-number">1</span>,&amp;debug);<br>    set_trap_gate(<span class="hljs-number">2</span>,&amp;nmi);<br>    set_system_gate(<span class="hljs-number">3</span>,&amp;int3);    <span class="hljs-comment">/* int3-5 can be called from all */</span><br>    set_system_gate(<span class="hljs-number">4</span>,&amp;overflow);<br>    set_system_gate(<span class="hljs-number">5</span>,&amp;bounds);<br>    set_trap_gate(<span class="hljs-number">6</span>,&amp;invalid_op);<br>    set_trap_gate(<span class="hljs-number">7</span>,&amp;device_not_available);<br>    set_trap_gate(<span class="hljs-number">8</span>,&amp;double_fault);<br>    set_trap_gate(<span class="hljs-number">9</span>,&amp;coprocessor_segment_overrun);<br>    set_trap_gate(<span class="hljs-number">10</span>,&amp;invalid_TSS);<br>    set_trap_gate(<span class="hljs-number">11</span>,&amp;segment_not_present);<br>    set_trap_gate(<span class="hljs-number">12</span>,&amp;stack_segment);<br>    set_trap_gate(<span class="hljs-number">13</span>,&amp;general_protection);<br>    set_trap_gate(<span class="hljs-number">14</span>,&amp;page_fault);<br>    set_trap_gate(<span class="hljs-number">15</span>,&amp;reserved);<br>    set_trap_gate(<span class="hljs-number">16</span>,&amp;coprocessor_error);<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">17</span>;i&lt;<span class="hljs-number">48</span>;i++)<br>        set_trap_gate(i,&amp;reserved);<br>    set_trap_gate(<span class="hljs-number">45</span>,&amp;irq13);<br>    outb_p(inb_p(<span class="hljs-number">0x21</span>)&amp;<span class="hljs-number">0xfb</span>,<span class="hljs-number">0x21</span>);<br>    outb(inb_p(<span class="hljs-number">0xA1</span>)&amp;<span class="hljs-number">0xdf</span>,<span class="hljs-number">0xA1</span>);<br>    set_trap_gate(<span class="hljs-number">39</span>,llel_interrupt);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内存初始化–mm-init"><a href="#内存初始化–mm-init" class="headerlink" title="内存初始化–mm_init()"></a>内存初始化–mm_init()</h4><p>这个主要是内存相关的初始化内容，调用的函数功能基本如名字所示，主要进行了以下初始化设置：</p><ul><li><code>page_ext_init_flatmem()</code>和cgroup的初始化相关，该部分是docker技术的核心部分</li><li><code>mem_init()</code>初始化内存管理的伙伴系统</li><li><code>kmem_cache_init()</code>完成内核slub内存分配体系的初始化，相关的还有<code>buffer_init</code></li><li><code>pgtable_init()</code>完成页表初始化，重新设置一个新的内核页表，并对相应的页表项进行设置，完成映射，包括页表锁<code>ptlock_init()</code>，</li><li><code>vmalloc_init()</code>完成vmalloc的初始化</li><li><code>ioremap_huge_init()</code> ioremap实现I/O内存资源由物理地址映射到虚拟地址空间，此处为其功能的初始化</li><li><code>init_espfix_bsp()</code>和<code>pti_init()</code>完成PTI（page table isolation）的初始化</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Set up kernel memory allocators</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __init <span class="hljs-title function_">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * page_ext requires contiguous pages,</span><br><span class="hljs-comment"> * bigger than MAX_ORDER unless SPARSEMEM.</span><br><span class="hljs-comment"> */</span><br>page_ext_init_flatmem();<br>mem_init();<br>kmem_cache_init();<br>pgtable_init();<br>vmalloc_init();<br>ioremap_huge_init();<br><span class="hljs-comment">/* Should be run before the first non-init thread is created */</span><br>init_espfix_bsp();<br><span class="hljs-comment">/* Should be run after espfix64 is set up. */</span><br>pti_init();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="剩余初始化–rest-init"><a href="#剩余初始化–rest-init" class="headerlink" title="剩余初始化–rest_init()"></a>剩余初始化–rest_init()</h4><p><code>rest_init</code>是非常重要的一步，主要包括了区分内核态和用户态、初始化1号进程和初始化2号进程。</p><p><img src="/2023/06/13/Linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/linux%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="linux内核初始化"></p><h4 id="1号进程的初始化–init进程"><a href="#1号进程的初始化–init进程" class="headerlink" title="1号进程的初始化–init进程"></a>1号进程的初始化–init进程</h4><p>1号进程对于操作系统来说，这是他运行的第一个用户进程，采用的是<code>kernel_thread(kernel_init, NULL, CLONE_FS)</code>创建的，创建的进程的函数是<code>kernel_thread</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Create a kernel thread.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">kernel_thread</span><span class="hljs-params">(<span class="hljs-type">int</span> (*fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kernel_clone_args</span> <span class="hljs-title">args</span> =</span> &#123;<br>        .flags        = ((flags | CLONE_VM | CLONE_UNTRACED) &amp; ~CSIGNAL),<br>        .exit_signal    = (flags &amp; CSIGNAL),<br>        .<span class="hljs-built_in">stack</span>        = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)fn,<br>        .stack_size    = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)arg,<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> _do_fork(&amp;args);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>kernel_init（）</code>为init线程的线程入口函数。在kernel_init()线程函数执行的最后，将启动第一个用户空间进程,核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ramdisk_execute_command) <br>&#123; <br>    ret = run_init_process(ramdisk_execute_command);<br>    ...... <br>&#125;<br>...... <br><span class="hljs-keyword">if</span> (!try_to_run_init_process(<span class="hljs-string">&quot;/sbin/init&quot;</span>) || <br>    !try_to_run_init_process(<span class="hljs-string">&quot;/etc/init&quot;</span>)  || <br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/init&quot;</span>)  || <br>    !try_to_run_init_process(<span class="hljs-string">&quot;/bin/sh&quot;</span>)) <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>这就可以看出，1号线程运行的是一个文件进程，他其实调用的是<code>do_execve()</code>函数,这个函数执行到最后就是去加载<code>elf</code>格式的文件,当将一个文件加载进来内存之后就调用<code>start_thread</code>;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">run_init_process</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *init_filename)</span><br>&#123; <br>    argv_init[<span class="hljs-number">0</span>] = init_filename; <br>    <span class="hljs-keyword">return</span> do_execve(getname_kernel(init_filename), <br>                     (<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *<span class="hljs-type">const</span> __user *)argv_init, <br>                     (<span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *<span class="hljs-type">const</span> __user *)envp_init);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">start_thread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> new_ip, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> new_sp)</span><br>&#123;<br>    set_user_gs(regs, <span class="hljs-number">0</span>);<br>    regs-&gt;fs  = <span class="hljs-number">0</span>;<br>    regs-&gt;ds  = __USER_DS;<br>    regs-&gt;es  = __USER_DS;<br>    regs-&gt;ss  = __USER_DS;<br>    regs-&gt;cs  = __USER_CS;<br>    regs-&gt;ip  = new_ip;<br>    regs-&gt;sp  = new_sp;<br>    regs-&gt;flags  = X86_EFLAGS_IF;<br>    force_iret();<br>&#125;<br>EXPORT_SYMBOL_GPL(start_thread);<br></code></pre></td></tr></table></figure><p>这个函数很重要，就是从内核态切换为用户态，然后运行创建好的线程，上面的<code>force_iret()</code>就是相当于从中断返回。</p><h4 id="2号线程的初始化–kthreadd进程"><a href="#2号线程的初始化–kthreadd进程" class="headerlink" title="2号线程的初始化–kthreadd进程"></a>2号线程的初始化–kthreadd进程</h4><p>rest_init()还创建了一个进程，<code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</code>,这里的函数<code>kthreadd</code>，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。</p><p><code>kthreadd</code>，即2号进程，用于内核态线程的管理，是一个守护线程</p><p>让我们来看一下这个<code>kthreadd</code>做了哪些事情：</p><ul><li>初始化了<code>task</code>结构，并将该线程设置为允许任意CPU运行。</li><li>进入循环，将线程状态设置为<code>TASK_INTERRUPTIBLE</code>，如果当前<code>kthread_create_list</code>为空，没有要创建的线程，则执行<code>schedule()</code>让出CPU资源。</li><li>如果需要创建，则设置为<code>TASK_RUNNING</code>状态，加上锁<code>spin_lock</code>，从链表中取得<code>kthread_create_info</code> 结构的地址，在上文中已经完成插入操作(将<code>kthread_create_info</code>结构中的 list 成员加到链表中，此时根据成员 list 的偏移获得 create)</li><li>调用<code>create_kthread(create)</code>完成线程的创建</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kthreadd</span><span class="hljs-params">(<span class="hljs-type">void</span> *unused)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">tsk</span> =</span> current;<br><br>    <span class="hljs-comment">/* Setup a clean context for our children to inherit. */</span><br>    set_task_comm(tsk, <span class="hljs-string">&quot;kthreadd&quot;</span>);<br>    ignore_signals(tsk);<br>    set_cpus_allowed_ptr(tsk, cpu_all_mask);<br>    set_mems_allowed(node_states[N_MEMORY]);<br><br>    current-&gt;flags |= PF_NOFREEZE;<br>    cgroup_init_kthreadd();<br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        set_current_state(TASK_INTERRUPTIBLE);<br>        <span class="hljs-keyword">if</span> (list_empty(&amp;kthread_create_list))<br>            schedule();<br>        __set_current_state(TASK_RUNNING);<br><br>        spin_lock(&amp;kthread_create_lock);<br>        <span class="hljs-keyword">while</span> (!list_empty(&amp;kthread_create_list)) &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kthread_create_info</span> *<span class="hljs-title">create</span>;</span><br><br>            create = list_entry(kthread_create_list.next,<br>                        <span class="hljs-keyword">struct</span> kthread_create_info, <span class="hljs-built_in">list</span>);<br>            list_del_init(&amp;create-&gt;<span class="hljs-built_in">list</span>);<br>            spin_unlock(&amp;kthread_create_lock);<br><br>            create_kthread(create);<br><br>            spin_lock(&amp;kthread_create_lock);<br>        &#125;<br>        spin_unlock(&amp;kthread_create_lock);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用了<code>create_kthread(create)</code>;这个函数又调用了<code>kernel_thread()</code>;只不过传入的函数是<code>kthread</code>,参数是kthread_create_info类型，里面包含了具体的线程执行动作函数<code>threadfn</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">create_kthread</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kthread_create_info *create)</span><br>&#123;<br>    <span class="hljs-type">int</span> pid;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_NUMA</span><br>    current-&gt;pref_node_fork = create-&gt;node;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* We want our own signal handler (we take no signals by default). */</span><br>    pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/* If user was SIGKILLed, I release the structure. */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">done</span> =</span> xchg(&amp;create-&gt;done, <span class="hljs-literal">NULL</span>);<br><br>        <span class="hljs-keyword">if</span> (!done) &#123;<br>            kfree(create);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        create-&gt;result = ERR_PTR(pid);<br>        complete(done);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新创建的线程由于执行了 schedule() 调度，此时并没有执行，直到我们使用<code>wake_up_process(p)</code>唤醒新创建的线程。线程被唤醒后, 会接着执行最后一段<code>threadfn(data)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">kthread</span><span class="hljs-params">(<span class="hljs-type">void</span> *_create)</span><br>&#123;<br>    <span class="hljs-comment">/* Copy data: it&#x27;s on kthread&#x27;s stack */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kthread_create_info</span> *<span class="hljs-title">create</span> =</span> _create;<br>    <span class="hljs-type">int</span> (*threadfn)(<span class="hljs-type">void</span> *data) = create-&gt;threadfn;<br>    <span class="hljs-type">void</span> *data = create-&gt;data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">completion</span> *<span class="hljs-title">done</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kthread</span> *<span class="hljs-title">self</span>;</span><br>    <span class="hljs-type">int</span> ret;<br><br>    self = kzalloc(<span class="hljs-keyword">sizeof</span>(*self), GFP_KERNEL);<br>    set_kthread_struct(self);<br><br>    <span class="hljs-comment">/* If user was SIGKILLed, I release the structure. */</span><br>    done = xchg(&amp;create-&gt;done, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (!done) &#123;<br>        kfree(create);<br>        do_exit(-EINTR);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!self) &#123;<br>        create-&gt;result = ERR_PTR(-ENOMEM);<br>        complete(done);<br>        do_exit(-ENOMEM);<br>    &#125;<br><br>    self-&gt;data = data;<br>    init_completion(&amp;self-&gt;exited);<br>    init_completion(&amp;self-&gt;parked);<br>    current-&gt;vfork_done = &amp;self-&gt;exited;<br><br>    <span class="hljs-comment">/* OK, tell user we&#x27;re spawned, wait for stop or wakeup */</span><br>    __set_current_state(TASK_UNINTERRUPTIBLE);<br>    create-&gt;result = current;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Thread is going to call schedule(), do not preempt it,</span><br><span class="hljs-comment">     * or the creator may spend more time in wait_task_inactive().</span><br><span class="hljs-comment">     */</span><br>    preempt_disable();<br>    complete(done);<br>    schedule_preempt_disabled();<br>    preempt_enable();<br><br>    ret = -EINTR;<br>    <span class="hljs-keyword">if</span> (!test_bit(KTHREAD_SHOULD_STOP, &amp;self-&gt;flags)) &#123;<br>        cgroup_kthread_ready();<br>        __kthread_parkme(self);<br>        ret = threadfn(data);<br>    &#125;<br>    do_exit(ret);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于kthread函数可以看一些这个<a href="https://zhuanlan.zhihu.com/p/581587583">https://zhuanlan.zhihu.com/p/581587583</a></p><ul><li><p>第2号进程创建完成之后，就一直运行在内核态了，主要负责线程的管理和调度</p></li><li><p>第2号进程会循环检测<code>kthread_create_list</code>全局链表, 当我们调用<code>kernel_thread</code>创建内核线程时，新线程会被加入到此链表中，因此所有的内核线程都是直接或者间接的以kthreadd为父进程</p></li><li><p>检测到新线程创建，则调用<code>kernel_thread()</code>创建线程，其回调为<code>kthread</code></p></li><li><p><code>kthread</code>在创建完后调用<code>schedule()</code>让出CPU资源，而不是直接运行。等待收到<code>wake_up_process(p)</code>的唤醒后再继续执行<code>threadfn(data)</code>。</p></li></ul><blockquote><p>我们可以得出：</p></blockquote><ul><li>任何一个内核线程入口都是 kthread()</li><li>通过<code>kthread</code>创建的内核线程不会立刻运行，需要手工 <code>wake up</code>.</li><li>通过<code>kthread 创建的内核线程有可能不会执行相应线程函数</code>threadfn`而直接退出</li></ul><p>  回到<code>rest_init()</code>，当完成了1号2号进程的创建后，我们将0号进程真正归位idle进程，结束<code>rest_init()</code>，也正事结束了<code>start_kernel()</code>函数，由此，内核初始化全部完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-mmap内存映射</title>
    <link href="/2023/06/13/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
    <url>/2023/06/13/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-mmap内存映射"><a href="#Linux-mmap内存映射" class="headerlink" title="Linux-mmap内存映射"></a>Linux-mmap内存映射</h1><p><img src="/2023/06/13/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/mmap%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84.png" alt="mmap文件映射"></p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>用户态调用<code>malloc()</code>会分配堆内存空间，而实际上则是完成了一次用户态的内存映射，根据分配空间的大小，内存映射对应的系统调用主要有<code>brk()</code>和<code>mmap()</code>(当然我们也可以直接调用<code>mmap()</code>来映射文件)。对小块内存（小于 128K），C 标准库使用 <code>brk()</code> 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。而大块内存（大于 128K），则直接使用内存映射 <code>mmap()</code> 来分配，也就是在文件映射段找一块空闲内存分配出去。这两种方式，自然各有优缺点。</p><p>  <code>brk()</code> 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。</p><p>   <code>mmap()</code> 方式分配的内存，会在释放时直接归还系统，所以每次 <code>mmap()</code> 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 <code>malloc()</code> 只对大块内存使用 <code>mmap()</code> 的原因。</p><p>下面我们将对mmap的底层实现原理进行探析：</p><h2 id="mmap原理"><a href="#mmap原理" class="headerlink" title="mmap原理"></a>mmap原理</h2><p>mmap一般用于大内存的申请，mmap是直接将虚拟内存空间映射到物理内存空间，mmap可以实现两种功能：</p><ul><li>实现虚拟内存到物理内存的映射</li><li>映射文件到自己的虚拟内存空间，这样就可以不通过read/write等系统调用来操作文件，可以直接在用户态访问。</li></ul><h3 id="mmap系统调用"><a href="#mmap系统调用" class="headerlink" title="mmap系统调用"></a>mmap系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">SYSCALL_DEFINE6(mmap, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, len,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, prot, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, flags,<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, off)<br>&#123;<br>    <span class="hljs-type">long</span> error;<br>    error = -EINVAL;<br>    <span class="hljs-keyword">if</span> (off &amp; ~PAGE_MASK)<br>        <span class="hljs-keyword">goto</span> out;<br>    error = ksys_mmap_pgoff(addr, len, prot, flags, fd, off &gt;&gt; PAGE_SHIFT);<br>out:<br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要调用<code>ksys_mmap_pgoff()</code>函数，这里逻辑如下：</p><ul><li>判断类型是否为匿名映射，如果不是则为文件映射，调用<code>fget()</code>获取文件描述符</li><li>如果是匿名映射，判断是否为大页，如果是则进行对齐处理并调用<code>hugetlb_file_setup()</code>获取文件描述符</li><li>调用<code>vm_mmap_pgoff()</code>函数找寻可以映射的区域并建立映射</li></ul><p><code>vm_mmap_pgoff()</code>函数调用<code>do_mmap_pgoff()</code>，实际调用<code>do_mmap()</code>函数，我们直接看这个<code>do_mmap()</code>函数：这个函数主要调用<code>get_unmapped_area</code>和<code>mmap_region</code>这两个函数，一个负责申请大内存，一个负责映射关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">do_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> prot,</span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">vm_flags_t</span> vm_flags,</span><br><span class="hljs-params">            <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *populate,</span><br><span class="hljs-params">            <span class="hljs-keyword">struct</span> list_head *uf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-type">int</span> pkey = <span class="hljs-number">0</span>;<br>    *populate = <span class="hljs-number">0</span>;<br>......<br>    <span class="hljs-comment">/* Obtain the address to map to. we verify (or select) it and ensure</span><br><span class="hljs-comment">     * that it represents a valid section of the address space.</span><br><span class="hljs-comment">     */</span><br>    addr = get_unmapped_area(file, addr, len, pgoff, flags);<br>......<br>    addr = mmap_region(file, addr, len, vm_flags, pgoff, uf);<br>    <span class="hljs-keyword">if</span> (!IS_ERR_VALUE(addr) &amp;&amp;<br>        ((vm_flags &amp; VM_LOCKED) ||<br>         (flags &amp; (MAP_POPULATE | MAP_NONBLOCK)) == MAP_POPULATE))<br>        *populate = len;<br>    <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们先看<code>get_unmapped_area()</code>函数，</p><ul><li>如果是匿名映射，则调用<code>get_umapped_area</code>函数指针，这个函数其实是 <code>arch_get_unmapped_area()</code>。它会调用 <code>find_vma_prev()</code>，在表示虚拟内存区域的 <code>vm_area_struct</code> 红黑树上找到相应的位置。之所以叫 <code>prev</code>，是说这个时候虚拟内存区域还没有建立，找到前一个 <code>vm_area_struct</code>。</li><li>如果是映射到一个文件，在 Linux 里面每个打开的文件都有一个 <code>struct file</code> 结构，里面有一个 <code>file_operations</code>用来表示和这个文件相关的操作。如果是我们熟知的 <code>ext4</code> 文件系统，调用的也是<code>get_unmapped_area</code> 函数指针。</li></ul><p>逻辑如图：</p><p><img src="/2023/06/13/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/1075436-20190524140149261-1192606308.png" alt="img"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br><span class="hljs-title function_">get_unmapped_area</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span><br><span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-title function_">long</span> <span class="hljs-params">(*get_area)</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>,</span><br><span class="hljs-params">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error = arch_mmap_check(addr, len, flags);<br>    <span class="hljs-keyword">if</span> (error)<br>        <span class="hljs-keyword">return</span> error;<br>    <span class="hljs-comment">/* Careful about overflows.. */</span><br>    <span class="hljs-keyword">if</span> (len &gt; TASK_SIZE)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    get_area = current-&gt;mm-&gt;get_unmapped_area;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        <span class="hljs-keyword">if</span> (file-&gt;f_op-&gt;get_unmapped_area)<br>            get_area = file-&gt;f_op-&gt;get_unmapped_area;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (flags &amp; MAP_SHARED) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * mmap_region() will call shmem_zero_setup() to create a file,</span><br><span class="hljs-comment">         * so use shmem&#x27;s get_unmapped_area in case it can be huge.</span><br><span class="hljs-comment">         * do_mmap_pgoff() will clear pgoff, so match alignment.</span><br><span class="hljs-comment">         */</span><br>        pgoff = <span class="hljs-number">0</span>;<br>        get_area = shmem_get_unmapped_area;<br>    &#125;<br>    addr = get_area(file, addr, len, pgoff, flags);<br>    <span class="hljs-keyword">if</span> (IS_ERR_VALUE(addr))<br>        <span class="hljs-keyword">return</span> addr;<br>    <span class="hljs-keyword">if</span> (addr &gt; TASK_SIZE - len)<br>        <span class="hljs-keyword">return</span> -ENOMEM;<br>    <span class="hljs-keyword">if</span> (offset_in_page(addr))<br>        <span class="hljs-keyword">return</span> -EINVAL;<br>    error = security_mmap_addr(addr);<br>    <span class="hljs-keyword">return</span> error ? error : addr;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap_region()</code>首先会再次检测地址空间是否满足要求，然后清除旧的映射，校验内存的可用性，在一切均满足的情况下调用<code>vma_link()</code>将新创建的<code>vm_area_struct</code>结构挂在<code>mm_struct</code>内的红黑树上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">mmap_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span><br><span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len, <span class="hljs-type">vm_flags_t</span> vm_flags, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff,</span><br><span class="hljs-params">        <span class="hljs-keyword">struct</span> list_head *uf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">mm</span> =</span> current-&gt;mm;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span>, *<span class="hljs-title">prev</span>;</span><br>    <span class="hljs-type">int</span> error;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rb_node</span> **<span class="hljs-title">rb_link</span>, *<span class="hljs-title">rb_parent</span>;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> charged = <span class="hljs-number">0</span>;<br>......<br>    vma_link(mm, vma, prev, rb_link, rb_parent);<br>    <span class="hljs-comment">/* Once vma denies write, undo our temporary denial count */</span><br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        <span class="hljs-keyword">if</span> (vm_flags &amp; VM_SHARED)<br>            mapping_unmap_writable(file-&gt;f_mapping);<br>        <span class="hljs-keyword">if</span> (vm_flags &amp; VM_DENYWRITE)<br>            allow_write_access(file);<br>    &#125;<br>    file = vma-&gt;vm_file;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>最后调用到<code>__vma_link_file()</code>会对文件映射进行处理，在file结构体中成员f_mapping指向address_space结构体，该结构体中存储红黑树i_mmap挂载vm_area_struct。也就是说这个进程的VMA和这个file已经绑定在一起了，完成了逻辑上的映射关系了，也就是虚拟地址和file的映射，但是并没有物理地址的映射。</p><ul><li>创建了一个<code>vm_area_struct</code>，然后将其挂在了<code>mm_struct</code>红黑树中以及<code>address_space</code>中的红黑树中。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __vma_link_file(<span class="hljs-keyword">struct</span> vm_area_struct *vma)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span>;</span><br>    file = vma-&gt;vm_file;<br>    <span class="hljs-keyword">if</span> (file) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span> =</span> file-&gt;f_mapping;<br>        <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_DENYWRITE)<br>            <span class="hljs-type">atomic_dec</span>(&amp;file_inode(file)-&gt;i_writecount);<br>        <span class="hljs-keyword">if</span> (vma-&gt;vm_flags &amp; VM_SHARED)<br>            <span class="hljs-type">atomic_inc</span>(&amp;mapping-&gt;i_mmap_writable);<br>        flush_dcache_mmap_lock(mapping);<br>        vma_interval_tree_insert(vma, &amp;mapping-&gt;i_mmap);<br>        flush_dcache_mmap_unlock(mapping);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们完成了用户态内存的映射，但是此处仅在虚拟内存中建立了新的区域，尚未真正访问物理内存。物理内存的访问只有在调度到该进程时才会真正分配，即发生缺页异常时分配。</p><h2 id="用户态缺页异常"><a href="#用户态缺页异常" class="headerlink" title="用户态缺页异常"></a>用户态缺页异常</h2><p>一旦开始访问虚拟内存的某个地址，如果我们发现，并没有对应的物理页，那就出发缺页中断，调用<code>do_page_fault</code></p><ul><li>如果是在内核态发生缺页中断，那么就调用的是``vmalloc_fault`</li><li>如果是用户态，就先通过<code>find_vam</code>找到对应的<code>vm_area_struct</code></li><li>然后调用<code>handle_mm_fault</code>来进行申请内存并建立映射关系</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * This routine handles page faults.  It determines the address,</span><br><span class="hljs-comment"> * and the problem, and then passes it off to one of the appropriate</span><br><span class="hljs-comment"> * routines.</span><br><span class="hljs-comment"> */</span><br>asmlinkage <span class="hljs-type">void</span> __kprobes <span class="hljs-title function_">do_page_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs *regs,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> error_code,</span><br><span class="hljs-params">                    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address)</span><br>&#123;<br>......<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * We fault-in kernel-space virtual memory on-demand. The</span><br><span class="hljs-comment">     * &#x27;reference&#x27; page table is init_mm.pgd.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * NOTE! We MUST NOT take any locks for this case. We may</span><br><span class="hljs-comment">     * be in an interrupt or a critical region, and should</span><br><span class="hljs-comment">     * only copy the information from the master page table,</span><br><span class="hljs-comment">     * nothing more.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (unlikely(fault_in_kernel_space(address))) &#123;<br>        <span class="hljs-keyword">if</span> (vmalloc_fault(address) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (notify_page_fault(regs, vec))<br>            <span class="hljs-keyword">return</span>;<br>        bad_area_nosemaphore(regs, error_code, address);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>......<br>    vma = find_vma(mm, address);<br>......<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If for any reason at all we couldn&#x27;t handle the fault,</span><br><span class="hljs-comment">     * make sure we exit gracefully rather than endlessly redo</span><br><span class="hljs-comment">     * the fault.</span><br><span class="hljs-comment">     */</span><br>    fault = handle_mm_fault(vma, address, flags);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">vm_fault_t</span> <span class="hljs-title function_">handle_mm_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_area_struct *vma, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> address,</span><br><span class="hljs-params">        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span><br>&#123;<br>......<br>    <span class="hljs-keyword">if</span> (unlikely(is_vm_hugetlb_page(vma)))<br>        ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);<br>    <span class="hljs-keyword">else</span><br>        ret = __handle_mm_fault(vma, address, flags);<br>......<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>__handle_mm_fault()</code>完成实际上的映射操作。这里涉及到了由<code>pgd, p4g, pud, pmd, pte</code>组成的五级页表，页表索引填充完后调用<code>handle_pte_fault()</code>创建页表项。</p><p><code>handle_pte_fault</code>主要处理三种情况：</p><ul><li>页表项从未出现过，即新映射页表项<ul><li>匿名页映射，则映射到物理内存页，调用<code>do_anonymous_page()</code></li><li>文件映射，调用<code>do_fault()</code></li></ul></li><li>页表项曾出现过，则为从物理内存换出的页，调用<code>do_swap_page()</code>换回来</li></ul><p><img src="/2023/06/13/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/1075436-20190527174134584-2009167765.png" alt="img"></p><p>匿名页调用</p><p><img src="/2023/06/13/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/1075436-20190527174244200-2102497879.png" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">vm_fault_t</span> <span class="hljs-title function_">handle_pte_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_fault *vmf)</span><br>&#123;<br>    <span class="hljs-type">pte_t</span> entry;<br>......<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * A regular pmd is established and it can&#x27;t morph into a huge</span><br><span class="hljs-comment">         * pmd from under us anymore at this point because we hold the</span><br><span class="hljs-comment">         * mmap_sem read mode and khugepaged takes it in write mode.</span><br><span class="hljs-comment">         * So now it&#x27;s safe to run pte_offset_map().</span><br><span class="hljs-comment">         */</span><br>        vmf-&gt;pte = pte_offset_map(vmf-&gt;pmd, vmf-&gt;address);<br>        vmf-&gt;orig_pte = *vmf-&gt;pte;<br>......<br>    <span class="hljs-keyword">if</span> (!vmf-&gt;pte) &#123;<br>        <span class="hljs-keyword">if</span> (vma_is_anonymous(vmf-&gt;vma))<br>            <span class="hljs-keyword">return</span> do_anonymous_page(vmf);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> do_fault(vmf);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!pte_present(vmf-&gt;orig_pte))<br>        <span class="hljs-keyword">return</span> do_swap_page(vmf);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h3><p>我们上面分析了，如果是文件映射，那么就会调用<code>do_fault()</code>函数，映射文件<code>do_fault()</code>函数调用了<code>fault</code>函数，该函数实际会根据不同的文件系统调用不同的函数。如<code>ext4</code>文件系统中<code>vm_ops</code>指向<code>ext4_file_vm_ops</code>，实际调用<code>ext4_filemap_fault()</code>函数，该函数会调用<code>filemap_fault()</code>完成实际的文件映射操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">vm_fault_t</span> <span class="hljs-title function_">do_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_fault *vmf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_area_struct</span> *<span class="hljs-title">vma</span> =</span> vmf-&gt;vma;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span> *<span class="hljs-title">vm_mm</span> =</span> vma-&gt;vm_mm;<br>    <span class="hljs-type">vm_fault_t</span> ret;<br><br>    <span class="hljs-keyword">if</span> (!vma-&gt;vm_ops-&gt;fault) &#123;  <span class="hljs-comment">// 这里调用了指定的文件系统的fault函数 ，这里的赋值在前面的mmap_region实现的</span><br>......<br>&#125;<br><span class="hljs-type">vm_fault_t</span> <span class="hljs-title function_">ext4_filemap_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_fault *vmf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> file_inode(vmf-&gt;vma-&gt;vm_file);<br>......<br>    ret = filemap_fault(vmf); <br>......<br>&#125;<br></code></pre></td></tr></table></figure><p><code>filemap_fault</code>会先调用<code>find_get_page</code>去寻址那个页，如果在缓存中找到了则调用<code>do_async_mmap_readahead()</code>，预读一些数据到内存里面，否则调用<code>pagecache_get_page()</code>分配一个缓存页，将该页加入LRU表中，并在<code>address_space</code>中调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">vm_fault_t</span> <span class="hljs-title function_">filemap_fault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_fault *vmf)</span><br>&#123;<br>    <span class="hljs-type">int</span> error;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">file</span> =</span> vmf-&gt;vma-&gt;vm_file;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">fpin</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span> *<span class="hljs-title">mapping</span> =</span> file-&gt;f_mapping;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_ra_state</span> *<span class="hljs-title">ra</span> =</span> &amp;file-&gt;f_ra;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> mapping-&gt;host;<br>......<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Do we have something in the page cache already?</span><br><span class="hljs-comment">     */</span><br>    page = find_get_page(mapping, offset);   <span class="hljs-comment">// 根据这个mapping和offset我们就能够在address_space中找到对应的page</span><br>    <span class="hljs-keyword">if</span> (likely(page) &amp;&amp; !(vmf-&gt;flags &amp; FAULT_FLAG_TRIED)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * We found the page, so try async readahead before</span><br><span class="hljs-comment">         * waiting for the lock.</span><br><span class="hljs-comment">         */</span><br>        fpin = do_async_mmap_readahead(vmf, page);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!page) &#123;<br>        <span class="hljs-comment">/* No page in the page cache at all */</span><br>......       <br>&#125;<br>    <br><span class="hljs-keyword">struct</span> page *pagecache_get_page(<span class="hljs-keyword">struct</span> address_space *mapping, <span class="hljs-type">pgoff_t</span> offset,<br>    <span class="hljs-type">int</span> fgp_flags, <span class="hljs-type">gfp_t</span> gfp_mask)<br>&#123;<br>......<br>        page = __page_cache_alloc(gfp_mask);<br>......<br>        err = add_to_page_cache_lru(page, mapping, offset, gfp_mask);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>对于内存中不存在的，就是利用<code>address_space</code>中的<code>address_space_operations </code>的<code>readpage </code>函数将文件内存读取到内存中，并返回这个新申请的page。</p><p>这样我们就完成了进程的虚拟地址和文件缓存的映射关系了，当访问这个虚拟地址时，就是相当于操作了文件了，因为他们都映射着同一个物理页，利用这一点我们可以实现进程间共享内存的通信。</p><h3 id="swap页面"><a href="#swap页面" class="headerlink" title="swap页面"></a>swap页面</h3><p>前文提到了我们会通过主动回收或者被动回收的方式将物理内存已映射的页面回收至硬盘中，当数据再次访问时，我们又需要通过<code>do_swap_page()</code>将其从硬盘中读回来。<code>do_swap_page()</code> 函数逻辑流程如下：查找 <code>swap</code> 文件有没有缓存页。如果没有，就调用 <code>swapin_readahead()</code>将 <code>swap</code> 文件读到内存中来形成内存页，并通过 <code>mk_pte()</code> 生成页表项。<code>set_pte_at</code> 将页表项插入页表，<code>swap_free</code> 将 <code>swap</code> 文件清理。因为重新加载回内存了，不再需要 <code>swap</code> 文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">vm_fault_t</span> <span class="hljs-title function_">do_swap_page</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> vm_fault *vmf)</span><br>&#123;<br>......<br>    entry = pte_to_swp_entry(vmf-&gt;orig_pte);<br>......<br>    page = lookup_swap_cache(entry, vma, vmf-&gt;address);<br>    swapcache = page;<br>    <span class="hljs-keyword">if</span> (!page) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">swap_info_struct</span> *<span class="hljs-title">si</span> =</span> swp_swap_info(entry);<br>        <span class="hljs-keyword">if</span> (si-&gt;flags &amp; SWP_SYNCHRONOUS_IO &amp;&amp;<br>                __swap_count(si, entry) == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">/* skip swapcache */</span><br>            page = alloc_page_vma(GFP_HIGHUSER_MOVABLE, vma,<br>                            vmf-&gt;address);<br>......<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            page = swapin_readahead(entry, GFP_HIGHUSER_MOVABLE,<br>                        vmf);<br>            swapcache = page;<br>        &#125;<br>......<br>    pte = mk_pte(page, vma-&gt;vm_page_prot);<br>......<br>    set_pte_at(vma-&gt;vm_mm, vmf-&gt;address, vmf-&gt;pte, pte);<br>    arch_do_swap_page(vma-&gt;vm_mm, vma, vmf-&gt;address, pte, vmf-&gt;orig_pte);<br>    vmf-&gt;orig_pte = pte;<br>......<br>    swap_free(entry);<br>......<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的I/O与驱动</title>
    <link href="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/"/>
    <url>/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux的I-O与驱动"><a href="#Linux的I-O与驱动" class="headerlink" title="Linux的I/O与驱动"></a>Linux的I/O与驱动</h1><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/14bc3d26efe093d3eada173f869146b1.png" alt="img"></p><p>本文我们将了解一下linux的IO原理以及linux是如何操作不同的设备的，其实就是linux的设备驱动的工作逻辑。</p><p>【参考资料】</p><p><a href="https://segmentfault.com/a/1190000038700641"><strong>Linux I/O 原理和 Zero-copy 技术全面揭秘</strong></a></p><p><a href="https://www.ilinuxkernel.com/files/Linux.Generic.Block.Layer.pdf"><strong>linux通用块设备层.pdf</strong></a></p><p><strong>csapp书籍</strong></p><h2 id="I-O架构"><a href="#I-O架构" class="headerlink" title="I/O架构"></a>I/O架构</h2><p>linux 的IO表示输入输出，指的是一起操作程序或设备和计算机之间发生书籍传输的过程，它主要分为IO设备和IO接口两部分，常见的IO设备有硬盘、鼠标、键盘等，而IO接口指的就是设备控制器，实现cpu和IO设备之间的信息交换。</p><p>linux操作系统的IO架构如图，其中设备控制器和硬件都是属于外设，设备控制器属于IO接口（其实就是对应的设备控制器中的寄存器），驱动程序负责和设备控制器交互，然后设备控制器将控制硬件完成数据的传输。</p><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/image-20230525221457199.png" alt="image-20230525221457199"></p><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/image-20230525221717485.png" alt="image-20230525221717485"></p><p>之前我们已经了解过了关于文件系统读写文件的基本流程，用户进程发起读写请求，然后陷入内核态，先查询page cache是否有要操作的页面，如果有直接进行读写操作，如果没有就调用指定的读写函数到磁盘中，然后将新页面缓存在page cache中。</p><h3 id="I-O模式"><a href="#I-O模式" class="headerlink" title="I/O模式"></a>I/O模式</h3><blockquote><p>这一块内容来自<a href="https://segmentfault.com/a/1190000038700641"><strong>Linux I/O 原理和 Zero-copy 技术全面揭秘</strong></a></p></blockquote><p>I/O模式一般有三种：</p><ul><li>程序控制I/O</li><li>中断驱动I/O</li><li>DMA I/O</li></ul><h4 id="程序控制I-O"><a href="#程序控制I-O" class="headerlink" title="程序控制I/O"></a>程序控制I/O</h4><p>这是最简单的一种 I/O 模式，也叫忙等待或者轮询：用户通过发起一个系统调用，陷入内核态，内核将系统调用翻译成一个对应设备驱动程序的过程调用，接着设备驱动程序会启动 I/O 不断循环去检查该设备，看看是否已经就绪，一般通过返回码来表示，I/O 结束之后，设备驱动程序会把数据送到指定的地方并返回，切回用户态。</p><p>这种I/O也叫做blocking I/O model，如图：</p><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/image-20230526204204341.png" alt="image-20230526204204341"></p><h4 id="中断驱动I-O"><a href="#中断驱动I-O" class="headerlink" title="中断驱动I/O"></a>中断驱动I/O</h4><p>前面那个I/O的缺点是，当执行I/O操作的时候，cpu无法执行其他的事情，一直不断的询问I/O是否完成，这就造成了cpu资源的严重浪费，所以现在有一个中断驱动的I/O来改善这种情况，当操作系统发起一个I/O后，cpu不会一直去询问是否数据ready完成，而是直接去执行其他的动作，当数据准备完成后，设备控制器会产生一个外部中断来通知cpu，表示数据已经准备完成，然后cpu响应中断将数据copy到内存中。</p><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/view.png" alt="preview"></p><p>流程如下：</p><ol><li>用户进程发起一个 <code>read()</code> 系统调用读取磁盘文件，陷入内核态并由其所在的 CPU 通过设备驱动程序向设备寄存器写入一个通知信号，告知设备控制器 (我们这里是磁盘控制器)要读取数据；</li><li>磁盘控制器启动磁盘读取的过程，把数据从磁盘拷贝到磁盘控制器缓冲区里；</li><li>完成拷贝之后磁盘控制器会通过总线发送一个中断信号到中断控制器，如果此时中断控制器手头还有正在处理的中断或者有一个和该中断信号同时到达的更高优先级的中断，则这个中断信号将被忽略，而磁盘控制器会在后面持续发送中断信号直至中断控制器受理；</li><li>中断控制器收到磁盘控制器的中断信号之后会通过地址总线存入一个磁盘设备的编号，表示这次中断需要关注的设备是磁盘；</li><li>中断控制器向 CPU 置起一个磁盘中断信号；</li><li>CPU 收到中断信号之后停止当前的工作，把当前的 PC/PSW 等寄存器压入堆栈保存现场，然后从地址总线取出设备编号，通过编号找到中断向量所包含的中断服务的入口地址，压入 PC 寄存器，开始运行磁盘中断服务，把数据从磁盘控制器的缓冲区拷贝到主存里的内核缓冲区；</li><li>最后 CPU 再把数据从内核缓冲区拷贝到用户缓冲区，完成读取操作，<code>read()</code> 返回，切换回用户态。</li></ol><h4 id="DMA-I-O"><a href="#DMA-I-O" class="headerlink" title="DMA I/O"></a>DMA I/O</h4><p>并发系统的性能高低究其根本，是取决于如何对 CPU 资源的高效调度和使用，而回头看前面的中断驱动 I/O 模式的流程，可以发现第 6、7 步的数据拷贝工作都是由 CPU 亲自完成的，也就是在这两次数据拷贝阶段中 CPU 是完全被占用而不能处理其他工作的，那么这里明显是有优化空间的；第 7 步的数据拷贝是从内核缓冲区到用户缓冲区，都是在主存里，所以这一步只能由 CPU 亲自完成，但是第 6 步的数据拷贝，是从磁盘控制器的缓冲区到主存，是两个设备之间的数据传输，这一步并非一定要 CPU 来完成，可以借助 DMA 来完成，减轻 CPU 的负担。</p><p>DMA 全称是 Direct Memory Access，也即直接存储器存取，是一种用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。整个过程无须 CPU 参与，数据直接通过 DMA 控制器进行快速地移动拷贝，节省 CPU 的资源去做其他工作。</p><p>目前，大部分的计算机都配备了 DMA 控制器，而 DMA 技术也支持大部分的外设和存储器。借助于 DMA 机制，计算机的 I/O 过程就能更加高效：</p><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/view-16851069947733.png" alt="preview"></p><p>DMA 控制器内部包含若干个可以被 CPU 读写的寄存器：一个主存地址寄存器 MAR（存放要交换数据的主存地址）、一个外设地址寄存器 ADR（存放 I/O 设备的设备码，或者是设备信息存储区的寻址信息）、一个字节数寄存器 WC（对传送数据的总字数进行统计）、和一个或多个控制寄存器。</p><ol><li>用户进程发起一个 <code>read()</code> 系统调用读取磁盘文件，陷入内核态并由其所在的 CPU 通过设置 DMA 控制器的寄存器对它进行编程：把内核缓冲区和磁盘文件的地址分别写入 MAR 和 ADR 寄存器，然后把期望读取的字节数写入 WC 寄存器，启动 DMA 控制器；</li><li>DMA 控制器根据 ADR 寄存器里的信息知道这次 I/O 需要读取的外设是磁盘的某个地址，便向磁盘控制器发出一个命令，通知它从磁盘读取数据到其内部的缓冲区里；</li><li>磁盘控制器启动磁盘读取的过程，把数据从磁盘拷贝到磁盘控制器缓冲区里，并对缓冲区内数据的校验和进行检验，如果数据是有效的，那么 DMA 就可以开始了；</li><li>DMA 控制器通过总线向磁盘控制器发出一个读请求信号从而发起 DMA 传输，这个信号和前面的中断驱动 I/O 小节里 CPU 发给磁盘控制器的读请求是一样的，它并不知道或者并不关心这个读请求是来自 CPU 还是 DMA 控制器；</li><li>紧接着 DMA 控制器将引导磁盘控制器将数据传输到 MAR 寄存器里的地址，也就是内核缓冲区；</li><li>数据传输完成之后，返回一个 ack 给 DMA 控制器，WC 寄存器里的值会减去相应的数据长度，如果 WC 还不为 0，则重复第 4 步到第 6 步，一直到 WC 里的字节数等于 0；</li><li>收到 ack 信号的 DMA 控制器会通过总线发送一个中断信号到中断控制器，如果此时中断控制器手头还有正在处理的中断或者有一个和该中断信号同时到达的更高优先级的中断，则这个中断信号将被忽略，而 DMA 控制器会在后面持续发送中断信号直至中断控制器受理；</li><li>中断控制器收到磁盘控制器的中断信号之后会通过地址总线存入一个主存设备的编号，表示这次中断需要关注的设备是主存；</li><li>中断控制器向 CPU 置起一个 DMA 中断的信号；</li><li>CPU 收到中断信号之后停止当前的工作，把当前的 PC/PSW 等寄存器压入堆栈保存现场，然后从地址总线取出设备编号，通过编号找到中断向量所包含的中断服务的入口地址，压入 PC 寄存器，开始运行 DMA 中断服务，把数据从内核缓冲区拷贝到用户缓冲区，完成读取操作，<code>read()</code> 返回，切换回用户态。</li></ol><h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><p>参考资料：</p><p><a href="https://ty-chen.github.io/linux-kernel-char-device/">字符设备驱动</a></p><p><a href="https://github.com/shornado/mybook/blob/master/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3_%E5%AE%8B%E5%AE%9D%E5%8D%8E.pdf">linux设备驱动开发详解.pdf–宋宝华</a></p><p><a href="https://zhuanlan.zhihu.com/p/482801096">玩转linux内核–字符设备驱动架构</a></p><p><a href="https://www.cnblogs.com/chen-farsight/p/6155518.html#unit1">https://www.cnblogs.com/chen-farsight/p/6155518.html#unit1</a></p><p><a href="https://blog.csdn.net/weixin_45905650/article/details/121459749">https://blog.csdn.net/weixin_45905650/article/details/121459749</a></p><h3 id="1-什么是字符设备"><a href="#1-什么是字符设备" class="headerlink" title="1. 什么是字符设备"></a>1. 什么是字符设备</h3><p>linux系统将设备分为三大类，字符设备、块设备、网络设备。常见的字符设备包括鼠标、键盘等。</p><p>当我们编写字符设备驱动的时候，其主要工作是添加、初始化、删除cdev结构体，申请、释放设备号，填充file_operations结构体中的功能函数，比如open()、read()、write()、close()等。当我们创建一个字符设备时，一般会在/dev目录下生成一个设备文件，Linux用户层的程序就可以通过这个设备文件来操作这个字符设备。</p><h3 id="2-字符设备驱动相关结构"><a href="#2-字符设备驱动相关结构" class="headerlink" title="2. 字符设备驱动相关结构"></a>2. 字符设备驱动相关结构</h3><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/v2-e14e59d101071b1ff39d9854bd248d9b_r.jpg" alt="img"></p><h4 id="cdev"><a href="#cdev" class="headerlink" title="cdev"></a>cdev</h4><p>在Linux内核中，使用cdev结构体来描述一个字符设备，cdev结构体在/include/linux/cdev.h中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kobject</span> <span class="hljs-title">kobj</span>;</span>                  <span class="hljs-comment">//内嵌的内核对象.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>                 <span class="hljs-comment">//该字符设备所在的内核模块的对象指针.</span><br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">ops</span>;</span>    <span class="hljs-comment">//该结构描述了字符设备所能实现的方法，是极为关键的一个结构体.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">list</span>;</span>                <span class="hljs-comment">//用来将已经向内核注册的所有字符设备形成链表.</span><br>    <span class="hljs-type">dev_t</span> dev;                            <span class="hljs-comment">//字符设备的设备号，由主设备号和次设备号构成.</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count;                   <span class="hljs-comment">//隶属于同一主设备号的次设备号的个数.</span><br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>其中的dev_t 定义了设备号，这是一个32位类型的数，高12位代表的是主设备号，低20位是次设别号，主设备号用来区分设备类型，次设备号用来区分同类型的不同设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">MAJOR(dev)  <span class="hljs-comment">/* 从dev_t中获取主设备号 */</span><br>MINOR(dev)  <span class="hljs-comment">/* 从dev_t中获取次设备号 */</span><br>MKDEV(ma,mi)  <span class="hljs-comment">/* 通过主设备号ma和次设备号mi生成dev_t */</span><br></code></pre></td></tr></table></figure><p>所有的字符串设别cdev结构都在cdev_map变量中保存，能够根据设备号快速获取cdev。</p><h4 id="file-operations"><a href="#file-operations" class="headerlink" title="file_operations"></a>file_operations</h4><p>这个是驱动程序的核心内容，它定义了字符串设备驱动提供给VFS虚拟文件系统的接口函数。当用户程序在用户态调用相关的系统调用时，linux就会调用这个结构中对应的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> &#123;</span><br>　　<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">module</span> *<span class="hljs-title">owner</span>;</span>　　<br>　　　　<span class="hljs-comment">/* 模块拥有者，一般为THIS MODULE */</span><br>　　<span class="hljs-type">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);　　<br>　　　　<span class="hljs-comment">/* 从设备中读取数据，成功时返回读取的字节数，出错返回负值 */</span><br>　　<span class="hljs-type">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);　　　<br>　　　　<span class="hljs-comment">/* 向设备发送数据，成功时该函数返回写入字节数。若未被实现，用户调层用write()时系统将返回 -EINVAL*/</span><br>　　<span class="hljs-type">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);　　<br>　　　　<span class="hljs-comment">/* 将设备内存映射内核空间进程内存中，若未实现，用户层调用mmap()系统将返回 -ENODEV */</span><br>　　<span class="hljs-type">long</span> (*unlocked_ioctl)(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> cmd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg);　　<br>　　　　<span class="hljs-comment">/* 提供设备相关控制命令（读写设备参数、状态，控制设备进行读写...）的实现，当调用成功时返回一个非负值 */</span><br>　　<span class="hljs-type">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);　　<br>　　　　<span class="hljs-comment">/* 打开设备 */</span><br>　　<span class="hljs-type">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);　　<br>　　　　<span class="hljs-comment">/* 关闭设备 */</span><br>　　<span class="hljs-type">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">fl_owner_t</span> id);　　<br>　　　　<span class="hljs-comment">/* 刷新设备 */</span><br>　　<span class="hljs-type">loff_t</span> (*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);　　<br>　　　　<span class="hljs-comment">/* 用来修改文件读写位置，并将新位置返回，出错时返回一个负值 */</span><br>　　<span class="hljs-type">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);　　<br>　　　　<span class="hljs-comment">/* 通知设备 FASYNC 标志发生变化 */</span><br>　　<span class="hljs-type">unsigned</span> <span class="hljs-title function_">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span>;　　<br>　　　　<span class="hljs-comment">/* POLL机制，用于询问设备是否可以被非阻塞地立即读写。当询问的条件未被触发时，用户空间进行select()和poll()系统调用将引起进程阻塞 */</span><br>　　...<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h4><p>基本流程是：</p><ul><li><p>申请一个cdev结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> cdev *<span class="hljs-title function_">cdev_alloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;　　<br><span class="hljs-comment">/* 返回值：</span><br><span class="hljs-comment">　　　　成功 cdev 对象首地址</span><br><span class="hljs-comment">　　　　失败：NULL */</span><br></code></pre></td></tr></table></figure></li><li><p>申请一个设备号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_chrdev_region</span><span class="hljs-params">(<span class="hljs-type">dev_t</span> *dev, <span class="hljs-type">unsigned</span> baseminor, <span class="hljs-type">unsigned</span> count, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span>;<br><span class="hljs-comment">/* 参数：</span><br><span class="hljs-comment">　　　　dev_t *dev - 用于保存分配到的第一个设备号（起始）</span><br><span class="hljs-comment">　　　　unsigned baseminor - 起始次设备号</span><br><span class="hljs-comment">　　　　unsigned count - 要分配设备号的数量</span><br><span class="hljs-comment">　　　　const char *name - 设备名</span><br><span class="hljs-comment">   返回值：</span><br><span class="hljs-comment">　　　　成功：0</span><br><span class="hljs-comment">　　　　失败：负数（绝对值是错误码）*/</span><br></code></pre></td></tr></table></figure></li><li><p>初始化这个cdev</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">cdev_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> file_operations *p)</span>;　　<br><span class="hljs-comment">/* 参数：</span><br><span class="hljs-comment">　　　　struct cdev *p - 被初始化的 cdev对象</span><br><span class="hljs-comment">　　　　const struct file_operations *fops - 字符设备操作方法集 */</span><br></code></pre></td></tr></table></figure></li><li><p>注册这个cdev</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cdev_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> cdev *p, <span class="hljs-type">dev_t</span> dev, <span class="hljs-type">unsigned</span> count)</span>;<br><span class="hljs-comment">/* 参数：</span><br><span class="hljs-comment">　　　　struct cdev *p - 被注册的cdev对象</span><br><span class="hljs-comment">　　　　dev_t dev - 设备的第一个设备号</span><br><span class="hljs-comment">　　　　unsigned - 这个设备连续的次设备号数量</span><br><span class="hljs-comment">   返回值：</span><br><span class="hljs-comment">　　　　成功：0</span><br><span class="hljs-comment">　　　　失败：负数（绝对值是错误码）*/</span><br></code></pre></td></tr></table></figure></li><li><p>创建设备文件（在/dev 文件夹下创建一个文件用来表示一个字符设备）</p><p>利用cat /proc/devices查看申请到的设备名，设备号。</p><ol><li>使用mknod手工创建：mknod filename type major minor</li><li>自动创建设备节点:利用udev（mdev）来实现设备文件的自动创建，首先应保证支持udev（mdev），由busybox配置。在驱动初始化代码里调用class_create为该设备创建一个class，再为每个设备调用device_create创建对应的设备。</li></ol><p>详细解析见： <a href="http://www.cnblogs.com/chen-farsight/p/6154941.html">Linux设备文件自动生成</a></p></li></ul><h4 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/current.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br>MODULE_LICENSE(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major = <span class="hljs-number">0</span>; <br><span class="hljs-type">static</span> <span class="hljs-type">int</span> minor = <span class="hljs-number">0</span>; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> count = <span class="hljs-number">3</span>; <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVNAME <span class="hljs-string">&quot;demo&quot;</span> </span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> *<span class="hljs-title">demop</span> =</span> <span class="hljs-literal">NULL</span>; <br><span class="hljs-comment">//打开设备 </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">demo_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span> <br>&#123; <br>　　<span class="hljs-comment">//get command and pid </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__); <br>　　<span class="hljs-comment">//get major and minor from inode </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(major=%d, minor=%d), %s : %s : %d\n&quot;</span>, imajor(inode), iminor(inode), __FILE__, __func__, __LINE__); <br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br><span class="hljs-comment">//关闭设备 </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">demo_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span> <br>&#123; <br>　　<span class="hljs-comment">//get command and pid </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__); <br>　　<span class="hljs-comment">//get major and minor from inode </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(major=%d, minor=%d), %s : %s : %d\n&quot;</span>, imajor(inode), iminor(inode), __FILE__, __func__, __LINE__); <br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br><span class="hljs-comment">//读设备</span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">demo_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span> <br>&#123;<br>　　<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> filp-&gt;f_path.dentry-&gt;d_inode; <br>　　<span class="hljs-comment">//get command and pid </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__); <br>　　<span class="hljs-comment">//get major and minor from inode </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(major=%d, minor=%d), %s : %s : %d\n&quot;</span>, imajor(inode), iminor(inode), __FILE__, __func__, __LINE__); <br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br><span class="hljs-comment">//写设备 </span><br><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title function_">demo_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span> <br>&#123; <br>　　<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">inode</span> =</span> filp-&gt;f_path.dentry-&gt;d_inode; <br>　　<span class="hljs-comment">//get command and pid </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__); <br>　　<span class="hljs-comment">//get major and minor from inode </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(major=%d, minor=%d), %s : %s : %d\n&quot;</span>, imajor(inode), iminor(inode), __FILE__, __func__, __LINE__); <br>　　<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br><span class="hljs-comment">//操作方法集 </span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">fops</span> =</span> &#123;<br>　　.owner = THIS_MODULE, .open = demo_open, <br>　　.release= demo_release, <br>　　.read = demo_read, <br>　　.write = demo_write, <br>&#125;; <br><span class="hljs-comment">//cdev设备模块初始化 </span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title function_">demo_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <br>&#123; <br>　　<span class="hljs-type">dev_t</span> devnum; <span class="hljs-type">int</span> ret; <br>　　<span class="hljs-comment">//get command and pid </span><br>　　printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__); <br>　　<span class="hljs-comment">//1. alloc cdev obj </span><br>　　demop = cdev_alloc(); <br>　　<span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == demop) &#123; <br>　　　　<span class="hljs-keyword">return</span> -ENOMEM; <br>　　&#125;<br>    <span class="hljs-comment">//2. init cdev obj</span><br>    cdev_init(demop, &amp;fops);<br>    ret = alloc_chrdev_region(&amp;devnum, minor, count, DEVNAME);<br>    <span class="hljs-keyword">if</span>(ret)&#123;<br>        <span class="hljs-keyword">goto</span> ERR_STEP;<br>    &#125;<br>    major = MAJOR(devnum);<br>    <span class="hljs-comment">//3. register cdev obj</span><br>    ret = cdev_add(demop, devnum, count);<br>    <span class="hljs-keyword">if</span>(ret)&#123;<br>        <span class="hljs-keyword">goto</span> ERR_STEP1;<br>    &#125;<br>    <span class="hljs-comment">//get command and pid</span><br>    printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d - ok.\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>ERR_STEP1:<br>    unregister_chrdev_region(devnum, count);<br><br>ERR_STEP:<br>    cdev_del(demop);<br>    <span class="hljs-comment">//get command and pid</span><br>    printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d - fail.\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title function_">demo_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">//get command and pid</span><br>    printk(KERN_INFO <span class="hljs-string">&quot;(%s:pid=%d), %s : %s : %d - leave.\n&quot;</span>, current-&gt;comm, current-&gt;pid, __FILE__, __func__, __LINE__);<br>    unregister_chrdev_region(MKDEV(major, minor), count);<br>    cdev_del(demop);<br>&#125;<br><br>module_init(demo_init);<br>module_exit(demo_exit);<br>复制代码<br> test.c<br><br>复制代码<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">char</span> *arg[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span> != num)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s /dev/devfile\n&quot;</span>, arg[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> fd = open(arg[<span class="hljs-number">1</span>], O_RDWR);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &gt; fd)&#123;<br>        perror(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    getchar();<br>    <span class="hljs-type">int</span> ret = read(fd, <span class="hljs-number">0x321</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read: ret = %d.\n&quot;</span>, ret);<br>    getchar();<br>    ret = write(fd, <span class="hljs-number">0x123</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write: ret = %d.\n&quot;</span>, ret);<br>    getchar();<br>    close(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-加载和卸载设备"><a href="#3-加载和卸载设备" class="headerlink" title="3. 加载和卸载设备"></a>3. 加载和卸载设备</h3><p>使用insmod 命令来加载模块，然后就会执行module_init()函数，这个函数会调用驱动程序中的init函数，来初始化这个驱动，对于设别节点的创建，可以使用mknod手动创建，或者使用自动创建也行。这样就完成了驱动程序加载到内核中了。</p><h3 id="4-打开字符设备"><a href="#4-打开字符设备" class="headerlink" title="4. 打开字符设备"></a>4. 打开字符设备</h3><p>在linux中万物皆是文件，上面我们说了当设备驱动程序加载完成后并在dev文件夹下常见一个文件，用来表示这个设备。也就是加载完ko文件后，我们需要这个dev文件夹下面的这个文件，才能通过文件系统的接口对这个设备进行操作。</p><p>在执行mknod的时候，会调用一个系统调用，然后调用user_path_create()位该设备文件创建一个dentry，然后会调用<code>vfs_mknod()</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vfs_mknod</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *dir, <span class="hljs-keyword">struct</span> dentry *dentry, <span class="hljs-type">umode_t</span> mode, <span class="hljs-type">dev_t</span> dev)</span><br>&#123;<br>......<br>    error = dir-&gt;i_op-&gt;mknod(dir, dentry, mode, dev);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>对于<code>/dev</code>目录下的设备驱动来说，他们都是属于<code>devtmpfs</code>文件系统，这个文件系统叫做设备驱动临时文件系统。当调用<code>dir-&gt;i_op-&gt;mknod</code>函数时，会最终调用<code>init_special_inode()</code>函数，对于devtmpfs的inode是比较特殊的，这个inode可以关联字符设备、块设备、FIFO 文件、Socket 等。这里的inode中的file_operations变量指向一个def_chr_fops,这个结构中只有一个open函数，此inode中还包含了一个i_rdev表示指向这个设备的dev_t，通过这个设别号dev_t我们就能够找到刚才注册的cdev了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">init_special_inode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-type">umode_t</span> mode, <span class="hljs-type">dev_t</span> rdev)</span><br>&#123;<br>    inode-&gt;i_mode = mode;<br>    <span class="hljs-keyword">if</span> (S_ISCHR(mode)) &#123;<br>        inode-&gt;i_fop = &amp;def_chr_fops;   <span class="hljs-comment">// 字符设备</span><br>        inode-&gt;i_rdev = rdev;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISBLK(mode)) &#123;<br>        inode-&gt;i_fop = &amp;def_blk_fops;<br>        inode-&gt;i_rdev = rdev;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISFIFO(mode))<br>        inode-&gt;i_fop = &amp;pipefifo_fops;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (S_ISSOCK(mode))<br>        ;  <span class="hljs-comment">/* leave it no_open_fops */</span><br>    <span class="hljs-keyword">else</span><br>        printk(KERN_DEBUG <span class="hljs-string">&quot;init_special_inode: bogus i_mode (%o) for&quot;</span><br>                  <span class="hljs-string">&quot; inode %s:%lu\n&quot;</span>, mode, inode-&gt;i_sb-&gt;s_id,<br>                  inode-&gt;i_ino);    <br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> <span class="hljs-title">def_chr_fops</span> =</span> &#123;<br>    .open = chrdev_open,<br>&#125;;<br></code></pre></td></tr></table></figure><p>执行完成这个<code>mknod</code>指令后，其实就是将这个dev文件夹下的对应的设备文件在内存中创建了一个对应的<code>inode</code>和<code>dentry</code>结构，只是对于<code>inode</code>的<code>file_operations</code>还没有具体绑定。</p><p>接下来我们打开这个设备，打开设备和操作普通文件一样，也会放回一个文件描述符fd，然后在内存中创建一个对应的<code>struct file</code>实例，并将file和dentry和inode绑定，在进程中调用open函数，最终会调用到inode中的open函数，最后调用到<code>chrdev_open</code>(这个是对于字符设备)。</p><p>对于chrdev_open函数，基本逻辑如下：</p><ul><li>调用<code>kobj_lookup()</code>，通过设备号<code>i_cdev</code>关联对应的设备驱动程序</li><li>调用<code>fops_get()</code>将设备驱动程序自己定义的文件操作<code>p-&gt;ops</code>赋值给<code>fops</code></li><li>调用设备驱动程序的 <code>file_operations</code> 的 <code>open()</code> 函数真正打开设备。对于打印机，调用的是 <code>lp_open()</code>。对于鼠标调用的是 <code>input_proc_devices_open()</code>，最终会调用到 <code>logibm_open()</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Called every time a character special file is opened</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">chrdev_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span><br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span> *<span class="hljs-title">fops</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span> *<span class="hljs-title">new</span> =</span> <span class="hljs-literal">NULL</span>;<br>......<br>    p = inode-&gt;i_cdev;<br>......<br>    kobj = kobj_lookup(cdev_map, inode-&gt;i_rdev, &amp;idx);<br>......      <br>    fops = fops_get(p-&gt;ops);<br>......<br>    replace_fops(filp, fops);<br>    <span class="hljs-keyword">if</span> (filp-&gt;f_op-&gt;open) &#123;<br>        ret = filp-&gt;f_op-&gt;open(inode, filp);<br>......<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>以上的流程用一张极客时间的图总结</p></blockquote><p><img src="/2023/06/13/Linux%E4%B8%8B%E7%9A%84IO/2e29767e84b299324ea7fc524a3dcee6.jpeg" alt="img"></p><blockquote><p>对于写入操作基本类似，只不过在读写的时候，要注意数据从内核态复制到用户态以及数据从用户态复制到内核态。</p></blockquote><h2 id="块设备驱动"><a href="#块设备驱动" class="headerlink" title="块设备驱动"></a>块设备驱动</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux中断</title>
    <link href="/2023/04/21/%E4%B8%AD%E6%96%AD/"/>
    <url>/2023/04/21/%E4%B8%AD%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核中断"><a href="#Linux-内核中断" class="headerlink" title="Linux 内核中断"></a>Linux 内核中断</h1><p><a href="https://heapdump.cn/article/4514433">https://heapdump.cn/article/4514433</a> 【详细】</p><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><p><a href="https://www.modb.pro/db/101480">https://www.modb.pro/db/101480</a></p><p>中断是CPU在执行某段程序的时候，发生某种状况，使得CPU不得不停止现在正在运行的程序，转向去执行另一段程序，处理完之后又返回来继续执行原来的程序。</p><p>中断的好处是，使得cpu能够处理一些突发事情，能够及时响应紧急事件，如果没有中断，只能采用轮询的方式，这样效率太低。</p><blockquote><p>中断的分类</p></blockquote><ul><li><p>外部中断：由外部设备产生的中断信号导致的中断，外部中断其实是可以屏蔽的（INTR），但是也有不可屏蔽的中断(NMI)，不可屏蔽的中断有芯片错误、总线故障等;NMI来源有NMI pin引脚和通过系统总线或本地 APIC 串行总线传送模式 NMI 消息。<strong>外部中断都是异步的</strong></p><ul><li>I/O中断：键盘、鼠标、打印机等</li><li>时钟中断</li><li>处理器间中断</li></ul></li><li><p>内部中断：内部中断又分为<strong>软中断</strong>和<strong>异常</strong></p><ul><li><p>由软件产生的中断，比如X86 架构的int指令，这种中断也叫做“陷阱”</p></li><li><p>异常是程序执行期间cpu内部发生错误产生的，比如执行DIV除法指令，而除数为0，就会产生异常，还有pagefault异常等，<strong>异常都是同步的</strong></p><p>分为故障、陷阱、终止</p></li></ul></li></ul><blockquote><p>可屏蔽中断和不可屏蔽中断都有哪些？</p></blockquote><ul><li><p>CPU提供了两条外接引脚用于中断，即NMI和INTR。其中，NMI用于不可屏蔽中断，比如电源掉电，一旦产生，CPU必须立即无条件响应，否则进行其他工作毫无意义，NMI的中断向量号为2；INTR用于可屏蔽中断，主要是外部I/O设备的中断信号，比如打印机中断，这些中断信号需要通过中断控制器传递给CPU；</p><p>基本上外部中断都是可以屏蔽的，他们不仅由每一个对应的中断的标志位控制，还由eflage寄存器中的IF标志位控制，这个是总控开关，SLI是IF置1，打开中断，而CLI是IF置0，关闭所有外部中断。</p></li><li><p><strong>内部中断都是不可屏蔽的</strong>。</p></li></ul><h2 id="中断流程"><a href="#中断流程" class="headerlink" title="中断流程"></a>中断流程</h2><p>中断分为两类，一类是异步中断，也就是外部中断，一类是同步中断，也就是内部中断。当中断发生的时候，进程会从用户态陷入到内核态，首先是从IDTR寄存器中找到中断向量表，然后根据中断号找到指定的中断描述符，根据中断描述符进行特权级的检查，然后获取到处理中断的指令地址。当然在陷入内核态的时候会发生栈的切换，当特权级发生变化的时候就会发生栈的切换，从用户栈切换到内核栈，linux在创建一个进程的时候会分配两个栈，一个用户栈，一个内核栈，用户栈信息保存在task_struct中的mm_struct中，内核栈保存在task_struct中的stack指针中，内核栈在内核空间，用户栈在用户空间。那陷入内核的时候是如何切换栈的呢，当进入内核时发生特权级转换时会将TSS中的esp0和ss0（0级特权级）中的值给放到esp和ss寄存器中，这个tss中的esp0和ss0保存的就是这个进程的内核栈地址。切换完内核栈之后，硬件还会将原来的esp和ss寄存器值压入到内核栈中，并且将cs和eip寄存器压入到内核栈中，为的是中断退出时恢复进程的上下文环境。</p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/4513327.png" alt="img"></p><p>接下来我将讲一下这个中断发生过程的所涉及的概念，比如特权级、中断描述符、用户栈和内核栈结构与切换、用户态和内核态分别产生中断时场景等。</p><h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><p>CPU将特权级分为4个等级，即0，1，2，3其中0级特权级权限最大（也就是我们平常说的内核态所处的特权级），3级特权级权限最小，也就是我们说的用户态处的特权级。</p><blockquote><p>CPL、DPL、RPL区别</p></blockquote><p>CPL代表的是CPU当前所处的特权级（一般和CS中的RPL相等）。intel架构采用的是分段机制，寻址通过段选择子和偏移地址来进行寻址，CS/DS/SS选择子中的低两位就是RPL即请求特权级，这个选择子的高13为是在GDT中的索引，也就是定位到一个指定的段描述符。在段的描述符中有两位表示这个段的特权级（DPL_SEG）。</p><p>选择子（CS/DS/SS寄存器）长度为16，高13位表示在GTD表中的索引，低两位表示RPL，GDT表中的每一项都是一个段描述符，每一个段描述符的中有一个DPL_SEG表示这个段所指向的内容的权限。</p><p>如果我们想要访问某个段，那么就要进行特权级检查，首先要满足CPL &lt;= DPL 并且  RPL &lt;= DPL,只有这样才能访问这个段。但是CPL和RPL不一定相等，因为CPL是表示当前cpu所处的特权级，而RPL在代码段、数据段、栈段的选择子中都有，我们可以在内核态访问用户态的代码段，这个时候CPL= 0；代码段中的RPL=3；然后用户数据段描述符DPL =3 所以此时CPL ！= RPL，所以也可以访问。CPL一般指的是CS寄存器中RPL。</p><blockquote><p>特权级检查：</p></blockquote><p>当访问段的时候，首先会检查CPL是不是数值上小于等于段描述符的DPL，然后再检查RPL是不是数值上小于等于DPL，只有两个都满足的时候才会通过检查。</p><blockquote><p>IDT中断描述符</p></blockquote><p>中断描述符存在IDT中断描述符表中，他是用来描述中断向量对应的中断处理函数地址的。 在中断描述符中，也有一个DPL_DOOR，访问中断描述符时，必须CPL在数值上小于等于DPL_DOOR，它可以实现低特权级到特权级的转变。</p><ul><li>当发生系统调用的时候，会进行特权级检查，此时CPL =3 ，然后通过中断号和中断向量表地址找到指定的中断向量描述符，然后将CPL和中断描述符中的DPL_DOOR进行比较，如果CPL &lt;= DPL 则通过，否则不通过。<strong>系统调用的中断描述符DPL=3.</strong></li><li>当发生外部中断的时候，是不会进行特权级检查的，一般外部中断描述符的DPL_DOOR都设置为0.</li></ul><p>在中断描述符中存在着要访问的段的选择子和偏移地址，通过计算就可以定位到中断处理程序了。</p><p>当特权级检查通过后，将从用户态切换到了内核态了。内核态检查完成后，硬件会执行一系列动作：</p><ul><li>通过TR寄存器找到TSS结构，取出esp0和ss0放到esp和ss寄存器中，然后将旧的esp和ss寄存器的值放到内核栈中</li><li>然后压入旧的cs和eip寄存器到内核栈中，以及将其他的通用寄存器的值压入到内核栈中 SAVE_ALL操作</li><li><strong>把内核代码选择符写入CS寄存器，把内核入口点的线性地址写入EIP寄存器（完成内核态向用户态的切换）</strong>；CS和EIP保存在中断符描述表中。</li></ul><p>上面这几个步骤是软件完成的还是硬件完成的？</p><h3 id="中断描述符"><a href="#中断描述符" class="headerlink" title="中断描述符"></a>中断描述符</h3><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/image-20230423222404610.png" alt="image-20230423222404610"></p><p>中断描述符是存在于中断描述表中（IDT），IDT的地址存放在IDTR寄存器中，IDT一般在物理地址的低地址处，在操作系统启动时会对IDT进行初始化操作。中断向量表是为了在中断发生时定位指定的中断处理函数。</p><p>中断描述符有4中：</p><ul><li>中断门描述符</li><li>陷阱门描述符</li><li>任务门描述符</li><li>调用门描述符</li></ul><p>每个门的作用都是有所区别的，经过不同门硬件也会执行不同的动作</p><ul><li><strong>对于中断门：会在进入中断处理程序时将EFLAGS中的IF标志位置0，关闭外部中断</strong></li><li><strong>对于陷阱门：在进入中断时不会清除IF标志位</strong></li></ul><blockquote><p>在每个描述符中都有两个位表示特权级DPL_DOOR</p></blockquote><blockquote><p><strong>中断特权级检查</strong>：</p></blockquote><ul><li>如果是由软中断int n、int 3和into引起的中断，这些都是进程引起的中断，由用户代码进行控制，那么此时会进行两个特权级检查，<ol><li>CPL的特权级要高于中断描述符中的DPL_DOOR, </li><li>然后CPL特权级还要低于中断描述符中段选择子指定的代码段描述符中的DPL，</li></ol></li><li>如果是外部中断和异常引起的，那么无需检查中断门特权，只需要检查CPL和代码段的DPL就行</li></ul><h3 id="用户栈和内核栈切换"><a href="#用户栈和内核栈切换" class="headerlink" title="用户栈和内核栈切换"></a>用户栈和内核栈切换</h3><p>在发生中断的时候，会出现用户栈和内核栈的切换，操作系统在创建进程的时候，会为每个进程分配一个内核栈和一个用户栈，分别用于内核态和用户态栈的使用。</p><h4 id="tast-struct"><a href="#tast-struct" class="headerlink" title="tast_struct"></a>tast_struct</h4><p>在linux系统，linux使用一个task_struct结构来标识一个进程。task_struct中有很多成员变量来描述这个对应的进程的信息。linux对于进程的调度都是通过task_struct进行的</p><p>对于task_struct结构的详细信息，可以自己看源码。我们这里只讲一些和栈相关的成员变量。</p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDk5NDU1Mg==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p>我们在上面这个图看到，和内核栈相关的变量有thread_info 和 指针stack。</p><blockquote><p>变量stack:</p><ul><li>他就是指向了内核栈的地址，在不同架构上，对于内核栈大小的分配是不一样的</li><li>有可能是8K，也有可能是16K</li></ul><p>内核栈大小由一个THREAD_SIZE限定</p></blockquote><h4 id="内核栈地址"><a href="#内核栈地址" class="headerlink" title="内核栈地址"></a>内核栈地址</h4><p>内核栈的申请是在内核地址空间来申请的，在创建task_struct时，会使用<code>alloc_thread_info_node</code>分配两个连续的页当作内核栈空间，然后将地址存在task_struct中的stack变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> thread_info *<span class="hljs-title function_">alloc_thread_info_node</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct *tsk,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> node)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span> *<span class="hljs-title">page</span> =</span> alloc_kmem_pages_node(node, THREADINFO_GFP,<br>                          THREAD_SIZE_ORDER);<br><br>    <span class="hljs-keyword">return</span> page ? page_address(page) : <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>THREAD_SIZE_ORDER</code>为<code>1</code>，所以分配了<code>2</code>个<code>page</code>，所以我们可以确定，进程的内核栈大小为<code>8k</code>。</p><h4 id="thread-union"><a href="#thread-union" class="headerlink" title="thread_union"></a>thread_union</h4><p>每个进程都有两个栈，一个是用户栈，一个是内核栈，进程的内核栈在kernel中描述是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* * */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">thread_union</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_ARCH_TASK_STRUCT_ON_STACK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> <span class="hljs-title">task</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_THREAD_INFO_IN_TASK</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> <span class="hljs-title">thread_info</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-built_in">stack</span>[THREAD_SIZE/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span>)];<br>&#125;;<br></code></pre></td></tr></table></figure><p>它是一个联合体，THREAD_SIZE根据架构的不同，大小也不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">x86：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE_ORDER1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE(PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br>因此是<span class="hljs-number">8</span>K<br>x86_64：<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE_ORDER(2 + KASAN_STACK_ORDER)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREAD_SIZE  (PAGE_SIZE &lt;&lt; THREAD_SIZE_ORDER)</span><br>PAGE_SIZE默认<span class="hljs-number">4</span>K，KASAN_STACK_ORDER没有定义时为<span class="hljs-number">0</span>，因此是<span class="hljs-number">16</span>K<br><br>ARM：<br><span class="hljs-number">8</span>k<br>ARM64：<br>        <span class="hljs-number">16</span>K<br></code></pre></td></tr></table></figure><h4 id="thread-info"><a href="#thread-info" class="headerlink" title="thread_info"></a>thread_info</h4><p><a href="https://blog.csdn.net/u012294613/article/details/124203358">https://blog.csdn.net/u012294613/article/details/124203358</a></p><p>linux使用task_struct来存储通用的进程信息，然后用thread_info存储架构相关的信息（x86、arm），那么thread_info放在哪里呢？我们可以看到在上面的thread_union有一个条件宏定义。所以它是可以存在内核栈中的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* x86 */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<span class="hljs-comment">/* low level flags */</span><br>u32status;<span class="hljs-comment">/* thread synchronous flags */</span><br>&#125;;<br><br><span class="hljs-comment">/* ARM */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span> &#123;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>flags;<span class="hljs-comment">/* low level flags */</span><br><span class="hljs-type">int</span>preempt_count;<span class="hljs-comment">/* 0 =&gt; preemptable, &lt;0 =&gt; bug */</span><br><span class="hljs-type">mm_segment_t</span>addr_limit;<span class="hljs-comment">/* address limit */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>*<span class="hljs-title">task</span>;</span><span class="hljs-comment">/* main task structure */</span>   <span class="hljs-comment">// </span><br>… … <span class="hljs-comment">// 这个在x86中是没有的。它使用current来定位</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在上面的thread_union可以知道，task_struct和thread_info都是可以放在内核栈中的。</p><p>在早期的linux中，在thread_info中有着一个指向task_struct结构的指针。并且thread_info都是放在内核栈中的。</p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/image-20230424145207004.png" alt="image-20230424145207004"></p><p>但是现在较新的版本的linux都是将thread_info结构放在了task_struct中，这个完全取决于宏的判断。之前将thread_info放在内核栈是为了获取task_struct地址，后面随着硬件的发展，arm_64使用寄存器存放task_struct地址，而X86_64的linux使用一个current_task变量存放地址，所以就将thread_info放在了task_struct中。</p><h4 id="current"><a href="#current" class="headerlink" title="current"></a>current</h4><p>早期的arm和x86 linux可以通过current宏获取当前进程task_struct的地址，通过获取esp中的栈指针，然后通过页对齐就可以找到内核栈的栈顶地址，也就是thread_info地址，然后就可以获取thread_info中的task指针获取task_struct结构。</p><p>但是由于arm_64通用寄存器较多，就将task_struct地址放在了寄存器中了，ARM64使用sp_el0，在进程切换时暂存进程描述符地址。</p><p>对于较新版本的x86 linux使用了一个Per-CPU变量（绑定每个CPU的）存储当前task_struct的指针，在进程切换的时候更新。</p><p>x86_64架构下每个 CPU 当前运行进程的 task_struct 的指针current_task存放到 per-cpu 变量中。<br>ARM64架构下每个 CPU 当前运行进程的 task_struct 的指针current_task存放到 sp_el0 寄存器中。</p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0ODkyMzY=,size_16,color_FFFFFF,t_70#pic_center.png" alt="img"></p><h4 id="用户栈地址"><a href="#用户栈地址" class="headerlink" title="用户栈地址"></a>用户栈地址</h4><p><a href="https://www.cnblogs.com/sky-heaven/p/15991962.html#top">https://www.cnblogs.com/sky-heaven/p/15991962.html#top</a></p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/image-20230424153926113.png" alt="image-20230424153926113"></p><p>在task_struct中有一个mm_struct结构指针，它指向着管理着用户地址空间的结构。</p><p>mm_struct中包含了一个vm_area_struct结构的指针，它其实是vm_area_struct组成的链表的头节点，然后每一个vm_area_struct都对应一个用户空间区域。</p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAT2NlYW4mJlN0YXI=,size_20,color_FFFFFF,t_70,g_se,x_16-16823222807286.png" alt="img"></p><p>用户栈的区域信息也是记录在一个vm_area_struct中。</p><h4 id="用户栈和内核栈的切换"><a href="#用户栈和内核栈的切换" class="headerlink" title="用户栈和内核栈的切换"></a>用户栈和内核栈的切换</h4><p>上面我们介绍了一些内核栈的信息，那么当发生用户栈和内核栈的切换的时候发生了什么</p><blockquote><p>我们以系统调用为例。</p></blockquote><p>其实在上面的中断流程我们已经说够了，当系统进入中断后，特权级检查通过后，就会通过tr寄存器找到tss结构，将tss结构中的esp0和ss0存放到esp和ss寄存器中，这样就实现了栈的切换，然后将之前的esp和ss寄存器值存放到内核栈中，用来中断返回时恢复进程运行环境。</p><p>栈切换完成后，将原来的cs寄存器和eip寄存器值压入内核栈，然后将中断描述符中的段选择子和偏移量放入到cs和eip中，然后再压入通用寄存器等信息。接着开始执行中断处理程序。</p><p><img src="/2023/04/21/%E4%B8%AD%E6%96%AD/978007-20170113165822791-46285459.jpg" alt="img"></p><blockquote><p>什么时候才会发生用户栈和内核栈的切换</p><ul><li>答：只有发生特权级变化的时候才会发生栈的切换</li></ul></blockquote><blockquote><p>在内核态发生中断的时候会发生什么？</p><ul><li>在内核态发生中断（比如外部中断）的时候（一定是针对于同一个CPU来说的），此时使用的栈式内核栈，所以不会引起栈的切换（只有特权级发生改变时才会进行栈的切换），还是使用这个内核栈，只不过会将cs、eip等寄存器存放到内核栈中，然后执行对应的中断程序。</li></ul></blockquote><h4 id="进程切换时栈变化"><a href="#进程切换时栈变化" class="headerlink" title="进程切换时栈变化"></a>进程切换时栈变化</h4><p><a href="https://windmissing.github.io/linux-kernel-notes/2_6/2012-05-22-process-switching-in-linux-2.6.html">https://windmissing.github.io/linux-kernel-notes/2_6/2012-05-22-process-switching-in-linux-2.6.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/75760406?from_voters_page=true">https://zhuanlan.zhihu.com/p/75760406?from_voters_page=true</a></p><p>在进行介绍进程切换时栈变化，我们先介绍一下什么是thread_struct结构</p><h5 id="thread-struct"><a href="#thread-struct" class="headerlink" title="thread_struct"></a>thread_struct</h5><p>这个结构就是在发生进程切换的时候，会将原来的进程的一些寄存器信息保存在这个结构中，从而实现当下一次调度这个进程的时候可以恢复这个进程的上下文信息。</p><p>我们先看一下它成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> &#123;</span><br><span class="hljs-comment">/* cached TLS descriptors. */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">desc_struct</span> <span class="hljs-title">tls_array</span>[<span class="hljs-title">GDT_ENTRY_TLS_ENTRIES</span>];</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp0;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>sysenter_cs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>eip;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>esp;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>fs;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>gs;<br><span class="hljs-comment">/* Hardware debugging registers */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>debugreg[<span class="hljs-number">8</span>];  <span class="hljs-comment">/* %%db0-7 debug registers */</span><br><span class="hljs-comment">/* fault info */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>cr2, trap_no, error_code;<br><span class="hljs-comment">/* floating point info */</span><br><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">i387_union</span><span class="hljs-title">i387</span>;</span><br><span class="hljs-comment">/* virtual 86 mode info */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm86_struct</span> __<span class="hljs-title">user</span> * <span class="hljs-title">vm86_info</span>;</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>screen_bitmap;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>v86flags, v86mask, saved_esp0;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>saved_fs, saved_gs;<br><span class="hljs-comment">/* IO permissions */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*io_bitmap_ptr;<br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>iopl;<br><span class="hljs-comment">/* max allowed port in the bitmap, in bytes: */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>io_bitmap_max;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中比较重要的就是<code>esp0</code>、<code>eip</code>、<code>esp</code>;</p><h5 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h5><blockquote><p>当发生进程切换的时候发生了两件事</p><ul><li>一个是装载新的页表</li><li>一个是切换内核态堆栈和硬件上下文</li></ul></blockquote><p>我们这里只关注内核态栈的变化</p><p>当进程切换的时候，会执行switch_to宏的内容，包含了prev、next、last参数，我们先关注prev和next这两个参数</p><p><a href="https://tupelo-shen.github.io/2020/03/10/Linux%E5%86%85%E6%A0%B813-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/">https://tupelo-shen.github.io/2020/03/10/Linux%E5%86%85%E6%A0%B813-%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2/</a></p><ul><li><p>首先在eax和edx中存放prev和next</p><p> movl  prev ,%eax</p><p> movl  next ,%edx</p></li><li><p>然后将eflags和ebp寄存器保存在prev进程的内核栈中</p></li><li><p><strong>把esp的内容保存到prev-&gt;thread.esp中以使该字段指向prev内核栈的栈顶，这一步其实就是保存此时进程的栈信息</strong></p></li><li><p><strong>然后将next进程的next-&gt;thread.esp装入到esp中，这样就完成了不同进程的内核栈的切换</strong></p></li><li><p>然后又把标记为1的地址存放到pre-&gt;thread.eip中</p></li><li><p>然后将next-&gt;thread.eip压入到next的内核栈</p></li><li><p>然后跳转到__switch_to()函数去，这个函数完成了大部分进程切换的操作，它的参数是prev_p 和next_p</p></li></ul><blockquote><p>__switch_to()函数</p></blockquote><ul><li><p>完成了将next_p-&gt;thread.esp0设置到tss结构的中esp0。这个是用来用户态陷入内核态时获取内核栈地址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">init_tss[cpu].esp0 = next_p-&gt;thread.esp0;<br></code></pre></td></tr></table></figure></li><li><p>将新进程的线程本地存储（TLS）段加载到当前CPU的GDT中。3个段选择器存储在进程描述符的tls_array数组中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cpu_gdt_table[cpu][<span class="hljs-number">6</span>] = next_p-&gt;thread.tls_array[<span class="hljs-number">0</span>];<br>cpu_gdt_table[cpu][<span class="hljs-number">7</span>] = next_p-&gt;thread.tls_array[<span class="hljs-number">1</span>];<br>cpu_gdt_table[cpu][<span class="hljs-number">8</span>] = next_p-&gt;thread.tls_array[<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure></li><li><p>存储fs和gs段寄存器的内容到旧进程的prev_p-&gt;thread.fs和prev_p-&gt;thread.gs中。汇编指令如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">movl %fs, <span class="hljs-number">40</span>(%esi)<br>movl %gs, <span class="hljs-number">44</span>(%esi)<br></code></pre></td></tr></table></figure><p>寄存器esi指向prev_p-&gt;thread结构。gs寄存器用来存放TLS段的地址。fs寄存器实际上windows使用。</p></li></ul><p>……</p><p>以上我们就结束了这个进程切换的时候栈发生的变化。</p><h3 id="x86-64下的系统调用syscall指令"><a href="#x86-64下的系统调用syscall指令" class="headerlink" title="x86_64下的系统调用syscall指令"></a>x86_64下的系统调用syscall指令</h3><p><strong>x86_64架构下较新的linux系统版本的系统调用采用了syscall指令了，不采用int指令产生中断了？</strong></p><p><a href="http://gityuan.com/2016/05/21/syscall/">http://gityuan.com/2016/05/21/syscall/</a></p><p><a href="https://wenfh2020.com/2021/09/05/kernel-syscall/">https://wenfh2020.com/2021/09/05/kernel-syscall/</a> 【详细】</p><p><a href="https://blog.csdn.net/chengwenyang/article/details/117794217">https://blog.csdn.net/chengwenyang/article/details/117794217</a></p><p>在64为 系统中使用syscall指令完成系统调用，这个指令使用了一种特殊的寄存器叫做<strong>特殊模块寄存器（MSR）</strong></p><blockquote><p>这一块后面进行补充，我们先将32位系统搞明白</p></blockquote><h2 id="中断的硬件原理"><a href="#中断的硬件原理" class="headerlink" title="中断的硬件原理"></a>中断的硬件原理</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU-15445 数据库</title>
    <link href="/2023/04/13/CMU-15445/"/>
    <url>/2023/04/13/CMU-15445/</url>
    
    <content type="html"><![CDATA[<h1 id="CMU-15445"><a href="#CMU-15445" class="headerlink" title="CMU-15445"></a>CMU-15445</h1><h2 id="Project1–BufferPool"><a href="#Project1–BufferPool" class="headerlink" title="Project1–BufferPool"></a>Project1–BufferPool</h2><p>这个实验主要是完成一个BufferPool Manager，因为磁盘的读写速度很慢，所以我们将在内存中维护一定大小的内存，作为数据库数据的缓冲区，即创建一个BufferPool来做缓冲区。这个实验主要分三个部分，一个是Lru_replacer ，一个是实现一个bufferpool manager instance，一个是parallel bufferpool manager。</p><h3 id="对象关系整理"><a href="#对象关系整理" class="headerlink" title="对象关系整理"></a>对象关系整理</h3><h3 id="Lru-replacer"><a href="#Lru-replacer" class="headerlink" title="Lru_replacer"></a>Lru_replacer</h3><p>这个是一种置换策略，<strong>最近最少使用</strong>算法，用来将bufferpool中最长时间没有使用的page给剔除内存，从而腾出新的空间。</p><p><a href="https://leetcode.cn/problems/lru-cache/description/">Lru算法leetcode</a></p><p><a href="https://blog.csdn.net/qq_34343254/article/details/110082648">https://blog.csdn.net/qq_34343254/article/details/110082648</a></p><blockquote><p>Lru基本思想：</p><ul><li>首先我们维护一个双向链表，这个链表节点的内容可以理解为我们在内存中要访问的内容</li><li>然后如果某个节点中的内容最近被访问了，那么就将这个链表放到最后面，说明近期的活跃度较高</li><li>如果我们向要从这个链表中拿掉一个节点，则我们可以直接将链表的头部给拿掉</li></ul><p><strong>同时为了能够快速的定位到某个节点，我们需要维护一个hash表，将要访问的内容为key，节点的指针为value，这样我们就可以快速的定位到这个节点。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> capacity = <span class="hljs-number">0</span>;<br>    map&lt;<span class="hljs-type">int</span>,list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt;::iterator&gt; mymap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; mylist;<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mymap.<span class="hljs-built_in">count</span>(key))&#123;<br>            <span class="hljs-keyword">auto</span> iter = mymap[key];<br>            <span class="hljs-type">int</span> val = iter-&gt;second;<br>            mylist.<span class="hljs-built_in">push_back</span>(&#123;iter-&gt;first,iter-&gt;second&#125;);<br>            mylist.<span class="hljs-built_in">erase</span>(iter);<br>            mymap[key] = --mylist.<span class="hljs-built_in">end</span>();<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mymap.<span class="hljs-built_in">count</span>(key))&#123;<br><br>            <span class="hljs-keyword">auto</span> iter = mymap[key];<br>            mylist.<span class="hljs-built_in">erase</span>(iter);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><br>            <span class="hljs-keyword">if</span>(mymap.<span class="hljs-built_in">size</span>() == capacity)&#123;<br>                <span class="hljs-keyword">auto</span> iter = mylist.<span class="hljs-built_in">begin</span>();<br>                mymap.<span class="hljs-built_in">erase</span>(iter-&gt;first);<br>                mylist.<span class="hljs-built_in">erase</span>(iter);<br>            &#125;<br><br>        &#125;<br>        mylist.<span class="hljs-built_in">push_back</span>(&#123;key,value&#125;);<br>        mymap[key] = --mylist.<span class="hljs-built_in">end</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 别人的版本</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) : <span class="hljs-built_in">cap</span>(capacity) &#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(key) == map.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> key_value = *map[key];<br>        cache.<span class="hljs-built_in">erase</span>(map[key]);<br>        cache.<span class="hljs-built_in">push_front</span>(key_value);<br>        map[key] = cache.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">return</span> key_value.second;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (map.<span class="hljs-built_in">find</span>(key) == map.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">size</span>() == cap) &#123;<br>                map.<span class="hljs-built_in">erase</span>(cache.<span class="hljs-built_in">back</span>().first);<br>                cache.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cache.<span class="hljs-built_in">erase</span>(map[key]);<br>        &#125;<br>        cache.<span class="hljs-built_in">push_front</span>(&#123;key, value&#125;);<br>        map[key] = cache.<span class="hljs-built_in">begin</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; cache;<br>    unordered_map&lt;<span class="hljs-type">int</span>, list&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&gt; map;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>我们在这个实验中需要实现几个重要的函数：</p><p><img src="/2023/04/13/CMU-15445/image-20230314164341378.png" alt="image-20230314164341378"></p><p><strong>我们添加了几个重要变量：一个是维护的双向链表，和一个hash表，为了是能够快速定位到要更改的节点。</strong></p></blockquote><h4 id="LRUReplacer-Victim"><a href="#LRUReplacer-Victim" class="headerlink" title="LRUReplacer::Victim"></a>LRUReplacer::Victim</h4><blockquote><p>这个函数用来将链表中的一个长时间不用的frame_id对应的节点抹去，这个frame_id其实就是pages数组的index，然后通过这个我们就能获取到这个位置上的page了，然后将这个page给写入到磁盘中，腾出这个page的空间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个函数用来牺牲一个帧,将这个frame_id对应的节点抹去，并将这个抹去的frame_id防止 *frame_id指针中，这样就获取了抹去的frame_id</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LRUReplacer::Victim</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> *frame_id)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>    <span class="hljs-keyword">if</span>(lru_map_.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-comment">//说明这个链表中没有可以牺牲的帧</span><br>        *frame_id = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    *frame_id = lru_list_.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 返回这个链表的最前面一个，最前面的一个就是要被淘汰的</span><br>    lru_map_.<span class="hljs-built_in">erase</span>(*frame_id); <span class="hljs-comment">// 淘汰了那个节点后，要在map中也将其抹去</span><br>    lru_list_.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">// 将最前面的节点抹去</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LRUReplacer-Pin"><a href="#LRUReplacer-Pin" class="headerlink" title="LRUReplacer::Pin"></a>LRUReplacer::Pin</h4><blockquote><p>这个函数用来将一个指定的frame_id对应的节点给脱离出这个链表，也就是不允许这个被lru算法选中了，不能写回磁盘</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 意味着被pin的页正在cpu使用中，不能被LRU算法选中；将一个帧从牺牲候选队列中移除。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LRUReplacer::Pin</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>    <span class="hljs-keyword">auto</span> iter = lru_map_.<span class="hljs-built_in">find</span>(frame_id); <span class="hljs-comment">// 找到这个frame_id对应的在list链表中的节点</span><br>    <span class="hljs-keyword">if</span>(iter == lru_map_.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-comment">// 表示没有在map中找到对应的元素</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    lru_list_.<span class="hljs-built_in">erase</span>(iter-&gt;second);<br>    lru_map_.<span class="hljs-built_in">erase</span>(iter);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LRUReplacer-Unpin"><a href="#LRUReplacer-Unpin" class="headerlink" title="LRUReplacer::Unpin"></a>LRUReplacer::Unpin</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  这个函数用来将cpu刚使用完成的页对应的frameid加入到lru中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LRUReplacer::Unpin</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span> </span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>    <span class="hljs-keyword">if</span>(lru_map_.<span class="hljs-built_in">find</span>(frame_id) != lru_map_.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-comment">// 说明这个已经在lru缓存中了</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    lru_list_.<span class="hljs-built_in">push_back</span>(frame_id);<br>    <span class="hljs-keyword">auto</span> p = lru_list_.<span class="hljs-built_in">end</span>();<br>    p--; <span class="hljs-comment">// 找到双向链表中的最后一个节点，也就是刚才加的</span><br>    lru_map_[frame_id] = p; <span class="hljs-comment">// 将节点和frame_id的关系加入到map中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BufferPool-Manager"><a href="#BufferPool-Manager" class="headerlink" title="BufferPool Manager"></a>BufferPool Manager</h3><blockquote><p>这个类的作用是管理磁盘和内存之间页的读入和写出</p></blockquote><p>首先我们先介绍一下一个参数：</p><ul><li>FrameId 这个其实就是pages数组的index，pages数组的每一个元素都可以看作一个帧，大小和page相等</li><li>内存中的frame是用来放page的，</li><li>我们使用page_table这个来映射pageid和frameid的关系。</li><li>freelist 代表的是这个pages数组中空闲的frameid，他是一个链表，我们向bufferpool申请空间的时候，我们会先看看freelist是不是为空，如果不为空，就拿下一个分配给申请者，并把这个frameid加入到lruReplacer中，然后在page_table中添加pageid和frameid之间的关系</li></ul><p><img src="/2023/04/13/CMU-15445/image-20230314211944477.png" alt="image-20230314211944477"></p><blockquote><p><strong>我们在上面已经讨论了这个lrureplacer的作用，他就是记录现在已经使用过的frameid对应的空间，也就是表示这些空间上的page现在没有被使用，可以被刷新到磁盘。</strong></p><ul><li>lrureplacer只记录了frameid</li><li>代表此时这些对应的空间上的page可以被写入到磁盘</li></ul></blockquote><blockquote><p>关于 pin_count 的作用：</p><ul><li><ul><li>task1中的Unpin：若pin_count==0，将此页的frameID（物理地址）放入LRUReplacer</li><li>pin_count：有多少线程正在使用当前页</li><li>规定：被pin住的页面不允许被free，不允许写入磁盘</li></ul></li><li><p>pin_count何时能够设置为0：</p></li><li><ul><li>delete时一定可以设置为0</li><li>unpin时，pincout–；</li></ul></li></ul></blockquote><blockquote><p>以下是相关函数：</p></blockquote><blockquote><p>首先在创建bufferpoolmanagerinstance的时候，构造函数会初始化一些参数，比如磁盘管理器，bufferpool的大小，比较重要的是要初始化<code>freelist</code>将所有的frameid放进链表中</p></blockquote><p><img src="/2023/04/13/CMU-15445/image-20230314213547817.png" alt="image-20230314213547817"></p><blockquote><p> flushpgimp：这个函数是将指定的pageid页面给写入到磁盘</p><p>【对于这个pageid 我还是有点疑惑】</p></blockquote><p><img src="/2023/04/13/CMU-15445/image-20230314213706152.png" alt="image-20230314213706152"></p><blockquote><p>FetchPgImp： 这个函数根据指定的pageid来获取在pages中的指定的page</p><ul><li>基本思路就是先看看这个page是不是在内存中</li><li>如果在内存中就将这个页返回，并标记为pin，从lru中删除</li><li>如果不在内存中，就在pages数组中找到一个page空间，然后去磁盘中读取这个page然后放到这个page空间中。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  从bufferpool中获取一个页，如果这个页不在的话，就先在bufferpool中找一个位置（先freelist，在lru），找到之后，将之前的页</span><br><span class="hljs-comment"> *  判断是否为脏页来决定是否写入磁盘，然后从磁盘中读取对应的pageid的页到刚才找到的位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 1.     Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.1    If P exists, pin it and return it immediately.</span><br>  <span class="hljs-comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span><br>  <span class="hljs-comment">//        Note that pages are always found from the free list first.</span><br>  <span class="hljs-comment">// 2.     If R is dirty, write it back to the disk.</span><br>  <span class="hljs-comment">// 3.     Delete R from the page table and insert P.</span><br>  <span class="hljs-comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">auto</span> iter = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (iter != page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-type">frame_id_t</span> frameid = iter-&gt;second;<br>    Page *page = &amp;pages_[frameid];<br>    page-&gt;pin_count_++;<br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frameid);<br>    <span class="hljs-keyword">return</span> page;<br>  &#125;<br>  <span class="hljs-comment">// 表示pageid对应的页不在内存中</span><br>  <span class="hljs-type">frame_id_t</span> frameid = <span class="hljs-number">-1</span>;<br>  Page *page = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!free_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    frameid = free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>    page = &amp;pages_[frameid];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frameid)) &#123;  <span class="hljs-comment">// 从lru中移除一个frameid</span><br>    page = &amp;pages_[frameid];<br>    <span class="hljs-comment">// 如果是脏页就刷进磁盘</span><br>    <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>      page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 清除掉pagetable中的pageid和frameid的关系</span><br>    page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  &#125;<br><br>  <span class="hljs-comment">// 判断是否找到了页的位置</span><br>  <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>    page-&gt;page_id_ = page_id;<br>    page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>    page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 在内存中找到了位置之后，我们开始将磁盘中对应的pageid给读进来，放入这个bufferpool中</span><br>    <span class="hljs-comment">// printf(&quot;hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh %d\n&quot;,page_id);</span><br>    disk_manager_-&gt;<span class="hljs-built_in">ReadPage</span>(page_id, page-&gt;<span class="hljs-built_in">GetData</span>());<br>    page_table_[page_id] = frameid;<br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frameid);<br>  &#125;<br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>NewPgImp： 这个函数是申请一个page空间，<strong>但是申请的page空间的pageid是bufferpool分配的这个是我不理解的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  这个函数是为一个页在bufferpool中分配一个位置，然后分配一个pageid，并将其pageid和frameid关系加入到pagetable中</span><br><span class="hljs-comment"> *  然后返回一个Page指针，指向了Pages数组中某一个page地址，就是在pages数组中申请了一个page空间</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call AllocatePage!</span><br>  <span class="hljs-comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span><br>  <span class="hljs-comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span><br>  <span class="hljs-comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span><br>  <span class="hljs-comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-type">frame_id_t</span> frameid = <span class="hljs-number">-1</span>;<br>  Page *page = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">if</span> (!free_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-comment">// 说明空闲链表中有空闲的frame_id,也就是在bufferpool中有空位</span><br>    <span class="hljs-comment">// 获取一个空闲的位置, 将page指向bufferpool的对应的page的位置</span><br>    frameid = free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>    page = &amp;pages_[frameid];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frameid)) &#123;<br>    <span class="hljs-comment">// 当空闲链表中找不到空闲的位置，说明bufferpool中位置被占满了，</span><br>    <span class="hljs-comment">// 这个时候需要使用lru移除一个，调用Victim()移除一个，并返回这个移除的位置</span><br>    page = &amp;pages_[frameid];<br>    <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    &#125;<br>    <span class="hljs-comment">// 从pagetable中移除pageid和frameid的对应关系</span><br>    page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (page !=<span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-comment">// 说明上面在bufferpool中获取到了位置，现在应该将这个申请一个id</span><br>    *page_id = <span class="hljs-built_in">AllocatePage</span>();<br>    page-&gt;page_id_ = *page_id;<br>    page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>    page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>    page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br>    page_table_[*page_id] = frameid;<br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frameid);<br>    <span class="hljs-keyword">return</span> page;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/CMU-15445/image-20230314215203809.png" alt="image-20230314215203809"></p><h3 id="ParallelBufferPoolManager"><a href="#ParallelBufferPoolManager" class="headerlink" title="ParallelBufferPoolManager"></a>ParallelBufferPoolManager</h3><p>为了提高bufferpool的并发程度，我们将bufferpoolmanager的粒度做的小一点，这样就能够实现更好的并发效果。</p><h2 id="Project2-–-Hash-Index"><a href="#Project2-–-Hash-Index" class="headerlink" title="Project2 – Hash Index"></a>Project2 – Hash Index</h2><p>这个实验我们将完成数据库索引功能。我们使用extendible hash table来实现数据库索引功能，什么是可拓展hash表，可以参考这个文章： <a href="https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/">https://www.geeksforgeeks.org/extendible-hashing-dynamic-approach-to-dbms/</a></p><blockquote><p>基本流程</p></blockquote><p><img src="/2023/04/13/CMU-15445/Basic-Working-of-Extendible-Hashing.png" alt="Lightbox"></p><p>它的基本原理就是：我们会维护一个directory 和很多个bucket，通过一个hash函数，我们可以在directory中找到一个位置，这个位置存着某个bucket的指针，每一个bucket都是hash后相同的对象存在的空间。</p><p>我们要清楚这个是一个可以拓展的hash表，通过维护directory的globaldepth 和很多bucket的localdepth来进行拓展hash表（主要拓展的是bucket）。</p><h3 id="HashTableDirectoryPage"><a href="#HashTableDirectoryPage" class="headerlink" title="HashTableDirectoryPage"></a>HashTableDirectoryPage</h3><p>这个类就是可拓展hash表的directory，它里面维护了一个自己的globaldepth变量，一个bucket_localdepth数组和一个bucket_pageid数组。</p><p><img src="/2023/04/13/CMU-15445/image-20230315213805600.png" alt="image-20230315213805600"></p><p>他在内存中占用一个page的大小（4096字节）：基本布局如下</p><p><img src="/2023/04/13/CMU-15445/image-20230315213908417.png" alt="image-20230315213908417"></p><p>也就是说最多只能有512个bucket。</p><blockquote><p>下面介绍几个重要的函数</p></blockquote><blockquote><p><strong>IncrGlobalDepth</strong></p><ul><li>我们将globaldepth加1之后，然后我们需要将拓展之后的空间的指向和前半部分一样，因为扩展之后相当于 0xxxxx 和1xxxxx 。</li><li>因为directory的位置必须任何时刻都要指定一个bucket，所以我们为了方便就复制一遍，也是为了后续方便的操作</li><li><strong>这个localdepth在查找的时候是没有任何用处的，他只是在insert和remove的时候，对bucket进行插入和删除的时候导致的bucket的分割和合并的时候才会有用</strong></li><li><strong>但是这个localdepth保证了所有index的后localdepth都相同的index都指向同一个大小为localdepth的bucket</strong>，比如localdepth为2的bucket，那么它可能被（000，100） 或者（010，110）这些组合指着（此时globaldepth 为3）.</li><li><strong>而这个globaldepth是很有用的，首先在查询的时候，我们要使用它作为掩码长度，来确定hash（key）所对应的在directory的index，一个是用来和localdepth比较判断是否拓展和收缩之类的。</strong></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 给directory 的global depth 加1，也就是grow，将原来的桶的索引的个数增加一倍</span><br><span class="hljs-comment"> * 增加一倍后，然后将之前的数都复制到新拓展的索引中</span><br><span class="hljs-comment"> * 至于bucketpage分裂和重映射不属于这个函数</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 1. 先增长</span><br><span class="hljs-comment"> * 2. 再分裂重映射</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HashTableDirectoryPage::IncrGlobalDepth</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// assert(global_depth_ &lt; MAX_BUCKET_DEPTH);</span><br>  <span class="hljs-type">int</span> new_start_depth = <span class="hljs-number">1</span> &lt;&lt; global_depth_;<br>  <span class="hljs-type">int</span> old = new_start_depth;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; old; i++, new_start_depth++) &#123;<br>    bucket_page_ids_[new_start_depth] = bucket_page_ids_[i];<br>    <span class="hljs-comment">// 这个是将directory 扩容后加入，将新拓展的地方依然指向同一个bucket；例如00 和10指向同一个</span><br>    <span class="hljs-comment">// 将桶信息复制到新拓展的地方</span><br>    local_depths_[new_start_depth] = local_depths_[i];<br>  &#125;<br>  global_depth_++;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>GetSplitImageIndex</strong> : 这个函数很重要，他是在进行insertsplit和removemerge时获取镜像index</p><ul><li>我们在insert时，可能会导致当前的bucket超出了容量，所以此时我们应该进行再申请一个bucket来和原来的bucket共同装那些内容。</li><li>此时这两个页的localdepth都应该加一，因为我们当时就是将在directory中的index后面localdepth长度的相同的都指向了原来的那个bucket，现在我们又申请了一个页，我们就想将之前的那些内容根据 原localdepth+1来将index分类，就分成了 0xx 和 1xx 这两类了，一个放在旧的bucket中，一个放在新的bucket中。</li><li>我们插入的那个key-value对应的index假如localdepth+1位为0，那么我们就是通过这个函数找到localdepth + 1 处 为1的index，<strong>但是这两个index必须其他位都相同</strong>，<strong>只有这个不相同</strong>，<strong>因为这样才是最近的一个，因为我们要根据这两个去将其他index后面原local depth长度的和要插入的一致的都找出来，将这些指向原来的bucket的index重新指向这两个bucket，0开头的指向原来的，1开头的指向新的。</strong></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 他的作用是获取兄弟bucket的bucket_idx(也就是所谓的splitImage), 也就是说,</span><br><span class="hljs-comment"> * 我们要将传入的bucket_idx的local_depth的最高位取反后返回</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 在extendible hash index中，当插入导致bucket分裂或者移除导致bucket合并时，</span><br><span class="hljs-comment"> * 我们都要找到待分离或合并的bucket的另一半。</span><br><span class="hljs-comment"> *  它找到了一定是最近的那个，方便我们往两边找</span><br><span class="hljs-comment"> * https://www.cnblogs.com/huasyuan/p/16611858.html</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">HashTableDirectoryPage::GetSplitImageIndex</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> bucket_idx)</span> </span>&#123;<br>  <span class="hljs-comment">// 合并时找最近的另一半</span><br>  <span class="hljs-type">uint32_t</span> local_depth = local_depths_[bucket_idx];<br>  <span class="hljs-keyword">return</span> bucket_idx ^ (<span class="hljs-number">1</span> &lt;&lt; (local_depth - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HashTableBucketPage"><a href="#HashTableBucketPage" class="headerlink" title="HashTableBucketPage"></a>HashTableBucketPage</h3><p>这个就是我们上面说的bucket，它里面包含了我们要存储的内容，通过这个类我们可以获取指定value并返回。</p><p>它里面有几个重要的参数，来表示这个page空间的使用情况，通过一个个bit表示这个page空间value空间是不是被占用了。我们在这个空间里保存的value是带上了key 即 pair&lt;key,value&gt;</p><p><img src="/2023/04/13/CMU-15445/image-20230315224019514.png" alt="image-20230315224019514"></p><blockquote><p>几个比较重要的函数：</p></blockquote><blockquote><p>GetValue ： 获取一个值从这个page中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_BUCKET_TYPE::GetValue</span><span class="hljs-params">(KeyType key, KeyComparator cmp, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;<br>  <span class="hljs-type">bool</span> res = <span class="hljs-literal">false</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; BUCKET_ARRAY_SIZE; ++i) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsReadable</span>(i) &amp;&amp; <span class="hljs-built_in">cmp</span>(key, array_[i].first) == <span class="hljs-number">0</span>) &#123;<br>      result-&gt;<span class="hljs-built_in">push_back</span>(array_[i].second);<br>      res = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>插入一个pair&lt;key,value&gt;</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_BUCKET_TYPE::Insert</span><span class="hljs-params">(KeyType key, ValueType value, KeyComparator cmp)</span> </span>&#123;<br>  <span class="hljs-type">int64_t</span> free_slot = <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; BUCKET_ARRAY_SIZE; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsReadable</span>(i)) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(key, array_[i].first) == <span class="hljs-number">0</span> &amp;&amp; value == array_[i].second) &#123;<br>        <span class="hljs-comment">// already existed the same key &amp; value</span><br>        <span class="hljs-comment">//                LOG_DEBUG(&quot;Same kv&quot;);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (free_slot == <span class="hljs-number">-1</span>) &#123;<br>      free_slot = i;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (free_slot == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// is full</span><br>    <span class="hljs-built_in">LOG_DEBUG</span>(<span class="hljs-string">&quot;Bucket is full&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// insert it and return true</span><br>  <span class="hljs-built_in">SetOccupied</span>(free_slot);<br>  <span class="hljs-built_in">SetReadable</span>(free_slot);<br>  array_[free_slot] = <span class="hljs-built_in">MappingType</span>(key, value);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ExtendibleHashTable"><a href="#ExtendibleHashTable" class="headerlink" title="ExtendibleHashTable"></a>ExtendibleHashTable</h3><p>这个就是最重要的类了，它提供了一系列方法用来操作这个directory和bucket</p><blockquote><p>下面我们就介绍一个很重要的函数，读取，插入和删除。</p></blockquote><h4 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue"></a>GetValue</h4><blockquote><p><code>bool HASH_TABLE_TYPE::GetValue(Transaction *transaction, const KeyType &amp;key, std::vector&lt;ValueType&gt; *result)</code></p></blockquote><blockquote><p>为了保证我们的可拓展hash表是线程安全的，所以我们在每个方法内部都必须上一个锁。</p><p>防止同一个索引的hash表被不同的线程拿到，从而导致directory和bucket出错，其实主要是directory出错，因为我们会在拿到bucket时，在对这个page上锁。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">/*****************************************************************************</span><br><span class="hljs-comment"> * SEARCH  获取key对应的value，</span><br><span class="hljs-comment"> * 先获取这个directory，然后根据用hash，得到key对应的bucket index，然后获取到</span><br><span class="hljs-comment"> * bucket_page_id，然后拿到这个页，然后遍历这个页中的array，查找key对应的pair，然后放进这个result中</span><br><span class="hljs-comment"> * 在获取某个bucketpage的页的时候，会加一个读锁，防止别的进程修改？</span><br><span class="hljs-comment"> *****************************************************************************/</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_TYPE::GetValue</span><span class="hljs-params">(Transaction *transaction, <span class="hljs-type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result)</span> </span>&#123;<br>  table_latch_.<span class="hljs-built_in">RLock</span>();  <span class="hljs-comment">// 申请一个读锁</span><br>  <span class="hljs-comment">// 这里我们pin了这个页</span><br>  HashTableDirectoryPage *dir = <span class="hljs-built_in">FetchDirectoryPage</span>();<br>  <span class="hljs-comment">// uint32_t bucket_idx = Hash(key);</span><br>  <span class="hljs-type">page_id_t</span> bucket_pageid = <span class="hljs-built_in">KeyToPageId</span>(key, dir);<br>  <span class="hljs-comment">// 这里我们pin了这个页</span><br>  Page *bucket_page = <span class="hljs-built_in">FetchBucketPage</span>(bucket_pageid);<br><br>  bucket_page-&gt;<span class="hljs-built_in">RLatch</span>();  <span class="hljs-comment">// 申请一个page 的读锁</span><br>  HASH_TABLE_BUCKET_TYPE *bucket = <span class="hljs-built_in">RetrieveBucket</span>(bucket_page);<br>  <span class="hljs-type">bool</span> res =  bucket-&gt;<span class="hljs-built_in">GetValue</span>(key, comparator_, result);<br>  bucket_page-&gt;<span class="hljs-built_in">RUnlatch</span>();  <span class="hljs-comment">// 释放这个page的读锁</span><br>  <span class="hljs-comment">// 对bucketpage要进行unpin操作</span><br>  <span class="hljs-comment">// 对dirpage要进行unpin操作</span><br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_pageid, <span class="hljs-literal">false</span>));<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));<br>  table_latch_.<span class="hljs-built_in">RUnlock</span>();  <span class="hljs-comment">// 释放锁</span><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><blockquote><p><code>bool HASH_TABLE_TYPE::Insert(Transaction *transaction, const KeyType &amp;key, const ValueType &amp;value)</code></p></blockquote><blockquote><p>基本流程：</p><ul><li>首先我们先获取这个directory，然后根据hash函数和globalmask获取index，然后就能够获取这个要插入的bucket了</li><li>但是我们如果这个bucket满了，我们需要进行重新申请一个page，然后重新将这个所有的在旧的bucket的，根据hash &amp; mask(旧localdepth + 1)分成了两类，一类放在旧的bucket中，一类放在新的bucket中。</li><li>具体细节在insertsplit函数中</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_TYPE::Insert</span><span class="hljs-params">(Transaction *transaction, <span class="hljs-type">const</span> KeyType &amp;key, <span class="hljs-type">const</span> ValueType &amp;value)</span> </span>&#123;<br>  <span class="hljs-comment">// LOG_INFO(&quot;lllllllllllllllllllllllllllllllllllllllllllll\n&quot;);</span><br>  <span class="hljs-comment">// 这个锁是用来针对这个整个对象来说的，因为这个对象是线程共享的，所以必须保证所有的方法都是线程安全的</span><br>  <span class="hljs-comment">// 别的不能执行insert操作，但是为什么还要给page锁呢，因为别的非insert函数可能会执行此page的变更操作</span><br>  table_latch_.<span class="hljs-built_in">RLock</span>();<br>  HashTableDirectoryPage *dir = <span class="hljs-built_in">FetchDirectoryPage</span>();  <span class="hljs-comment">// 获取这个directory，然后pin</span><br>  <span class="hljs-type">page_id_t</span> bucket_pageid = <span class="hljs-built_in">KeyToPageId</span>(key, dir);<br>  Page *bucket_page = <span class="hljs-built_in">FetchBucketPage</span>(bucket_pageid);  <span class="hljs-comment">// 获取这个桶对应的page</span><br>  bucket_page-&gt;<span class="hljs-built_in">WLatch</span>();  <span class="hljs-comment">// 获取这个page的写锁，保证别的地方不能操作这个page对象</span><br>  <span class="hljs-comment">// 上面那个锁，假如此时global = 2；local = 1；然后00 和 10 都是指向了同一个page，</span><br>  <span class="hljs-comment">// 但是在这个等待page锁的时候，别的Insert操作导致这个page满了分裂了 ？？？？？？ 我们都说了上面别的线程不能insert了</span><br>  <span class="hljs-comment">// 假如我们这个k解析的是10，但是我们之前获取的肯定是00对应的page，这个时候如果直接插，就会出错，</span><br>  <span class="hljs-comment">// 因为分列导致10对应的pageid变了，就是这个k应该插入到新分裂的那个页面</span><br>  <span class="hljs-comment">// 所以我们要不要加一个判断 再从dir中获取一下这个k对应pageid，如果两次都相等，则没事，</span><br>  <span class="hljs-comment">// 如果两次不等，则重新获取页，重新等待锁，重新判断，直到相同</span><br>  <span class="hljs-comment">// 上面可以叫做double check</span><br>  <span class="hljs-comment">// 但是会出现上面这个问题吗？因为我们锁住了这个insert函数，所以就不会有别的线程进行insert，所以不会。</span><br>  <span class="hljs-comment">// 但是！如果有可能因为这个page删除，合并了而出错，所以要不要double-check呢？</span><br>  <span class="hljs-comment">// 如果为了保险起见，我们可以不锁这个insert了，直接使用double-check就行，但是我这里没用</span><br>  HASH_TABLE_BUCKET_TYPE *bucket = <span class="hljs-built_in">RetrieveBucket</span>(bucket_page);  <span class="hljs-comment">// 转换成HASH_TABLE_BUCKET_TYPE</span><br>  <span class="hljs-keyword">if</span> (!bucket-&gt;<span class="hljs-built_in">IsFull</span>()) &#123;<br>    <span class="hljs-comment">// 判断这个bucket页是否已经满了</span><br>    <span class="hljs-type">bool</span> res = bucket-&gt;<span class="hljs-built_in">Insert</span>(key, value, comparator_);<br>    bucket_page-&gt;<span class="hljs-built_in">WUnlatch</span>();  <span class="hljs-comment">// 对这个page的锁释放</span><br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_pageid, <span class="hljs-literal">true</span>));  <span class="hljs-comment">// 对这个bucketpage执行unpin，并标志这个page是个脏页</span><br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));  <span class="hljs-comment">// 对这个diretorypage进行unpin操作</span><br>    table_latch_.<span class="hljs-built_in">RUnlock</span>();<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  <span class="hljs-comment">// 说明这个bucket已经满了，那么就需要进行分裂</span><br>  <span class="hljs-comment">// 现在要先解锁，？？？？要解锁吗？</span><br>  bucket_page-&gt;<span class="hljs-built_in">WUnlatch</span>();  <span class="hljs-comment">// 对这个page的锁释放</span><br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_pageid, <span class="hljs-literal">false</span>));  <span class="hljs-comment">// 对这个bucketpage执行unpin，并标志这个page不是脏页</span><br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));  <span class="hljs-comment">// 对这个diretorypage进行unpin操作</span><br>  table_latch_.<span class="hljs-built_in">RUnlock</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">SplitInsert</span>(transaction, key, value);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SplitInsert"><a href="#SplitInsert" class="headerlink" title="SplitInsert"></a>SplitInsert</h4><blockquote><p>这个里面比较重要的一块就是将所有的指向之前的bucket的index，重新指向旧的和新的bucket中。</p><ul><li>假如我们要插入key-value时，此时value对应的是index，然后这个index里指向page1（它的localdepth），<strong>那么这个directory中所有的index后localdepth个位和这个key对应的index相同的都是指向这个bucket。</strong></li><li>但是现在这个时候因为这个bucketpage满了，所以我们要重新申请一个bucketpage来将这些值重新放在旧的bucketpage和新的bucketpage中。</li><li>我们先重新设置上面所有指向旧的bucketpage的index给分成两类，一类指向旧的bucketpage，一类指向新的bucketpage</li><li>如何划分呢？假如旧的bucketpage的localdepth是a，然后a&lt; gloabdepth（先不考虑给directory 扩容）；我们申请完page后，这两个page的localdepth都是旧的localdepth + 1；</li><li><strong>所以我们要找到所有index 后localdepth 和key对应的index的后localdepth，然后index的localdepth+1位置为0和1都找到；（因为这些之前肯定都是指向同一个page，现在我们的localdepth+1了，要后localdepth +1 位相同放在同一个页面内）</strong></li><li>所以我们先通过<code>splitimage</code>函数找到镜像的indeximage，然后以1 &lt;&lt; (localdepth+1)(旧的)为等差值，来找到所有 和key对应的index后（localdepth +1）位相同的index 以及 和indeximage后（localdepth +1）位相同的index，然后分别指向旧的page和新的page；</li><li>这样我们旧将之前的页面给分割好了，然后我们就逐个的将之前的值重新hash一下放到各个对应的页中。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个是如果要插入的bucket满了，那么就分裂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_TYPE::SplitInsert</span><span class="hljs-params">(Transaction *transaction, <span class="hljs-type">const</span> KeyType &amp;key, <span class="hljs-type">const</span> ValueType &amp;value)</span> </span>&#123;<br>  table_latch_.<span class="hljs-built_in">WLock</span>();  <span class="hljs-comment">// 获取这个对象的全局锁</span><br>  HashTableDirectoryPage *dir = <span class="hljs-built_in">FetchDirectoryPage</span>();  <span class="hljs-comment">// 获取dir</span><br>  <span class="hljs-type">int64_t</span> split_bucket_index = <span class="hljs-built_in">KeyToDirectoryIndex</span>(key, dir);  <span class="hljs-comment">// 获取这个key对应的dirctory的index，也是要分裂的下标</span><br>  <span class="hljs-type">uint32_t</span> split_bucket_depth = dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index);  <span class="hljs-comment">// 获取这个要分割的bucket的深度</span><br>  <span class="hljs-keyword">if</span> (split_bucket_depth &gt;= MAX_BUCKET_DEPTH) &#123;<br>    <span class="hljs-comment">// 表示已经满了，无法分割了</span><br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));<br>    table_latch_.<span class="hljs-built_in">WUnlock</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (split_bucket_depth == dir-&gt;<span class="hljs-built_in">GetGlobalDepth</span>()) &#123;<br>    <span class="hljs-comment">// 给dir的entry grow一倍</span><br>    dir-&gt;<span class="hljs-built_in">IncrGlobalDepth</span>();<br>  &#125;<br>  <span class="hljs-comment">// 获取这个要分割的桶页</span><br>  <span class="hljs-type">page_id_t</span> split_bucket_page_id = <span class="hljs-built_in">KeyToPageId</span>(key, dir);<br>  Page *split_page = <span class="hljs-built_in">FetchBucketPage</span>(split_bucket_page_id);<br>  split_page-&gt;<span class="hljs-built_in">WLatch</span>();  <span class="hljs-comment">// 给这个页上锁</span><br>  HASH_TABLE_BUCKET_TYPE *split_bucket = <span class="hljs-built_in">RetrieveBucket</span>(split_page);<br><br>  MappingType *origin_array = split_bucket-&gt;<span class="hljs-built_in">GetArrayCopy</span>();<br>  <span class="hljs-type">uint32_t</span> origin_array_size = split_bucket-&gt;<span class="hljs-built_in">NumReadable</span>();<br>  split_bucket-&gt;<span class="hljs-built_in">Clear</span>();  <span class="hljs-comment">// 给原来的要分割的页全部清理干净，因为后面要把所有的元素重新进行散列到这两个新的页中</span><br><br>  <span class="hljs-comment">// 然后将开始申请一个新的页作为桶页分割后存储的页</span><br>  <span class="hljs-type">page_id_t</span> image_bunket_page_id;<br>  <span class="hljs-comment">// 这个新获得的页需要加锁吗</span><br>  HASH_TABLE_BUCKET_TYPE *image_bucket = <span class="hljs-built_in">RetrieveBucket</span>(<br>    <span class="hljs-built_in">AssertPage</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">NewPage</span>(&amp;image_bunket_page_id)));<br><br>  <span class="hljs-comment">// 增加这个localdepth</span><br>  dir-&gt;<span class="hljs-built_in">IncrLocalDepth</span>(split_bucket_index);<br>  <span class="hljs-comment">// 获取他的截掉localdepth长度后高位相同的另一个，比如000和010，localdepth为2，他们指向同一个bucketpage，这个方法也是找到另一个</span><br>  <span class="hljs-type">uint32_t</span> split_image_bucket_index = dir-&gt;<span class="hljs-built_in">GetSplitImageIndex</span>(split_bucket_index);<br>  dir-&gt;<span class="hljs-built_in">SetLocalDepth</span>(split_image_bucket_index, dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index));  <span class="hljs-comment">// 设置这个新的页的localdepth</span><br>  dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(split_image_bucket_index, image_bunket_page_id);  <span class="hljs-comment">// 在dir中设置这个bucket对应的pageid</span><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 上面我们完成了新bucketpage的申请，并且，将镜像index指向新的页（ 比如splitpageindex = 110，那么镜像的那个就是100 ，</span><br><span class="hljs-comment">   * 对于000和010还没映射，反正最后应该110和010指向旧页，100和000指向新页</span><br><span class="hljs-comment">   * 也就是dir中的split_image_bucket_index存的是新的页id，现在老页和新页都没有数据）</span><br><span class="hljs-comment">   * 但是，我们的GetSplitImageIndex只是获得了截掉localdepth长度的相同的另一个，</span><br><span class="hljs-comment">   * 对于比如100和110，他们之前也指向这个分割的也，也就是之前的页的localdepth是1，</span><br><span class="hljs-comment">   * 现在分割了变成了2，那么000和100指向旧页，010和110指向新页</span><br><span class="hljs-comment">   * 我们在上面只完成了000和010index的设置，对于100和110，甚至1000，1010等都指向这个分割的页，</span><br><span class="hljs-comment">   * 那么我们现在要对这些index对应的pageid重新设置，要么是新页，要么是老页</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// 这个diff是用来以localdepth个0和一个高位1组成的单位，因为00和100，1000，1100 的差距都是100，</span><br>  <span class="hljs-comment">// 假如我们这个可以对应的是100，localdepth现在是2，globaldepth3，</span><br>  <span class="hljs-comment">// 经过上面我们只是给100赋了老的页面id和110赋了新的页面的id，所以对于000和010没有设置，</span><br>  <span class="hljs-comment">// 因为最开始000，010，100，110都是指向一个localdepth为1的bucketpage，分裂后localdepth变成了2</span><br>  <span class="hljs-comment">// 下面我们就设置这些没有设置的index</span><br>  <span class="hljs-comment">// ---------------------------------------</span><br>  <span class="hljs-type">uint32_t</span> diff = <span class="hljs-number">1</span> &lt;&lt; dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index);<br>  <span class="hljs-comment">// 先设置和split_bucket_index指向的同一个页面的index</span><br>  <span class="hljs-type">uint32_t</span> i = split_bucket_index;<br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>    dir-&gt;<span class="hljs-built_in">SetLocalDepth</span>(i, dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index));<br>    dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(i, split_bucket_page_id);<br>    <span class="hljs-keyword">if</span> (i &lt; diff) &#123;<br>      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 防止为负数</span><br>    &#125;<br>    i -= diff;<br>  &#125;<br>  <span class="hljs-comment">// 再设置和split_image_bucket_index指向同一个页面的index</span><br>  i = split_image_bucket_index;<br>  <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>    dir-&gt;<span class="hljs-built_in">SetLocalDepth</span>(i, dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index));<br>    dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(i, image_bunket_page_id);<br>    <span class="hljs-keyword">if</span> (i &lt; diff) &#123;<br>      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 防止为负数</span><br>    &#125;<br>    i -= diff;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i =split_bucket_index; i &lt; dir-&gt;<span class="hljs-built_in">Size</span>(); i+=diff) &#123;<br>    dir-&gt;<span class="hljs-built_in">SetLocalDepth</span>(i, dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index));<br>    dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(i, split_bucket_page_id);<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = split_bucket_index; i &lt; dir-&gt;<span class="hljs-built_in">Size</span>(); i+=diff) &#123;<br>    dir-&gt;<span class="hljs-built_in">SetLocalDepth</span>(i, dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(split_bucket_index));<br>    dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(i, image_bunket_page_id);<br>  &#125;<br>  <span class="hljs-comment">// ---------------------------------</span><br>  <span class="hljs-comment">// 现在我们完成了bucketpage的分割和所有原来指向同一个老页的都重新设置指向了新页和就页，</span><br>  <span class="hljs-comment">// 现在就是将之前旧页中的元素，重新进行散列到</span><br>  <span class="hljs-comment">// 我们这两个页面中</span><br>  <span class="hljs-type">uint32_t</span> mask = dir-&gt;<span class="hljs-built_in">GetLocalDepthMask</span>(split_bucket_index);  <span class="hljs-comment">// 肯定是获得?</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span> ; i &lt; origin_array_size; i++) &#123;<br>    MappingType temp = origin_array[i];<br>    <span class="hljs-type">uint32_t</span> target_bucket_index = <span class="hljs-built_in">Hash</span>(temp.first) &amp; mask;  <span class="hljs-comment">// 获取每个元素的key对应的</span><br>    <span class="hljs-type">page_id_t</span> target_bucket_page_id = dir-&gt;<span class="hljs-built_in">GetBucketPageId</span>(target_bucket_index);<br>    <span class="hljs-built_in">assert</span>(target_bucket_page_id == split_bucket_page_id || target_bucket_page_id == image_bunket_page_id);<br>    <span class="hljs-keyword">if</span> (target_bucket_page_id == split_bucket_page_id) &#123;<br>      <span class="hljs-built_in">assert</span>(split_bucket-&gt;<span class="hljs-built_in">Insert</span>(temp.first, temp.second, comparator_));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">assert</span>(image_bucket-&gt;<span class="hljs-built_in">Insert</span>(temp.first, temp.second, comparator_));<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 到这里就完成了bucketpage的split</span><br>  <span class="hljs-keyword">delete</span>[] origin_array;<br>  split_page-&gt;<span class="hljs-built_in">WUnlatch</span>();  <span class="hljs-comment">// 给这个页解锁</span><br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">true</span>));<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(split_bucket_page_id, <span class="hljs-literal">true</span>));<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(image_bunket_page_id, <span class="hljs-literal">true</span>));<br>  table_latch_.<span class="hljs-built_in">WUnlock</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Insert</span>(transaction, key, value);  <span class="hljs-comment">// 重新将这个值插入到桶中</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>上面我们完成了数据在hash表中的插入</p><p>下面我们完成数据在hash表中的删除</p></blockquote><h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><blockquote><p>基本思路：</p><ul><li>拿到directory，然后根据key和globaldepth找到index，然后找到bucketpage</li><li>然后对这个page进行操作</li><li>如果这个page删除完这个元素后，我们可以将这个page给放回freelist中</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> KeyType, <span class="hljs-keyword">typename</span> ValueType, <span class="hljs-keyword">typename</span> KeyComparator&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">HASH_TABLE_TYPE::Remove</span><span class="hljs-params">(Transaction *transaction, <span class="hljs-type">const</span> KeyType &amp;key, <span class="hljs-type">const</span> ValueType &amp;value)</span> </span>&#123;<br>  table_latch_.<span class="hljs-built_in">RLock</span>();<br><br>  HashTableDirectoryPage *dir = <span class="hljs-built_in">FetchDirectoryPage</span>();<br>  <span class="hljs-type">page_id_t</span> bucket_page_id = <span class="hljs-built_in">KeyToPageId</span>(key, dir);<br>  Page *page = <span class="hljs-built_in">FetchBucketPage</span>(bucket_page_id);<br>  page-&gt;<span class="hljs-built_in">WLatch</span>();<br>  HASH_TABLE_BUCKET_TYPE *bucket = <span class="hljs-built_in">RetrieveBucket</span>(page);<br>  <span class="hljs-type">bool</span> res = bucket-&gt;<span class="hljs-built_in">Remove</span>(key, value, comparator_);<br>  <span class="hljs-comment">// 如果bucket空了，那么就将他的image bucket page进行merge</span><br>  <span class="hljs-keyword">if</span> (bucket-&gt;<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>    page-&gt;<span class="hljs-built_in">WUnlatch</span>();<br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_page_id, <span class="hljs-literal">true</span>));<br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));<br>    table_latch_.<span class="hljs-built_in">RUnlock</span>();<br>    <span class="hljs-built_in">Merge</span>(transaction, key, value);<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>  page-&gt;<span class="hljs-built_in">WUnlatch</span>();<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(bucket_page_id, <span class="hljs-literal">true</span>));<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));<br>  table_latch_.<span class="hljs-built_in">RUnlock</span>();<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>因为牵扯页面的merge，我们下面这个函数实现</p></blockquote><h4 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h4><blockquote><p>基本思路：</p><ul><li>这个merge相当于上面的split的逆过程，split函数分割后再将之前的index重新指向这两个page，然后将原来的元素重新散落到这两个page中</li><li>我们这个merge，就是将指向被删除的page的index给重新指向imageindex指向的page中</li><li>首先我们找到这个imageindex，就是localdepth位取反的值，然后根据这index去加减1&lt;&lt; localdepth 位找到所有的指向要删除的page的index重新指向imageindex指向的imagepage中。</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">Page* merge_bucket_page = <span class="hljs-built_in">FetchBucketPage</span>(merge_bucket_page_id);<br>  merge_bucket_page-&gt;<span class="hljs-built_in">RLatch</span>();<br>  HASH_TABLE_BUCKET_TYPE *bucket = <span class="hljs-built_in">RetrieveBucket</span>(merge_bucket_page);<br>  <span class="hljs-keyword">if</span> (!bucket-&gt;<span class="hljs-built_in">IsEmpty</span>()) &#123;<br>    merge_bucket_page-&gt;<span class="hljs-built_in">RUnlatch</span>();<br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(dir-&gt;<span class="hljs-built_in">GetPageId</span>(), <span class="hljs-literal">false</span>));<br>    <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(merge_bucket_page_id, <span class="hljs-literal">false</span>));<br>    table_latch_.<span class="hljs-built_in">WUnlock</span>();<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  merge_bucket_page-&gt;<span class="hljs-built_in">RUnlatch</span>();<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">UnpinPage</span>(merge_bucket_page_id, <span class="hljs-literal">false</span>));<br>  <span class="hljs-built_in">assert</span>(buffer_pool_manager_-&gt;<span class="hljs-built_in">DeletePage</span>(merge_bucket_page_id));<br>  <span class="hljs-type">page_id_t</span> image_bucket_page_id = dir-&gt;<span class="hljs-built_in">GetBucketPageId</span>(image_bucket_index);<br>  dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(merge_bucket_index, image_bucket_page_id);<br>  dir-&gt;<span class="hljs-built_in">DecrLocalDepth</span>(merge_bucket_index);<br>  dir-&gt;<span class="hljs-built_in">DecrLocalDepth</span>(image_bucket_index);<br>  <span class="hljs-built_in">assert</span>(dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(merge_bucket_index) == dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(image_bucket_index));<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; dir-&gt;<span class="hljs-built_in">Size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (dir-&gt;<span class="hljs-built_in">GetBucketPageId</span>(i) == merge_bucket_page_id || dir-&gt;<span class="hljs-built_in">GetBucketPageId</span>(i) == image_bucket_page_id) &#123;<br>      dir-&gt;<span class="hljs-built_in">SetBucketPageId</span>(i, image_bucket_page_id);<br>      dir-&gt;<span class="hljs-built_in">SetLocalDepth</span>(i, dir-&gt;<span class="hljs-built_in">GetLocalDepth</span>(merge_bucket_index));<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>几个关键的函数我们就介绍完了，现在我们来总结一下这个难点</p></blockquote><ul><li>首先是对于这个extendible hash table 的原理必须掌握清除，对于它的插入、删除这两个操作的原理必须掌握的很清楚才能够写出代码来。特别是这个<code>SplitImageIndex</code>这个函数的意义。</li><li>对于这个hash表的各个函数必须是线程安全的，所以要对每个函数进行加锁处理</li></ul><h2 id="project3-query-executing"><a href="#project3-query-executing" class="headerlink" title="project3 query executing"></a>project3 query executing</h2><p><img src="/2023/04/13/CMU-15445/image-20230222154427720.png" alt="image-20230222154427720"></p><h3 id="Executor–执行器"><a href="#Executor–执行器" class="headerlink" title="Executor–执行器"></a>Executor–执行器</h3><p>一个SQL语法句子会经过parser和binder生成一个查询计划数Planner</p><p>例如：<code>SELECT t1.y, t2.x FROM t1 INNER JOIN t2 ON t1.x = t2.y;</code></p><p>生成的Planner树就是</p><img src="/2023/04/13/CMU-15445/image-20230222154706379.png" alt="image-20230222154706379" style="zoom:50%;"><p>其中查询计划规定了数据的流向，一般是从底向上流动，然后根节点负责输出</p><p>生成palnner后，会经过优化器来优化计划树，一般来说，Planner生成的是Logical plan node，但是经过optimizer则生成的是physical plan node ，具体的例子就是join，在 Planner 生成的查询计划中，Join 就是 Join。在 Optimizer 生成的查询计划中，Join 会被优化成具体的 HashJoin 或 NestedIndexJoin 等等。在 Bustub 中，并不区分 Logical Plan Node 和 Physical Plan Node。Planner 会直接生成 Physical Plan Node。</p><p>一般优化器的实现算法两个，一个是基于cost（cost-based），一个是基于rule（rule-based）.</p><blockquote><p>executor–执行算子</p></blockquote><p>在拿到Optimizer生成的具体执行计划后，我们需要将plan node替换成一个个真实可以执行的executor，也就是用executor替换plannode。生成一个执行计划树</p><p>每一个executor就是对pannode的封装和计划操作。</p><p>算子的执行有三种模型，</p><ul><li>Iterator Model，或 Pipeline Model，或火山模型。每个算子都有 <code>Init()</code> 和 <code>Next()</code> 两个方法。<code>Init()</code> 对算子进行初始化工作。<code>Next()</code> 则是向下层算子请求下一条数据。当 <code>Next()</code> 返回 false 时，则代表下层算子已经没有剩余数据，迭代结束。可以看到，火山模型一次调用请求一条数据，占用内存较小，但函数调用开销大，特别是虚函数调用造成 cache miss 等问题。</li><li>Materialization Model. 所有算子立即计算出所有结果并返回。和 Iterator Model 相反。这种模型的弊端显而易见，当数据量较大时，内存占用很高。但减少了函数调用的开销。比较适合查询数据量较小的 OLTP workloads。</li><li>Vectorization Model. 对上面两种模型的中和，一次调用返回一批数据。利于 SIMD 加速。目前比较先进的 OLAP 数据库都采用这种模型。</li></ul><p>本项目采用的就是Iterator Model模型</p><h3 id="Task1-EXECUTORS"><a href="#Task1-EXECUTORS" class="headerlink" title="Task1 EXECUTORS"></a>Task1 EXECUTORS</h3><p>上面我们已经基本结束了executor，包含很多的算子，SeqScan、Insert、delete等等，采用的是火山模型，执行这个算子的时候，看看有没有子算子，如果有子算子，那么就递归的调用子算子，将子算子返回的tuples，然后一个个的处理他们，处理完成之后，返回符合条件的tuple。</p><p>每个executor都负责处理 a single plan node type。它们从它们的children中接收tuples，并向它们的父亲提供tuples。</p><p>本项目提供了ExecutionEngine辅助类(<code>src/include/execution/execution_engine.h</code>)。它将输入的query plan转化为一个query executor（使用的ExecutorFactory来进行创建的–工厂模式），并执行query executor直到所有result都被收集（init，然后循环调用next，将所有tuple存入result vector中）。你需要修改ExecutionEngine来捕获所有你的executors抛出的异常</p><p>每个executor都有一个ExecutorContext(<code>src/include/execution/executor_context.h</code>)来维持关于query的额外信息（包含所用的log/lock/buffer/txn manager和catalog)。</p><blockquote><p>基本流程：</p></blockquote><p>执行引擎ExecutionEngine的函数Execute()传入的第一个参数就是executor对应的planNode。AbstractPlanNode是所有node的父类。第二个参数就是放executor执行完后得到的tuples。exec_ctx就是当前执行的上下文，记录了bfp，log manager，lock manager，catalog和txnmanager。</p><p>首先这里有个工厂方法ExecutorFactory::CreateExecutor(),根据传入的planNode的类型，使用dynamic_cast将planNode转换成对应类型的planNode（父类指针转换成子类指针），调用对应的executor的构造函数创建executor。</p><p>然后调用executor的init方法初始化executor，重复执行next方法，next返回true则将结果存入result_set并继续执行next, next返回false 则结束。所以后面的任务就是实现每个executor的init和next方法</p><blockquote><p>在介绍所有的具体的执行器之前，我们先理清一下这个实验中的Table的关系</p></blockquote><p><img src="/2023/04/13/CMU-15445/image-20230222162447042.png" alt="image-20230222162447042"></p><ul><li><p>**Catalog **首先，Bustub 有一个 Catalog。Catalog 提供了一系列 API，例如 <code>CreateTable()</code>、<code>GetTable()</code> 等等。Catalog 维护了几张 hashmap，保存了 table id 和 table name 到 table info 的映射关系。table id 由 Catalog 在新建 table 时自动分配，table name 则由用户指定。</p></li><li><p><strong>TableInfo</strong> 这里的 table info 包含了一张 table 的 metadata，有 schema、name、id 和指向 table heap 的指针。系统的其他部分想要访问一张 table 时，先使用 name 或 id 从 Catalog 得到 table info，再访问 table info 中的 table heap。</p></li><li><p><strong>TableHeap</strong> 是管理 table 数据的结构，包含 <code>InsertTuple()</code>、<code>MarkDelete()</code> 一系列 table 相关操作。table heap 本身并不直接存储 tuple 数据，tuple 数据都存放在 table page 中。table heap 可能由多个 table page 组成，==仅保存其第一个 table page 的 page id==。需要访问某个 table page 时，通过 page id 经由 buffer pool 访问。</p></li><li><p><strong>TablePage <strong>是实际存储 table 数据的结构，父类是 page。相较于 page，table page 多了一些新的方法。</strong>table page 在 data 的开头存放了 next page id、prev page id 等信息，将多个 table page 连成一个双向链表，便于整张 table 的遍历操作。</strong>当需要新增 tuple 时，table heap 会找到当前属于自己的最后一张 table page，尝试插入，若最后一张 table page 已满，则新建一张 table page 插入 tuple。table page 低地址存放 header，tuple 从高地址也就是 table page 尾部开始插入。</p></li><li><p><strong>Tuple <strong>对应数据表中的一行数据。每个 tuple 都由 RID 唯一标识。</strong>RID 由 page id + slot num 构成</strong>。tuple 由 value 组成，value 的个数和类型由 table info 中的 schema 指定。</p></li><li><p>**Value **则是某个字段具体的值，value 本身还保存了类型信息。</p></li></ul><p>需要注意的是，executor 本身并不保存查询计划的信息，应该通过 executor 的成员 plan 来得知该如何进行本次计算，例如 SeqScanExecutor 需要向 SeqScanPlanNode 询问自己该扫描哪张表。</p><blockquote><p>AbstractPlanNode</p></blockquote><p>这是所有PlanNode的父类。对应的有一个枚举类PlanType，表示所有可能的PlanNode类型。AbstractPlanNode只有两个成员变量，<strong>一个是output_shcema</strong>,在Next返回tuple（如果需要返回tuple）时可以根据output_schema选择输出tuple的哪几个column（相当于select）。<strong>另一个是vector children_</strong>, 里面有所有children的常量指针。</p><h3 id="SEQUENTIAL-SCAN"><a href="#SEQUENTIAL-SCAN" class="headerlink" title="SEQUENTIAL SCAN"></a>SEQUENTIAL SCAN</h3><p>这个是顺序扫描，对一张表进行扫描，每次返回一个符合条件的tuple。它包含一个SeqScanPlanNode，这个plannode指明了在那张表上进行迭代，这个plannode也会包含一个predicate（也就是这个扫描计划的判断条件），比如where id &lt; 5 就是一个predicate，如果某个tuple不满足这个predicate就会跳过。（这个predicate是一个表达式）</p><blockquote><p><strong>sequential node</strong></p></blockquote><p>sequential node继承自AbstractPlanNode，多了两个私有变量。一个是predicate，是用来过滤不符合条件的tuple。比如where id &lt; 5 就是一个predicate。另一个变量是table_oid_,指明了要扫描的表的id</p><blockquote><p>具体实现</p></blockquote><p>因为我们是要扫描一张表，所以我们要有一个tableIterator,指向当前第一个未遍历的tuple，还需要一个指向这个tableheap的指针。</p><p>每一个执行器都包含两个默认的方法，就是初始化和Next</p><p>初始化就是，我们根据plannode种的表id和执行器上下文exec_ctx种的catalog去找到tableheap，也就是先找到表，然后初始化这个tableIterator未table的begin();</p><p>next首先判断当前是不是已经扫描完成表，即<code>iter_ == table_heap_-&gt;End()</code>，然后根据plan_-&gt;OutputSchema()-&gt;GetColumnCount()来构建这个返回元组tuple，通过这个计划节点先获取这个返回元组的schema，然后，逐个的获取tableIterator指向的tuple中的每一个对应的在schema的column的value，然后将这些获得的value逐个的放在vector中，然后构建输出的tuple</p><p>但是在输出之前，我们需要先判断这个计划节点的predicate是否满足，如果满足就返回这个构建的tuple，如果不满足就直接下一个。</p><h3 id="InsertExecutor"><a href="#InsertExecutor" class="headerlink" title="InsertExecutor"></a>InsertExecutor</h3><p>插入数据的来源可能有两种可能来源。第一种是来自child，每次调用InsertExecutor的Next方法时，就将从child获取的tuple插入到表中。另一个就是直接传入数据插入到表中，也就是RawValues，原生数据。</p><p><strong>在插入操作时，我们要记得更新我们的索引index</strong></p><p>来自child的tuple比较简单，直接插入就好了，别忘了在自己的init方法中init child，然后将从child获取的tuple插入到表中。<strong>然后要记得修改索引</strong>，直接调用之前封装好的插入索引方法就行，这里是调用index的InsertEntry方法</p><p>对于rawvalues，取出要插入的tuple，然后使用table_heap的插入方法，插入到某个page中</p><p>==基本流程：== 首先判断是不是RawInsert，如果是直接插入到page中，如果不是就继续往下找，找到最后一个插入到page中，是通过table_heap_-&gt;InsertTuple()方法插入的，他会逐个遍历这个表page，有空就插入，如果没有空了就新建一个page插入， 然后插入完成之后，要更新索引</p><blockquote><p><strong>有点要注意的时，就是我们插入数据的时候，肯定时先插入之后再给这个tuple上写锁，那么在这就会发生一个幻读的现象。</strong></p><p>除非我们直接将这个table给上锁了，就不会出现幻读现象了。</p></blockquote><h3 id="UpdateExecutor和DeleteExecutor"><a href="#UpdateExecutor和DeleteExecutor" class="headerlink" title="UpdateExecutor和DeleteExecutor"></a>UpdateExecutor和DeleteExecutor</h3><p>更新就是将原来的tuple根据planNode指定的更新方式（一个是add，一个是直接set），这个更新方法已经提供了，只要每次调用next方法时，通过child获取下一个需要更新的tuple，调用GenerateUpdatedTuple生成更新后的tuple，然后调用tableHeap的updataTuple在表中更新tuple，再在所有的索引中删除原来的tuple，插入新的tuple，返回tuple的RID即可</p><p>删除也是删除child提供的tuple的RID调用table的MarkDelete方法。<strong>这里MarkDelete的意思是使tuple invisable，并不真的删除它</strong>。只有在事务提交的时候才真的删除。这样如果事务还没提交就abort了，回滚时只需要将mark的标志撤销就好。</p><h3 id="NestedLoopJoin"><a href="#NestedLoopJoin" class="headerlink" title="NestedLoopJoin"></a>NestedLoopJoin</h3><p>join我们都知道时连接操作，就是将两个表通过相同的字段进行连接，如何实现这个连接，有两种方法，一个时嵌套循环连接，一个时hashjoin连接</p><p>原理：就是将两个孩子节点返回的tuple进行断言判断（也就是判断指定的columns位置上的value是不是相同的），如果相同，就将这两个tuple根据outputSchema组合输出新的tuple</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (left_child-&gt;<span class="hljs-built_in">Next</span>(&amp;left_tuple))&#123;<br>    <span class="hljs-keyword">while</span> (right_child-&gt;<span class="hljs-built_in">Next</span>(&amp;right_tuple))&#123;<br>        <span class="hljs-keyword">if</span> (left_tuple matches right_tuple)&#123;<br>            *tuple = ...;   <span class="hljs-comment">// assemble left &amp; right together</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>因为我们这个执行器的next每次只是输出了一个符合要求的tuple，比如我们第一次遍历right child ，有一个符合条件的，然后返回，没有遍历的right child怎么办，因为我们下次开始获取left child，所以就会导致有的没有遍历到。还有就是，我们right只能遍历一次就无法遍历了，因为右边的迭代器到底了，其next无法返回数据了。</p><p>针对上面的情况，我设计了临时存储左边一个tuple和所有的右边的表的tuple满足的组合tuple放到这个执行器的一个变量中std::queue<Tuple> tmp_results_{};临时存储，然后下一次进入时，直接先从这里面取，如果没有了，那么左边的child 的iter++，直到左边的所有的tuple被遍历完成。</Tuple></p><h3 id="HashJoin"><a href="#HashJoin" class="headerlink" title="HashJoin"></a>HashJoin</h3><p>基本逻辑：</p><p>先将左表的tuple给hash一下并插入到哈希表中，key就是join的字段，value就是tuple数组（因为会有多个tuple的join字段相同，我们把相同的都放进这个tuple数组中），然后不断的获取右表的tuple， 然后对指定的右表的tuple的列做hash，然后看看在左表形成的hash表中有没有对应的key，如果有，说明满足join条件，然后去构建新的tuple数组并返回。</p><p>这个不需要建立临时的容器存储内容</p><h3 id="AGGREGATION"><a href="#AGGREGATION" class="headerlink" title="AGGREGATION"></a><strong>AGGREGATION</strong></h3><p>之前我们都直到有一些聚合函数，比如sum，max，min，count等等，这个执行器就是来实现这些功能的。</p><p>然后还会结合Group by 和having on，如下的例句就是执行聚合操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> deptno,<span class="hljs-built_in">sum</span>(sal)  total  <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal<span class="hljs-operator">&gt;</span><span class="hljs-number">1000</span> <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>  deptno <span class="hljs-keyword">having</span> <span class="hljs-built_in">sum</span>(sal) <span class="hljs-operator">&gt;</span><span class="hljs-number">9000</span> <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-built_in">sum</span>(sal) <span class="hljs-keyword">asc</span>;<br></code></pre></td></tr></table></figure><p>如何实现：采用hash表实现的。</p><p>首先group by时肯定时要有一个列作为聚合对象，将此列的相同的值列为一组（先分组），那我们就可以将这个组的value设置为key，然后聚合结果设置为value，</p><p>这个聚合执行器只有一个孩子算子，那我们在init方法中循环的获取tuple，然后将这个tuple的对应的那个列的value进行hash一下得到AggregateKey，然后将这个值和hash表中的AggregateKey对应的AggregateValue进行运算，得到新的聚合值，但是这种算法只能满足四个聚合功能，count，sum，min，max，对于平均值等没有实现。但是6.830实现了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 遍历完整张表以后，哈希表也就建立了。现在哈希表中key的数量由整张表中group指定的列中unique value的数量确定。</span><br><span class="hljs-comment"> * 而哈希表的value则是每个unique value对应的count，sum值。</span><br><span class="hljs-comment"> * 之后每次next只要使用哈希表的迭代器根据having（如果有的话）找到下一个符合要求的key/value键值对，构造出新的tuple返回就行。</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="project4-concurrency-control"><a href="#project4-concurrency-control" class="headerlink" title="project4 concurrency control"></a>project4 concurrency control</h2><p>这个项目是实现一个lockmanager（S锁和X锁管理器），并使用它来支持query execution，实现事务的隔离性。事务（Transaction）是数据库中一个极其重要的概念。<br>本实验要实现三个task：</p><ul><li>lock manager：锁管理器，这里的锁是X锁（排他锁/写锁）和S锁（共享锁/读锁），利用2PL（两阶段锁）实现并发控制。</li><li>DeadLock prevention：防止在加锁过程中出现死锁现象，采用的wound-wait算法来预防死锁现象</li><li>concurrent query execution：修改之前的算子，SeqSacn、insert、delete等算子，加上合适的锁实现并发查询的效果</li></ul><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务可以简单的理解为执行几个sql语句的动作</p><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p><img src="/2023/04/13/CMU-15445/image-20230223193447618.png" alt="image-20230223193447618"></p><p>下面介绍一下什么是脏读、不可重复读、幻读</p><blockquote><p>脏读：就是事务t1先修改了数据x的值，然后事务t2读取了事务1修改后x的值，但是事务1有由于某些原因导致事务中止，而事务2进行了正常的提交，因此此时事务2读取了了一个根本不存在的值。</p></blockquote><blockquote><p>不可重复读：事务1读取了x的值，然后事务2对x进行了修改并提交了，然后事务1又去读取了x的值，此时读取的数据两次不一样，这就是不可重复读，就是两次不同的时间去读一个数结果不一致。</p></blockquote><blockquote><p>幻读：当事务1先读取符合搜索条件P的记录，然后T2写下了符合搜索田间P的记录，之后事务1再去读取符合搜索条件P的记录时，此时发现两次读取的记录不一样。</p></blockquote><p>在不同的隔离级别下，我们要满足上述的要求</p><p>读未提交：不用保证任何</p><p>读已提交：要保证不能发生脏读现象。</p><p>可重读：保证不能发生脏读和不可重读现象</p><p>以上都是通过上不同的锁来实现的</p><h3 id="lock-manager"><a href="#lock-manager" class="headerlink" title="lock manager"></a>lock manager</h3><p>为了保证事务们的操作的正常顺序和间隔，DBMS使用一个lock manager来控制事务何时能够被允许访问data items。LM中维护了某个tuple对应的事务锁请求，以及为某个具体的事务对某个tuple进行上锁、解锁、升级锁函数。</p><p><code>std::unordered_map&lt;RID, LockRequestQueue&gt; lock_table_;</code>// 记录了某个tuple的所有锁请求</p><p>对于每一个RID 也就是每一个tuple都对应着一个<code>LockRequestQueue</code>即锁请求队列，这个锁请求队列中主要就是一个std::list<LockRequest> request_queue_,这个LockRequest表示一个这个锁来自哪个事务，锁类型，锁是否授予等</LockRequest></p><p>这个lock manager 全局只有一个，当我们的Tableheap和Executor class 想要修改一个tuple时，需要使用它来获取相应的锁。根据不同的隔离级别，我们会在合适的地方进行上锁和解锁操作，以及更改事务的状态。如果上锁失败了，都应该产生一个ABORTED状态，并抛出异常（比如在Shrinking阶段时又尝试申请锁，又或者死锁了被aborted）。事务管理器txn manager应该之后捕获这个异常并将这个事务已经执行的操作进行rollback。</p><h3 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h3><p>Shared lock ：共享锁，也就是读锁</p><p>exclusive lock ： 排他锁，也就是写锁</p><h3 id="2PL-两阶段锁"><a href="#2PL-两阶段锁" class="headerlink" title="2PL 两阶段锁"></a>2PL 两阶段锁</h3><p>什么是两阶段锁，他是一种悲观的解决并发问题，所谓的两阶段锁，是一种能够无需提前知道未来所有事务内容的情况下保证调度冲突可串行化的一种并发协议。</p><p>两阶段封锁顾名思义分为两个阶段，分别是Growing阶段和Shrink阶段。在Growing阶段，事务从Lock Manager处获得执行事务所需要的所有数据对象的锁；当事务执行第一个解锁操作时，随后进入Shrink阶段，只能释放Growing阶段获得的锁，不能够重新获取新的锁。</p><blockquote><p>普通2PL产生的问题：<strong>级联回滚</strong></p></blockquote><p><strong>但是普通的2PL协议会产生<code>级联回滚</code>的问题：</strong>如下</p><p><img src="/2023/04/13/CMU-15445/v2-8bbbdcc2984d9e3712e511dc9573c461_r.jpg" alt="img"></p><p><strong>我们可以看出，如果T1在释放A锁之后，我们的T2获取了A锁，然后读取了A的内容并提交了，但是呢此时T1失败了，这样就会产生了脏读现象，需要对事务进行回滚。</strong></p><p><strong>为了解决这个问题，还有一种严格的2PL协议，就是在事务commit的时候才会去释放锁。</strong></p><blockquote><p>严格2PL（两阶段锁）</p></blockquote><p><strong>如果所有的事务都遵守二阶段锁定协议的话，在事务之前获取锁，事务结束阶段释放锁，那么所有并发事务执行结果必然正确，这是严格的2PL</strong></p><p>而且完全遵守二阶段锁效率是非常低下的。所以这里提出了妥协，就是设置了不同的隔离等级，来避免脏读、不可重复读、幻读等。相当于介于严格和普通的2PL锁协议之间。（主要体现在三个方面 1. 读以提交的我们甚至都没有采用两阶段锁协议，因为读锁释放之后还可以获取 2. 我们将写锁的释放都延迟到了事务提交阶段  3. 在可重复读时 可以释放读锁，但是需要进入shinking阶段，写锁的释放推迟到事务提交阶段释放。）</p><p>这里我们只需要完成<strong>未提交读（read uncommitted）</strong>，<strong>提交读（read committed）</strong>，<strong>可重复读（repeatable read）</strong></p><p>具体的上锁计划如下：</p><ol><li>READ_UNCOMMITED只有在需要时上写锁。</li><li>READ_COMMITTED要解决脏读的问题，解决方案就是读时上读锁，读完解读锁；写时上写锁，但等到commit时才解写锁；读时上读锁，读完解读锁。这样，永远不会读到未commit的数据，因为上面有写锁。（这样就保证了脏读的出现，但是不能保证可重读）（这里没有使用两阶段锁协议其实，就是普通的加锁和解锁，因为我们都没有）<ul><li>具体就是读时上读锁，读完释放读锁（但是我们不会将事务状态改为shriking）写时上写锁，然后在事务提交的时候才释放写锁，然后将事务改为shrinking状态。</li></ul></li><li>REPEATABLE_READ 其实就是我在执行事务的时候不想被别的事务打扰， <strong>二级封锁协议加上事务</strong>,A事务读取数据的时候就加上共享锁，如果释放共享锁了，就不能再获取锁了进入shinking阶段（保证自己下面不能再获取锁进行读了，以此避免不可重读），但是其他的事务可以读取，因为s锁是可以共存的，如果是X锁，要到事务提交后才能释放锁，且别的事务无法打扰。这就避免了脏读和不可重复读现象发生。<ul><li>具体就是可以在读完之后释放锁，但是需要更改状态位shinking，将写锁的释放推迟到事务提交</li></ul></li></ol><blockquote><p><strong>所谓的最后释放锁，其实就是在事务提交的时候，不断的遍历这个事务所持有的锁，然后挨个释放，在insert、update等算子中我们不执行释放锁就行了</strong></p></blockquote><h3 id="lock-manager函数"><a href="#lock-manager函数" class="headerlink" title="lock manager函数"></a>lock manager函数</h3><h4 id="先介绍几个相关的类"><a href="#先介绍几个相关的类" class="headerlink" title="先介绍几个相关的类"></a>先介绍几个相关的类</h4><p>TransactionManager：包含事务开启、事务的提交、事务的中止的方法、以及根据事务id获取指定的事务</p><p>Transaction： 包含了事务的一些属性，事务id，事务的隔离级别，这个事务所拥有哪些tuple的锁，事务的状态，等信息。</p><p>LockManager： 包含了每个tuple对应的事务上锁请求，完成某个事务对某个tuple的上锁、解锁操作等</p><p>LockRequest： 上锁请求，包含了事务id、上锁类型、是否上锁信息，这个是对应在lockmanager中的某个RID的，所以不需要指定rid了</p><h4 id="WOUND-wait算法"><a href="#WOUND-wait算法" class="headerlink" title="WOUND-wait算法"></a>WOUND-wait算法</h4><p>这是一种抢占式算法，在本项目中就是假如说年轻的事务正在持有某一个tuple的锁，但是此时老事务也想要获取这个锁，那么我们就要把这个锁给老事务，而把新事务给aborted掉。这种操作就可以避免死锁产生。如果此时年老的事务正在持有某个tuple的锁，但是年轻的事务也要想获取锁，于是就等待老事务将锁释放。</p><h4 id="LockShared函数"><a href="#LockShared函数" class="headerlink" title="LockShared函数"></a>LockShared函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquire a lock on RID in shared mode. See [LOCK_NOTE] in header file.</span><br><span class="hljs-comment"> * @param txn the transaction requesting the shared lock</span><br><span class="hljs-comment"> * @param rid the RID to be locked in shared mode</span><br><span class="hljs-comment"> * @return true if the lock is granted, false otherwise</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LockShared</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span></span>;<br></code></pre></td></tr></table></figure><p>给一个事务去申请某个tuple的shared锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LockManager::LockShared</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> </span>&#123;<br>  <span class="hljs-comment">// 首先判断这个事务是不是已经aborted了</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 查看事务的隔离级别,READ_UNCOMMITTED只有在写的时候才能加锁</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetIsolationLevel</span>() == IsolationLevel::READ_UNCOMMITTED)&#123;<br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TransactionAbortException</span>(txn-&gt;<span class="hljs-built_in">GetTransactionId</span>(), AbortReason::LOCKSHARED_ON_READ_UNCOMMITTED);<br>  &#125;<br>  <span class="hljs-comment">// 在GROWING阶段才可以加锁</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::SHRINKING)&#123;<br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TransactionAbortException</span>(txn-&gt;<span class="hljs-built_in">GetTransactionId</span>(), AbortReason::LOCK_ON_SHRINKING);<br>  &#125;<br>  <span class="hljs-comment">// 是否这个事务已经获取了这个tuple的shared锁</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">IsSharedLocked</span>(rid))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">//接下来继续上锁，并采取wound-wait算法进行上锁，老的抢占年轻的锁</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(latch_)</span></span>;<span class="hljs-comment">// 下面是对共享资源lock_table_更改，所以要上锁</span><br>  LockRequestQueue * lock_request_queue = &amp;lock_table_[rid];<br>  <span class="hljs-function">LockRequest <span class="hljs-title">lockrequest</span><span class="hljs-params">(txn-&gt;GetTransactionId(),LockMode::SHARED)</span></span>;<br>  lock_request_queue-&gt;request_queue_.<span class="hljs-built_in">emplace_back</span>(lockrequest);<br>  txn-&gt;<span class="hljs-built_in">GetSharedLockSet</span>()-&gt;<span class="hljs-built_in">emplace</span>(rid);<br><br>  <span class="hljs-comment">// 上锁要讲究顺序，采取的算法是WOUND-WAIT算法，老的抢占年轻的，年轻的等待</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">NeedWait</span>(txn,lock_request_queue))&#123;<br>    <span class="hljs-comment">// 如果需要等待，我们这里使用线程等待，使用wait</span><br>    lock_request_queue-&gt;cv_.<span class="hljs-built_in">wait</span>(guard);<br>    <span class="hljs-comment">// 这个等待会被唤醒，同时我们要判断我们这个事务是不是在等待过程中被别的事务给中止了</span><br>    <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果我们在等待过程中没有被中止，那我们再判断一下是不是还需要等待</span><br>  &#125;<br><br>  <span class="hljs-comment">// 如果不需要等待，说明我们可以授予锁了</span><br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : lock_request_queue-&gt;request_queue_)&#123;<br>    <span class="hljs-keyword">if</span>(e.txn_id_ == txn-&gt;<span class="hljs-built_in">GetTransactionId</span>())&#123;<br>      e.granted_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::GROWING);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="NeedWait函数"><a href="#NeedWait函数" class="headerlink" title="NeedWait函数"></a>NeedWait函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LockManager::NeedWait</span><span class="hljs-params">(Transaction *txn, LockRequestQueue *lock_queue)</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> self = lock_queue-&gt;request_queue_.<span class="hljs-built_in">back</span>();<br><br>  <span class="hljs-keyword">auto</span> first_iter = lock_queue-&gt;request_queue_.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">if</span> (self.lock_mode_ == LockMode::SHARED) &#123;<br>    <span class="hljs-keyword">if</span> (first_iter-&gt;txn_id_ == txn-&gt;<span class="hljs-built_in">GetTransactionId</span>() || first_iter-&gt;lock_mode_ == LockMode::SHARED) &#123;<span class="hljs-comment">// 从这里我们可以知道，唤醒之后，是执行事务请求队列中的第一个事务</span><br>      <span class="hljs-comment">// 1. 看看这个锁请求队列中是不是只有一个事务，如果只有一个事务，那么就把这个锁给这个请求者（不需要等待）</span><br>      <span class="hljs-comment">// 第一个一定是获取锁请求的，所以如果此时获取锁是SHARED那么是可以共存的s锁，不需要等待</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (first_iter-&gt;txn_id_ == txn-&gt;<span class="hljs-built_in">GetTransactionId</span>()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// need wait, try to prevent it.</span><br>  <span class="hljs-type">bool</span> need_wait = <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">bool</span> has_aborted = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 采取的是年轻的等待老的，老的直接抢占新的，事务的id越小越老</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = first_iter; iter-&gt;txn_id_ != txn-&gt;<span class="hljs-built_in">GetTransactionId</span>(); iter++) &#123;<br>    <span class="hljs-keyword">if</span> (iter-&gt;txn_id_ &gt; txn-&gt;<span class="hljs-built_in">GetTransactionId</span>()) &#123; <span class="hljs-comment">// 这个是比自己年轻的</span><br>      <span class="hljs-type">bool</span> situation1 = self.lock_mode_ == LockMode::SHARED &amp;&amp; iter-&gt;lock_mode_ == LockMode::EXCLUSIVE; <span class="hljs-comment">// 情景一：自己申请的锁是S并且比自己年轻的锁是X</span><br>      <span class="hljs-type">bool</span> situation2 = self.lock_mode_ == LockMode::EXCLUSIVE;<span class="hljs-comment">// 情景二：自己申请的锁是X锁</span><br>      <span class="hljs-keyword">if</span> (situation1 || situation2) &#123;<br>        <span class="hljs-comment">// abort younger ，事务编号越大越年轻，以上两种情况，都不允许年轻的事务还持有锁，直接给他abort</span><br>        Transaction *younger_txn = TransactionManager::<span class="hljs-built_in">GetTransaction</span>(iter-&gt;txn_id_);<br>        <span class="hljs-keyword">if</span> (younger_txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::ABORTED) &#123;<br>          <span class="hljs-built_in">LOG_DEBUG</span>(<span class="hljs-string">&quot;%d: Abort %d&quot;</span>, txn-&gt;<span class="hljs-built_in">GetTransactionId</span>(), iter-&gt;txn_id_);<br>          younger_txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>          has_aborted = <span class="hljs-literal">true</span>;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 下面都是比自己老的事务在持有锁，所以我们要等待</span><br>    <span class="hljs-keyword">if</span> (self.lock_mode_ == LockMode::EXCLUSIVE) &#123;<br>      need_wait = <span class="hljs-literal">true</span>; <span class="hljs-comment">// </span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (iter-&gt;lock_mode_ == LockMode::EXCLUSIVE) &#123;<br>      need_wait = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 因为老事务的锁是EXCLUSIVE，那么我需要等待，无论我是SHARED还是EXCLUSIVE</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (has_aborted) &#123;<br>    lock_queue-&gt;cv_.<span class="hljs-built_in">notify_all</span>(); <span class="hljs-comment">// 这个时候我们应该所有等待的事务都唤醒（也就是线程），唤醒后判断是否被aborted了，如果别中止了，那个线程就直接返回false了，也就是上锁失败了</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> need_wait;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>关于X锁和S锁共存问题</p></blockquote><p><img src="/2023/04/13/CMU-15445/image-20230223224027708.png" alt="image-20230223224027708"></p><p>判断是否需要等待获取锁，基本思想就是，老的事务抢占年轻的，年轻的等待老的，S锁可以同时获取。</p><p>这个锁请求在lockmanager的hash表中，一个tuple对应着一个锁请求队列，这个队列中都是要上锁的请求。按照之前的申请的顺序排列的。</p><p>然后我们构建一个锁请求后，然后根据WOUND-wait算法来判断是不是需要等待。</p><ol><li>如果自己申请的是shared锁，并且此时持有锁的事务持有的是这个tuple的s锁，那么不用等待，直接返回</li><li>如果此时自己申请的是S锁，但是前面比自己年轻的事务持有的是X锁，那么就把这个事务给abort掉</li><li>如果自己申请的是X锁，那么比自己年轻的全部都abort掉</li><li>如果abort掉比自己年轻的事务后，还有老的事务，就等待着，因为一个线程绑定一个事务，所以用线程的wait方法进行等待</li><li>我们要注意了，如果我们把一些年轻的事务abort，我们需要唤醒所有的等待的事务，然后把这些abort的事务获取锁结果返回false，不然他们还是一直等待。</li></ol><h4 id="LockExclusive函数"><a href="#LockExclusive函数" class="headerlink" title="LockExclusive函数"></a>LockExclusive函数</h4><p>基本思路和获取s锁一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LockManager::LockExclusive</span><span class="hljs-params">(Transaction *txn, <span class="hljs-type">const</span> RID &amp;rid)</span> </span>&#123;<br><br>  <span class="hljs-comment">// 首先判断这个事务是不是已经aborted了</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-comment">// 在GROWING阶段才可以加锁</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetState</span>() != TransactionState::GROWING)&#123;<br>    txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::ABORTED);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TransactionAbortException</span>(txn-&gt;<span class="hljs-built_in">GetTransactionId</span>(), AbortReason::LOCK_ON_SHRINKING);<br>  &#125;<br>  <span class="hljs-comment">// 是否这个事务已经获取了这个tuple的exclusive锁</span><br>  <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">IsExclusiveLocked</span>(rid))&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-comment">//接下来继续上锁，并采取wound-wait算法进行上锁，老的抢占年轻的锁</span><br>  <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(latch_)</span></span>;<span class="hljs-comment">// 下面是对共享资源lock_table_更改，所以要上锁</span><br>  LockRequestQueue * lock_request_queue = &amp;lock_table_[rid];<br>  <span class="hljs-function">LockRequest <span class="hljs-title">lockrequest</span><span class="hljs-params">(txn-&gt;GetTransactionId(),LockMode::EXCLUSIVE)</span></span>;<br>  lock_request_queue-&gt;request_queue_.<span class="hljs-built_in">emplace_back</span>(lockrequest);<br>  txn-&gt;<span class="hljs-built_in">GetExclusiveLockSet</span>()-&gt;<span class="hljs-built_in">emplace</span>(rid);<br>  <span class="hljs-comment">// 上锁要讲究顺序，采取的算法是WOUND-WAIT算法，老的抢占年轻的，年轻的等待</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-built_in">NeedWait</span>(txn,lock_request_queue))&#123;<br>    <span class="hljs-comment">// 如果需要等待，我们这里使用线程等待，使用wait</span><br>    lock_request_queue-&gt;cv_.<span class="hljs-built_in">wait</span>(guard);<br>    <span class="hljs-comment">// 这个等待会被唤醒，同时我们要判断我们这个事务是不是在等待过程中被别的事务给中止了</span><br>    <span class="hljs-keyword">if</span>(txn-&gt;<span class="hljs-built_in">GetState</span>() == TransactionState::ABORTED)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果我们在等待过程中没有被中止，那我们再判断一下是不是还需要等待</span><br>  &#125;<br>  <span class="hljs-comment">// 如果不需要等待，说明我们可以授予锁了</span><br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : lock_request_queue-&gt;request_queue_)&#123;<br>    <span class="hljs-keyword">if</span>(e.txn_id_ == txn-&gt;<span class="hljs-built_in">GetTransactionId</span>())&#123;<br>      e.granted_ = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br>  txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::GROWING);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="LockUpdate函数"><a href="#LockUpdate函数" class="headerlink" title="LockUpdate函数"></a>LockUpdate函数</h4><p>就是将已经获取到S锁的事务（也就是此时这个tuple的正在被这个事务锁着），然后又想获得X锁，所以此时我们应该将SharedLock的请求给删除掉，然后在第一个没有授予锁的请求之前插入EXCLUSIVE锁，（因为此时这个事务在获取锁呢，说明现在排队等的都是比自己年轻的事务），所以我们将创建的新的锁请求放到队列的最前面，这样就会使得它去获得锁了。这个过程中大锁一直都持有，所以外界是看不到中间过程的。</p><h4 id="Unlock函数"><a href="#Unlock函数" class="headerlink" title="Unlock函数"></a>Unlock函数</h4><p>解锁操作，就是将一个事务对某个tuple上的锁进行解锁，解锁完成之后，我们需要唤醒所有正在等待这个tuple锁的请求队列，因为这种情况下可能会有多个事务都会获取锁。然后记得再将这个事务种的lockset中对应的tuple给删除掉。</p><blockquote><p>这里解锁的思路虽然是上面，但是我们还需要根据2pl协议和事务隔离级别，在解锁后更改事务的状态。</p></blockquote><p>这一点我们可以看我们之前总结那三个隔离级别下的事务状态变化</p><p><img src="/2023/04/13/CMU-15445/image-20230224161625654.png" alt="image-20230224161625654"></p><p>结论：所以，只有在REPEATABLE_READ隔离级别下，我们才需要在第一次SHARED锁解锁后将事务的状态设置成SHIRNKING状态，另外两个隔离级别是不需要这个两阶段锁协议的，并且READ_COMMITTED和REPEATABLE_READ的X锁释放都是在事务提交的时候才释放锁（可以看下面的代码，X锁的释放由事务提交统一释放），那个时候事务已经结束了，所以就不需要再判断解锁X锁设置事务状态为SHIRNKING，对于X锁，直接解锁就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TransactionManager::Commit</span><span class="hljs-params">(Transaction *txn)</span> </span>&#123;<br>  <span class="hljs-built_in">LOG_DEBUG</span>(<span class="hljs-string">&quot;%d: Start to commit&quot;</span>, txn-&gt;<span class="hljs-built_in">GetTransactionId</span>());<br>  txn-&gt;<span class="hljs-built_in">SetState</span>(TransactionState::COMMITTED);<br><br>  <span class="hljs-comment">// Perform all deletes before we commit.</span><br>  <span class="hljs-keyword">auto</span> write_set = txn-&gt;<span class="hljs-built_in">GetWriteSet</span>();<br>  <span class="hljs-keyword">while</span> (!write_set-&gt;<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">auto</span> &amp;item = write_set-&gt;<span class="hljs-built_in">back</span>();<br>    <span class="hljs-keyword">auto</span> table = item.table_;<br>    <span class="hljs-keyword">if</span> (item.wtype_ == WType::DELETE) &#123;<br>      <span class="hljs-comment">// Note that this also releases the lock when holding the page latch.</span><br>      table-&gt;<span class="hljs-built_in">ApplyDelete</span>(item.rid_, txn);<br>    &#125;<br>    write_set-&gt;<span class="hljs-built_in">pop_back</span>();<br>  &#125;<br>  write_set-&gt;<span class="hljs-built_in">clear</span>();<br><br>  <span class="hljs-comment">// Release all the locks.</span><br>  <span class="hljs-built_in">ReleaseLocks</span>(txn);<br>  <span class="hljs-comment">// Release the global transaction latch.</span><br>  global_txn_latch_.<span class="hljs-built_in">RUnlock</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="concurrent-query-execution"><a href="#concurrent-query-execution" class="headerlink" title="concurrent query execution"></a>concurrent query execution</h3><p>所谓的并发执行，就是在之前的算子中，SeqScan、Insert、delete等。在这些算子中，我们需要通过合适的加锁和解锁操作来实现不同的隔离级别。如何加锁和解锁如下：</p><p><img src="/2023/04/13/CMU-15445/image-20230224163001377.png" alt="image-20230224163001377"></p><h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h2><p>参考书籍：《MySQL是怎样运行的》</p><p>参考博客：<a href="https://www.xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84">https://www.xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84</a></p><p>参考博客：<a href="https://www.cnblogs.com/zhiyiYo/p/16972668.html">https://www.cnblogs.com/zhiyiYo/p/16972668.html</a></p><blockquote><p><strong>MVCC实现了读已提交和可重读隔离级别，他是通过生成一个<code>readview</code>和<code>undo日志</code>实现版本链的追踪。</strong></p><ul><li>通过在不同的事情生成readview来实现不同的隔离级别</li><li><strong><code>READ COMMITTED</code>： 在每次执行select时都会产生一个新的read view，这样就能保证每次查询的数据都是可提交的</strong></li><li><strong><code>REPEATABLE READ</code>： 这个是在事务第一次执行select语句的时候才会生成READ VIEW,之后就不会再继续生成了。</strong></li></ul></blockquote><blockquote><p>MVCC是一种乐观策略，他不会阻塞和等待，而2PL是一种悲观策略，他会导致事务的阻塞</p></blockquote><h3 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h3><p>所谓的readview就是，它其实就是记录某一时刻事务的状态，主要有4个字段进行记录。</p><ul><li><code>m_low_limit_id</code>：<code>DB_TRX_ID</code> 大于等于 <code>m_low_limit_id</code> 的记录对于当前查询不可见</li><li><code>m_up_limit_id</code>：<code>DB_TRX_ID</code> 小于 <code>m_up_limit_id</code> 的记录对于当前查询可见</li><li><code>m_creator_trx_id</code>：创建了 <code>ReadView</code> 的事务，也就是当前执行了 <code>SELECT</code> 语句的事务</li><li><code>m_ids</code>：创建 <code>ReadView</code> 时仍处于活跃状态的事务列表</li></ul><p><code>ReadView::changes_visible</code> 用来鉴定一个记录对于当前查询是否可见，分为以下几种情况：</p><ul><li>如果 <code>id</code> 小于 <code>m_up_limit_id</code>，说明记录在快照创建之前就已提交，可见</li><li>如果 <code>id</code> 等于 <code>m_creator_trx_id</code>，说明这条记录被当前事务所修改，可见</li><li>如果 <code>id</code> 大于等于 <code>m_low_limit_id</code>，说明这条记录是在快照创建之后被修改的，不可见</li><li>如果 <code>id</code> 在 [<code>m_up_limit_id</code>, <code>m_low_limit_id</code>) 之间，需要判断 <code>id</code> 在不在活跃事务列表中，如果在说明这条记录还没被提交则不可见，不在的话就是已被提交的记录则可见</li></ul><blockquote><p>基本流程就是：</p></blockquote><p>假如我们找到了一个tuple，然后看看这个tuple被谁更改了，</p><ul><li>如果此时这个tuple的事务id，小于最小的说明可见，可以直接读</li><li>如果大于最大的，不可见，我们需要根据这个rollpoint往前找，找到不活跃的事务，读其结果返回</li><li>如果在活跃事务id区间，不可见，我们需根据这个rollpoint往前找，找到不活跃的事务，读其结果返回</li><li>如果等于自己的事务id，可见</li></ul><h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><blockquote><p>这个索引是按照主键建立的B+树，所有的记录都是按照主键的大小进行排列，然后依次存放在不同的页中，页和页之间建立了一个双向链表。</p><ul><li>在叶子节点中，包含了这个记录的完整信息</li><li>对于页目录项的页和用户记录的页都是按照主键的大小进行形成一个双向链表</li></ul></blockquote><blockquote><p>InnoDB会默认的给我们生成一个聚簇索引，如果有主键，就按照主键生成，如果没有主键，就按照第一个不为NULL的列生成，如果都没有，自动生成一个id作为主键生成。</p></blockquote><p><img src="/2023/04/13/CMU-15445/7c635d682bd3cdc421bb9eea33a5a413.png" alt="图片"></p><h3 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h3><blockquote><p>这个索引是按照某一个非逐渐列建立的B+树</p><ul><li>在这个叶子节点中，只保存了<code>建立B+树用到的列</code>的和<code>主键</code>这两个记录,我们先找到这个列对应的主键信息，然后再去主键形成的B+树找到完整的记录</li><li>对于页目录项的页和用户记录的页都是按照非主键列的大小进行形成了一个双向链表</li></ul></blockquote><blockquote><p>二级索引的意义就是对于查找通过非主键的时候能够很快找到目标记录；</p><p>基本流程：</p><ul><li>先在自己这个列形成的B+树中找到对应的主键（可能有多个相同的这个列的记录，对应多个主键）</li><li>然后再拿到这个主键信息，到根据主键构建的B+树中找到目标记录；（称为回表）</li><li>然后继续从刚才在非主键B+树找到的非主键记录继续向后遍历是否还有满足的记录；如果有，继续重复2动作，没有就结束</li></ul></blockquote><blockquote><p>【补充】</p></blockquote><p>其实在二级索引时，对于页目录项节点，的记录其实包含了三个属性</p><ul><li>索引列的值</li><li>主键值</li><li>页号</li></ul><p>这是为了能够在大量索引值相同的情况下，快速找到对应的记录，通过这三个判断就能够保证在叶子节点存储时的顺序和正确查找。</p><p><img src="/2023/04/13/CMU-15445/3104c8c3adf36e8931862fe8a0520f5d.png" alt="图片"></p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><blockquote><p>联合索引就是使用多个列的大小作为排序规则，同时使用多个列建立B+树</p><ul><li>先按照第一个列进行排序，然后再按照第二个列进行排序，</li><li>在进行二分查找的时候必须要满足同时大于和同时小于才能确定这个目标页</li><li>其他的和二级索引没啥区别，叶子节点也是只记录了形成索引的列和主键。</li></ul></blockquote><blockquote><p>查找思路和步骤和二级索引相似。</p></blockquote><h3 id="B-树形成过程"><a href="#B-树形成过程" class="headerlink" title="B+树形成过程"></a>B+树形成过程</h3><blockquote><p><strong>根页面万年不动窝</strong></p></blockquote><p><strong>对于聚簇索引，这个InnoDB会默认给我们建立一个，我们只用建立其他的自己想要的就行。</strong></p><ul><li>当我们想要使用某个列创建一个索引时，首先会分配一个空的根页面节点</li><li>最开始，然后我们插入数据时，因为此时只有一个根页面节点，我们会直接将记录插入到这个页面</li><li>如果页面满了后继续插入，就会去申请两个页面，然后根据列的大小排序分别插入到这两个页面中，然后将这两个页面的信息插入到根页面节点中。</li></ul><p>【总结】：建立索引时，B+树根节点页面始终不变，我们查找数据时，就能够直接获取这个页面id然后进行操作了。</p><h2 id="undo-log-–-保证原子性"><a href="#undo-log-–-保证原子性" class="headerlink" title="undo log – 保证原子性"></a>undo log – 保证原子性</h2><p>这个日志用来保证事务执行的原子性，undo log会记录下来一个事务在执行过程中的所有增、删、改操作的记录。</p><ul><li>对于增，他会在undo log中记录下来这个新增的记录的主键值，然后后续回滚的时候，直接通过这个主键值删除对应的记录就行</li><li>对于删除，他会记录下来这个记录的所有信息，在回滚的时候插入到表中就行</li><li>对于更ixn，他会记录下来被更新的列的旧值，然后回滚时用这些去更新就行</li></ul><blockquote><p>每一个跟新操作产生的undo log格式都会包含一个roll_pointer指针和一个trx_id事务id：</p><ul><li>通过 trx_id 可以知道该记录是被哪个事务修改的；</li><li>通过 roll_pointer 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链；</li></ul></blockquote><p><img src="/2023/04/13/CMU-15445/%E7%89%88%E6%9C%AC%E9%93%BE.png" alt="版本链"></p><blockquote><p>其中MVCC多版本并发控制也是基于undo log实现的。</p></blockquote><h2 id="redo-log-–-保证持久性"><a href="#redo-log-–-保证持久性" class="headerlink" title="redo log – 保证持久性"></a>redo log – 保证持久性</h2><p>我们直到Bufferpool提升了读写效率，但是Bufferpool并不是每更新一个数据的时候就往磁盘写，而是由后台线程在适当的时候将其刷入到磁盘。</p><p>但是有时候会出现数据库突然断电的时候，这个bufferpool的数据还是没有来得及刷入到磁盘中，导致更改的数据丢失了，这肯定是不允许的，因此我们友引入了一个redo log机制</p><p>当我们对bufferpool的数据进行更改的时候，数据库会首先更新bufferpool，然后标记为ditry，然后我们会将这个页的修改以redo log的形式记录下来，这个时候更新就算完成了。这个技术就叫做WAL（write-ahead logging）–》mysql的写操作不是立刻写入到磁盘，而是更新bufferpool然后写入redo log中，然后在合适的机会将bufferpool的内容写入到磁盘中</p><blockquote><p>redo log是物理日志，他主要记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><ul><li><p>只要在事务提交的时候，将这个redo log写入到磁盘就行，不需要直接就把buffer中的数据写入磁盘（redo log是磁盘顺序写，而bufferpool是随机写）</p></li><li><p>当系统发生崩溃的时候，虽然buffer中的脏页还没有实现持久化，但是redo log已经实现了持久化，接着mysql重启时，就会根据redolog中的内容将所有数据恢复到最新状态。</p></li></ul></blockquote><p><img src="/2023/04/13/CMU-15445/wal.png" alt="img"></p><blockquote><p>被修改 Undo 页面，需要记录对应 redo log 吗？</p></blockquote><p>如果bufferpool中的undo log被修改了，也是会记录在redo log中的</p><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务，如下图</p><p><img src="/2023/04/13/CMU-15445/%E4%BA%8B%E5%8A%A1%E6%81%A2%E5%A4%8D.png" alt="事务恢复"></p><h2 id="MySQL优化"><a href="#MySQL优化" class="headerlink" title="MySQL优化"></a>MySQL优化</h2><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><blockquote><p>火山模型有什么优缺点？</p></blockquote><p>火山模型是一种流式迭代模型，比较常见的执行模型，将执行树的每个节点都设为一个执行器，然后自顶向下的调用NEXT接口，实现数据自底向上的数据流动。</p><p>他的优点是它可以单独的实现每个操作符，</p><p>但是他每次查询调用太多的next接口，并且是一个个数据的获取，cpu利用率低。</p><blockquote><p>为什么使用B+树而不是B树或者红黑树</p></blockquote><p>B树是每个节点都存放着索引和数据，数据遍布整个树结构，搜索可能在非叶子节点结束，但是也可能在中间就结束了。</p><p>而B+树是仅在叶子节点保存数据，其余节点只存放索引值，并且叶子节点中有指向下一个叶子节点的指针，叶子节点类似于链表。就是因为这个叶子节点保存了完整的数据以及有指针作为连接，B+树提高了了区间范围的访问性，提高了范围查询能力，而B树的范围查询能力较差。</p><p>B树只适合做随机检索，而B+树同时支持随机检索和顺序检索。</p><p>B+树空间利用率高，因为B+树的非叶子节点只保存索引，这些索引都是单独占一个页的，不像B树索引和数据都存放在一起同时在一个页中，这样B+树就能够一下子从磁盘中读到较多的索引，这样就可以更快的定位，减少了IO次数。</p><p>B树在元素遍历的时候效率较差，因为B+树的叶子节点相互连接的。</p><blockquote><p>索引失效的场景</p></blockquote><ul><li>模糊查询的时候以%开头</li><li>where中索引列有运算或使用了函数</li><li>进行了数据转换</li><li>复合索引没有用到左列字段</li><li>唯一性太差的字段可能也不会走索引</li></ul><p>什么场景下最好不使用索引：</p><ul><li>唯一性差，就是一个字段的取值就只有几种的时候，最好不用</li><li>频繁更新的字段不要使用，因为频繁变化导致索引变化</li><li>where中的大于号和小于号最好不要用</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++基础知识</title>
    <link href="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="C-基础知识"><a href="#C-基础知识" class="headerlink" title="C++基础知识"></a>C++基础知识</h1><h2 id="【随记】"><a href="#【随记】" class="headerlink" title="【随记】"></a>【随记】</h2><h3 id="1-引用"><a href="#1-引用" class="headerlink" title="1. 引用"></a>1. 引用</h3><p><a href="https://blog.csdn.net/weixin_62529445/article/details/126278769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~YuanLiJiHua~Position-1-126278769-blog-124724506.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~YuanLiJiHua~Position-1-126278769-blog-124724506.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=1">指针、引用</a></p><blockquote><p>引用的本质就是<strong>指针常量</strong>，一旦初始化完成，就无法再改变</p><p>引用实际上是给一个变量起的别名，编译器不会给引用变量开辟新的空间，变量和他的引用变量共用同一块内存</p></blockquote><blockquote><p>1.引用本质–引用是一个指针常量，引用一旦完成就无法改变</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//自定转化为int* const b=&amp;a;</span><br><span class="hljs-comment">//指针常量是指针的指向不可以改</span><br><span class="hljs-comment">//也就说明了引用为什么不可以改</span><br><span class="hljs-type">int</span>&amp; b = a;<br><span class="hljs-comment">//编译器发现b是引用，自动帮我们转化为*b=20;</span><br>b = <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>2.常量引用</p></blockquote><p>当函数参数是引用的时候，有时需要用到常量引用，涉及到权限以及防止误操作。</p><p>权限方面不能放大，只能缩小。</p><p>例如一个变量是一个可读可写的权限，可以修改为只读的权限。</p><p>一个变量是只读的权限，不能修改为可读可写的权限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//权限平移</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>&amp; b = a;<br> <br><span class="hljs-comment">//权限不能放大</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c = <span class="hljs-number">20</span>;<span class="hljs-comment">//c是只读</span><br><span class="hljs-comment">//int&amp; d=c;//d是可读可写 c是只读，错误</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; d = c;<span class="hljs-comment">//d是只读 权限平移</span><br> <br><span class="hljs-comment">//权限可以缩小</span><br><span class="hljs-type">int</span> e = <span class="hljs-number">30</span>;<span class="hljs-comment">//e可读可写</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; f = e;<span class="hljs-comment">//f只读</span><br> <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用引用传参，函<strong>数内如果不改变参数</strong>，建议使用const引用传参  const int&amp; b</p><p><strong>因为如果将引用作为参数，就相当于指针一样，就可以改变原有的值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用常量引用防止误操作修改实参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//b+=10;//误操作，改变了实参</span><br><span class="hljs-comment">// 加入const之后，都是只读的权限，避免通过引用修改实参</span><br>cout &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//该函数只是实现打印数据功能</span><br><span class="hljs-built_in">ShowValue</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>引用使用场景</p></blockquote><ol><li>引用做参数</li></ol><p>作用：函数传参时，可以用引用让形参修改实参</p><p>优点：简化指针修改实参</p><p>总结：<strong>通过引用参数产生的效果和按地址传递是一样的，引用的语法更加简单清楚，唯一的缺点就是引用无法重新赋值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//引用做函数参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tmp = a;<br>a = b;<br>b = tmp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;交换前a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;交换前b=&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-built_in">mySwap</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;交换后a=&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;交换后b=&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//交换前a=10 b=20</span><br><span class="hljs-comment">//交换后a=20 b=10</span><br></code></pre></td></tr></table></figure><ol start="2"><li>引用做返回值</li></ol><blockquote><p>引用可以做参数返回，但是不能返回局部变量的引用，可以返回静态变量的引用</p><p>因为局部变量是放在栈区的，函数结束后就会销毁变量，而静态变量是在静态区的，静态区的变量是在程序结束之后才释放的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这个程序使用引用返回本质是不对的，返回值没有保障</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-comment">//n存放在栈区，出了作用域就被销毁</span><br>n++;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>&amp; ret = <span class="hljs-built_in">count</span>();<br>cout &lt;&lt; ret &lt;&lt; endl;<br>cout &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//这个场景可以使用传引用返回</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">count</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<span class="hljs-comment">//static修饰的变量n存放在静态区</span><br>n++;<br><span class="hljs-keyword">return</span> n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>&amp; ret = <span class="hljs-built_in">count</span>();<br>cout &lt;&lt; ret &lt;&lt; endl;<br>cout &lt;&lt; ret &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-引用和指针的区别"><a href="#2-引用和指针的区别" class="headerlink" title="2. 引用和指针的区别"></a>2. 引用和指针的区别</h3><blockquote><p>语法角度：引用是没有开辟新的空间用来存储引用变量，指针是有一个空间用来存储指针变量的</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//语法角度，ra没有开空间</span><br><span class="hljs-type">int</span>&amp; ra = a;<br>ra = <span class="hljs-number">20</span>;<br> <br><span class="hljs-comment">//语法角度，pa开了4or8byte空间</span><br><span class="hljs-type">int</span>* pa =&amp;a;<br>*pa = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>底层角度：引用和指针都是开辟了新的空间</p></blockquote><p>实际上，b在内存条上是占用了一块空间的。不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间，<strong>且取其地址时直接取到所指向的地址</strong>。<strong>实际在内存空间上，引用本身也占用一块内存，里面存储着所引用的变量的地址，大小与指针相同，字面上也表现为unsigned long int型。只是经过编译器处理后，访问这块内存时将直接转而访问其指向的内存。因此在程序中无法读取到这块内存本身。</strong></p><p>这可以理解为“编译器的把戏”或“程序的谎言”，但这一机制不是为了捉弄程序员，而是为了真正实现别名的效果。</p><p>综上：<strong>引用的实现实际上是占用内存空间的，但程序把它按照不占用内存空间来处理</strong>。</p><blockquote><p>引用和指针的不同点：</p></blockquote><ol><li>引用概念上定义一个变量的别名，指针存储一个变量地址。</li><li>引用在定义时必须初始化，指针没有要求</li><li>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体</li><li>没有NULL引用，但有NULL指针</li><li>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)</li><li>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</li><li>有多级指针，但是没有多级引用</li><li>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</li><li>指针使用更强大，更危险，更复杂，引用比指针使用起来相对更安全，更简单，但相对局限</li></ol><h3 id="C-创建对象方式"><a href="#C-创建对象方式" class="headerlink" title="C++ 创建对象方式"></a>C++ 创建对象方式</h3><p><a href="https://blog.csdn.net/qq_44890993/article/details/126880953">C++创建对象的方式</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> String = std::string;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>  String m_Name;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Person</span>() :<span class="hljs-built_in">m_Name</span>(<span class="hljs-string">&quot;Unknown&quot;</span>) &#123;&#125;<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> String&amp; name) :<span class="hljs-built_in">m_Name</span>(name) &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> String&amp; <span class="hljs-title">GetName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> m_Name; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-在栈上创建对象"><a href="#1-在栈上创建对象" class="headerlink" title="1. 在栈上创建对象"></a>1. 在栈上创建对象</h4><p>在栈上创建的对象，有一个自动的生命周期，他们的生命周期由它声明的作用域所决定，换言之，只要变量超出了其作用域，该对象的内存就被释放了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  &#123;<br>    <span class="hljs-comment">// 在栈上创建对象</span><br>    <span class="hljs-comment">// 可以写为 Person personOnStack = Person(&quot;person1&quot;);</span><br>    <span class="hljs-function">Person <span class="hljs-title">personOnStack</span><span class="hljs-params">(<span class="hljs-string">&quot;person1&quot;</span>)</span></span>; <br>    <span class="hljs-comment">// 打印名字 person1</span><br>    std::cout &lt;&lt; personOnStack.<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>  &#125; <span class="hljs-comment">// 当代码运行到此行时，personOnStack将被回收</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-在堆上创建对象"><a href="#2-在堆上创建对象" class="headerlink" title="2. 在堆上创建对象"></a>2. 在堆上创建对象</h4><p>在堆上创建对象则不同。在堆上创建的对象会一直待在那里，直到你决定把它释放，空闲出其对应的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  &#123;<br>    <span class="hljs-comment">// 在堆上创建对象 关键词 new</span><br>    Person *personOnHeap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;person2&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 打印名字 person1</span><br>    std::cout &lt;&lt; personOnHeap-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 在堆上分配的对象要手动释放内存</span><br>  <span class="hljs-comment">// 即 new 和 delete一起使用</span><br>  <span class="hljs-keyword">delete</span> personOnHeap;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-比较"><a href="#3-比较" class="headerlink" title="3.比较"></a>3.比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 创建 Person 类型的指针</span><br>  Person *p1, *p2;<br>  &#123;<br>    <span class="hljs-comment">// 在栈上创建对象</span><br>    <span class="hljs-comment">// 可以写为 Person personOnStack = Person(&quot;person1&quot;);</span><br>    <span class="hljs-function">Person <span class="hljs-title">personOnStack</span><span class="hljs-params">(<span class="hljs-string">&quot;person1&quot;</span>)</span></span>; <br>    <span class="hljs-comment">// 在堆上创建对象 关键词 new</span><br>    Person *personOnHeap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;person2&quot;</span>);<br>    <span class="hljs-comment">/* p1指针指向 personOnStack 所在的内存地址</span><br><span class="hljs-comment">     * 在大括号之后 personOnStack 将被回收</span><br><span class="hljs-comment">     * 在大括号之后将获取不到 m_name = person1 的对象</span><br><span class="hljs-comment">     */</span><br>    p1 = &amp;personOnStack;<br>    <br>    <span class="hljs-comment">/* personOnHeap赋值给p2</span><br><span class="hljs-comment">     * 在大括号之后 personOnHeap不会被回收</span><br><span class="hljs-comment">     * 在大括号之后将获取到 m_name = person2 的对象 </span><br><span class="hljs-comment">     */</span><br>    p2 = personOnHeap;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 打印结果为空</span><br>  std::cout &lt;&lt; p1-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 打印名字 person2</span><br>  std::cout &lt;&lt; p2-&gt;<span class="hljs-built_in">GetName</span>() &lt;&lt; std::endl;<br>    <br>  <span class="hljs-comment">// 在堆上分配的对象要手动释放内存</span><br>  <span class="hljs-comment">// 即 new 和 delete一起使用</span><br>  <span class="hljs-keyword">delete</span> p2;<br>  <span class="hljs-comment">// 此处不需要delete p1的原因？</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码所示，当代码运行到main函数中的大括号后，personOnStack对象被释放，所以p1获取到的m_Name为空；而在堆上创建的，personOnHeap对象没有被释放，所以p2能够正常获取m_Name。</p><p>​    最后，p1不需要delete的原因——main函数中的大括号之后，personOnStack对象被释放，所以personOnStack对象的地址也被释放，p1指针不需要被delete。</p><h3 id="gcc工作流程"><a href="#gcc工作流程" class="headerlink" title="gcc工作流程"></a>gcc工作流程</h3><p><a href="https://blog.csdn.net/weixin_39875125/article/details/115566413">https://blog.csdn.net/weixin_39875125/article/details/115566413</a></p><h2 id="【基本语法】"><a href="#【基本语法】" class="headerlink" title="【基本语法】"></a>【基本语法】</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><blockquote><p>一维数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义方式1</span><br><span class="hljs-type">int</span>  arr[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">//定义方式2</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;  <span class="hljs-comment">//长度10，没有定义的为0</span><br><span class="hljs-comment">//定义方式3 </span><br><span class="hljs-type">int</span> arr2[]  = &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;    <span class="hljs-comment">//长度就是&#123;&#125;中的元素的个数</span><br><br>arr可以表示这个数组，以及数组的起始地址<br></code></pre></td></tr></table></figure><blockquote><p>二维数组</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义方式1</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">5</span>];<span class="hljs-comment">//定义一个3行5列的二维数组</span><br><span class="hljs-comment">//定义方式2</span><br><span class="hljs-type">int</span> arr1[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>&#125;&#125;;<br><br><span class="hljs-comment">//定义方式3</span><br><span class="hljs-type">int</span> arr2[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">45</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>,<span class="hljs-number">55</span>&#125;;<span class="hljs-comment">//他会自动帮我划分行和列</span><br><br><span class="hljs-comment">//定义方式4</span><br><span class="hljs-type">int</span> arr3[][<span class="hljs-number">3</span>]  = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;; <span class="hljs-comment">//必须要把列定义行，这样才能识别</span><br></code></pre></td></tr></table></figure><h3 id="2-指针"><a href="#2-指针" class="headerlink" title="2. 指针"></a>2. 指针</h3><blockquote><p>指向一块地址空间</p></blockquote><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>指针变量指向地址为0的空间</p><p>用途： 初始化指针</p><p>注意：空指针指向的内存是不可以访问的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p;<br><span class="hljs-type">int</span> *p  = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><p>定义： 指针变量指向非法的空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//定义指针变量p指向内存空间地址为0x1100的空间（但是没有事先申请，所以没有访问权限）</span><br><span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-number">0x1100</span>;<br>cout &lt;&lt; *p &lt;&lt; endl  <span class="hljs-comment">//访问野指针报错</span><br></code></pre></td></tr></table></figure><h4 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h4><blockquote><p>三种情况 – 就近原则，靠近谁，谁就不能修改</p></blockquote><ul><li><p>常量指针 ：顾名思义，就是指针指向了一个常量，也就是指针指向的变量不可修改</p></li><li><p>指针常量：这个指针是一个常量，不能修改这个指针，即无法修改指针的指向</p></li><li><p>const修饰指针和常量</p></li></ul><blockquote><p>常量指针：指针的指向可以改，但是指针指向的内容不可以改（其实是不能通过*p进行修改）</p><p>​    使用案例：<strong>可以作为一个函数参数，这样既可以取代了值传递，又不能修改原来的变量</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;a;<br><br>    *p = <span class="hljs-number">40</span>;  <span class="hljs-comment">//这个是错误的，不能通过*p进行修改，不代表a就是常量</span><br>    <br>    p = &amp;b; <span class="hljs-comment">//这个是正确的，可以更改指针的指向</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>指针常量：指针的指向不能改，指针指向的变量可以改，其实这个指针就是个常量了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br><br>    *p = <span class="hljs-number">40</span>; <span class="hljs-comment">//这个是正确的 ，可以修改指针指向的变量</span><br><br>    p = &amp;b;<span class="hljs-comment">//这个是错误的，无法修改指针的指向，指针是个常量</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure><blockquote><p>const 修饰指针和常量：指针指向无法修改，指针指向的变量无法修改</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br><br>    *p = <span class="hljs-number">40</span>;<span class="hljs-comment">//错误</span><br><br>    p = &amp;b; <span class="hljs-comment">//错误</span><br>    cout &lt;&lt; *p &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h4 id="指针访问数组元素"><a href="#指针访问数组元素" class="headerlink" title="指针访问数组元素"></a>指针访问数组元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">56</span>,<span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span> *p = arr;<span class="hljs-comment">//这个int 类型的指针就指向了这个数组</span><br>cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//输出数组的第一个元素 1</span><br>p++;<span class="hljs-comment">//这样就指向了数组的第二个元素，p = p+5;表示指向从p开始计数后的第五个元素</span><br>cout &lt;&lt; *p &lt;&lt; endl;<span class="hljs-comment">//输出 2</span><br><br></code></pre></td></tr></table></figure><h3 id="3-内存四区"><a href="#3-内存四区" class="headerlink" title="3. 内存四区"></a>3. 内存四区</h3><blockquote><ul><li>代码区</li><li>全局区</li><li>栈区</li><li>堆区</li></ul></blockquote><blockquote><p>代码区：存放代码，其实就是代码段</p></blockquote><blockquote><p>全局区：存放全局变量，static变量，全局常量，<strong>字符串常量</strong>；</p><p>​                局部变量不存在全局区；</p><p>栈区：存放局部变量，函数返回地址，<strong>不要将局部变量的地址返回出去</strong>，因为函数结束后，局部变            量地址空间被释放了，可能会被其他内容覆盖。<strong>但是，这个也不是绝对的，如果我们的            局部变量开辟在堆区中，是可以将其返回的</strong>。</p><p>堆区：堆区是由程序员进行管理和开辟的，<strong>堆区数据利用new关键字进行内存开辟</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//在堆区中申请了一个内存存放10，并返回这个空间的地址</span><br>        <span class="hljs-keyword">return</span> p; <span class="hljs-comment">//将这个堆区中的10的地址返回出去，这个指针变量p在栈中，被释放</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> *m = <span class="hljs-built_in">func</span>();<span class="hljs-comment">//获取指针，这个指针就指向了堆区10的地址,这个空间不会自动释放</span><br>        cout &lt;&lt; *m &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-new和delete"><a href="#4-new和delete" class="headerlink" title="4. new和delete"></a>4. new和delete</h3><blockquote><p>new 用来在堆区申请一块内存，并返回内存的地址</p><p>delete 用来释放new出来的地址空间</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);     <span class="hljs-comment">//在堆中申请一块内存</span><br><span class="hljs-keyword">delete</span> p;                      <span class="hljs-comment">//释放内存</span><br><br><span class="hljs-type">int</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];      <span class="hljs-comment">//在堆中申请一块数组空间</span><br><span class="hljs-keyword">delete</span>[] p;                  <span class="hljs-comment">//使用delete[]  来释放</span><br></code></pre></td></tr></table></figure><blockquote><p>对于基本类型，使用delete 或者delete[] 都可以释放数组空间，但是对于对象就不行</p><p>因为对象空间的释放是调用其析构函数，delete只是调用一个对象的析构函数，delete[] 才是调用对象数组中的所有对象的析构函数来释放，所以释放对象数组要用delete[]；</p></blockquote><h3 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h3><p>看上面【随记】</p><p>int a = 10;</p><p>int &amp;b = a; //定义一个引用b</p><h4 id="引用本质"><a href="#引用本质" class="headerlink" title="引用本质"></a>引用本质</h4><blockquote><p><strong>本质就是指针常量</strong>–不能改变指向，可以改变变量</p></blockquote><blockquote><p>引用必须初始化，且不能更改引用对象</p></blockquote><blockquote><p>引用也占用空间，但是无法找到引用的地址，即使cout&lt;&lt; &amp;b &lt;&lt; endl 这个输出的是变量a的地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a; <span class="hljs-comment">//编译的时候会自动的转成int *const b =a; 所以就是一个指针常量，不可改变指向，可以修改值</span><br>b = <span class="hljs-number">20</span>;     <span class="hljs-comment">//编译的时候会自动转成 *b =20;</span><br><br></code></pre></td></tr></table></figure><h4 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h4><blockquote><p>不能改指向，也不能改值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a =<span class="hljs-number">20</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;b =<span class="hljs-number">20</span>; <span class="hljs-comment">// 其实就是const int &amp; b = 20;</span><br></code></pre></td></tr></table></figure><h3 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h3><blockquote><p>函数的形参可以直接定义成默认参数，但是声明和定义中必须只能有一个保留默认参数</p></blockquote><h4 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//占位参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span></span>; <span class="hljs-comment">//第二个int 就是占位的，但是函数调用的时候必须要传进来具体值，占位参数也可以有默认值</span><br><span class="hljs-comment">//void func(int a,int = 10); 这个也是正确的</span><br></code></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>作用：【函数名可以相同，提高复用性】</p><blockquote><p>函数重载满足的条件</p></blockquote><ul><li>同一个作用域下</li><li>函数名相同</li><li>函数的<strong>参数类型不同</strong>或者 **个数不同 **或者 <strong>顺序不同</strong></li></ul><p>【注意】函数的返回值不能够作为函数重载的条件，只能是上面那三个差别。但是函数重载是可以返回值不一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;int func(int a,double b)&quot;</span> &lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;func (char c)&quot;</span> &lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//重载的原因是参数导致的，返回值不参与</span><br></code></pre></td></tr></table></figure><blockquote><p>其他的重载函数注意</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> =<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//有默认值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-type">int</span> c =<span class="hljs-number">10</span>; <br>    <span class="hljs-built_in">f</span>(c);<span class="hljs-comment">//调用的无const    因为a是个变量，可以改,即int &amp;a =c ;合法</span><br>    <br>    <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">//调用有coonst ， 10是个常量，const int&amp;a =10 合法</span><br>       <br>     <span class="hljs-built_in">f1</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">//这个时候就不知到调用哪个f1了，需要避免</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="【类与对象】"><a href="#【类与对象】" class="headerlink" title="【类与对象】"></a>【类与对象】</h2><blockquote><p>三大特性</p></blockquote><ul><li>封装</li><li>继承</li><li>多态</li></ul><blockquote><p>权限：public protect private</p></blockquote><ul><li><p>public  类外和类内都可以访问</p></li><li><p>protect 类外不可以访问，但是子类继承可以访问</p></li><li><p>private 类外不可以访问，但是子类不能可以访问</p></li></ul><h3 id="1-class-和-struct差别"><a href="#1-class-和-struct差别" class="headerlink" title="1. class 和 struct差别"></a>1. class 和 struct差别</h3><ul><li>struct 默认权限是public</li><li>class 默认权限是private</li></ul><h3 id="2-对象的初始化和清理"><a href="#2-对象的初始化和清理" class="headerlink" title="2. 对象的初始化和清理"></a>2. 对象的初始化和清理</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221127155115222.png" alt="image-20221127155115222"></p><h4 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h4><p>两种分类方式</p><ul><li>按参数分类：有参构造和无参构造</li><li>按类型分类：普通构造和拷贝构造</li></ul><p>三种调用方式</p><ul><li>括号法</li><li>显示法</li><li>隐士转换法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span> &#123;<br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">person</span>()&#123;<br>        <br>    &#125;<br>   <br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)&#123;<br>        age = a;<br>        cout &lt;&lt; age &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)&#123;<br>        age = p.age;<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()&#123;<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//括号法</span><br>person p1;  <span class="hljs-comment">//默认构造函数调用，person p1();这个不行，这个会被认为是一个函数声明</span><br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 有参构造函数调用</span><br><span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>;<span class="hljs-comment">//采用拷贝构造函数调用</span><br><br><span class="hljs-comment">//显示法</span><br>person p1;<br>person p2 = <span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//有参构造</span><br>person p3 = <span class="hljs-built_in">person</span>(p2) <span class="hljs-comment">//拷贝构造</span><br><span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>) ;<span class="hljs-comment">//匿名对象，最好不要拷贝构造函数初始化匿名对象</span><br><br><span class="hljs-comment">//隐士转换法</span><br>person p4 = <span class="hljs-number">10</span>;<span class="hljs-comment">//相当于 person p4 = person(10);</span><br>person p5 = p3; <span class="hljs-comment">//相当于person p5 = person(p3);</span><br><br></code></pre></td></tr></table></figure><blockquote><p>拷贝构造函数的调用时机</p></blockquote><ul><li><p>使用一个已经创建完毕的对象初始化一个新对象</p></li><li><p>值传递的方式给函数初始值</p></li><li><p>值方式返回局部对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1. 使用一个已经创建完毕的对象初始化一个新对象</span><br><span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>; <span class="hljs-comment">//这个是直接调用拷贝函数初始化一个对象</span><br><br><span class="hljs-comment">//2. 使用值传递方式给函数参数赋值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(person p)</span></span>&#123;<br>    <br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-built_in">f</span>(p1);  <span class="hljs-comment">//这个相当于隐士调用，person p = p1  =&gt;person p = person(p1);</span><br>    <span class="hljs-comment">//会调用这个拷贝函数</span><br>&#125;<br><br><span class="hljs-comment">//3. 值方式返回局部对象  -- 记住一点就行，返回的是值，也是值传递，(会去调用拷贝构造)</span><br><span class="hljs-function">person <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    person p;<br>    <span class="hljs-keyword">return</span> p;  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<br>     person p1 = <span class="hljs-built_in">f</span>();  <span class="hljs-comment">//这个会返回一个值对象，也就是不是f()中的那个p，而是拷贝了一份返回回来了</span><br>    <span class="hljs-comment">//person p1 = p; 隐士转换</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><ul><li>一般默认会给我们提供无参构造函数，和拷贝构造函数</li><li>如果我们写了有参构造函数，编译器就不再提供默认构造函数，但是依旧提供拷贝构造函数</li></ul><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><ul><li>浅拷贝：简单的赋值拷贝操作</li><li>深拷贝：在堆区中重新申请空间，进行拷贝操作</li></ul><blockquote><p>浅拷贝</p></blockquote><p>直接拷贝复制过去，如果其中一个对象调用了析构函数，就会使得共同指向的堆区被其中一个释放</p><p>从而导致另一个对象无法访问和释放</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221128110425379.png" alt="image-20221128110425379"></p><blockquote><p>深拷贝</p></blockquote><p>重新在堆空间申请一块内存给到赋值的对象</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221128110551004.png" alt="image-20221128110551004"></p><blockquote><p>总结</p></blockquote><p><strong>如果类中有在堆区开辟的属性，那么一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p><h4 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//就是上面的那个f()函数，返回一个person</span><br>person p1 = <span class="hljs-built_in">f</span>();<span class="hljs-comment">//这个有的编译器会进行返回值优化，也就是直接将p1指向f()中的p的空间</span><br></code></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><blockquote><p>将堆区代码开辟的空间释放</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221127155150127.png" alt="image-20221127155150127"></p><h3 id="3-类的静态成员"><a href="#3-类的静态成员" class="headerlink" title="3. 类的静态成员"></a>3. 类的静态成员</h3><blockquote><p>变量</p></blockquote><ul><li>所有对象共享这个一个变量</li><li>编译阶段分配内存</li><li>类内声明，类外初始化操作</li><li>访问方式： 可以直接  <strong>类名::变量</strong>访问，也可以用对象访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> age;  <span class="hljs-comment">//类内声明</span><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<span class="hljs-comment">//外部无法访问</span><br>    <br>&#125;<br>person::age = <span class="hljs-number">10</span>;<span class="hljs-comment">//类外初始化</span><br>person::num =<span class="hljs-number">30</span>;<span class="hljs-comment">//</span><br><br><span class="hljs-built_in">main</span>()&#123;<br>    person p;<br>    p.age = <span class="hljs-number">100</span>;<br>    person::age =<span class="hljs-number">20</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>静态成员函数</p></blockquote><ul><li>全局共享</li><li>只能访问类的静态成员变量</li></ul><h3 id="4-对象模型和this指针"><a href="#4-对象模型和this指针" class="headerlink" title="4. 对象模型和this指针"></a>4. 对象模型和this指针</h3><blockquote><p><strong>成员变量  和  成员函数  是分开存储的</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p) ==&gt;<span class="hljs-number">1</span>;<span class="hljs-comment">//空对象的占用空间是1</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p); ==&gt;<span class="hljs-number">4</span> <span class="hljs-comment">//占用4</span><br><br><span class="hljs-keyword">class</span> person&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> num;<br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p) ==&gt;<span class="hljs-number">4</span>;<span class="hljs-comment">//静态成员不属于对象的</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125; <span class="hljs-comment">//函数也不属于类对象上，只有一份</span><br>&#125;<br>person p;<br><span class="hljs-built_in">sizeof</span>(p) ==&gt;<span class="hljs-number">4</span> ;<span class="hljs-comment">//函数也是单独存储的</span><br></code></pre></td></tr></table></figure><blockquote><p>this指针</p></blockquote><p>每一个非静态成员函数只会诞生一个函数实例，也就是多个同类型的对象会公用同一块代码</p><p>那么这一块代码如何区分哪个对象调用自己的呢？</p><p>通过this指针解决</p><p><strong>this 指针指向的是每一个被调成员函数所属的对象，每一个非静态成员函数都包含this指针</strong></p><p>this指针不需要定义，直接使用</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，用this指针取分</li><li>在类的非静态成员函数返回对象本身，使用return *this;</li></ul><h3 id="5-常函数和常对象"><a href="#5-常函数和常对象" class="headerlink" title="5. 常函数和常对象"></a>5. 常函数和常对象</h3><p><strong>this本质是指针常量—&gt;不能修改指向，可以修改指向的变量的值</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">//这个代表就是常函数--&gt;也就是this现在是一个const person * const p；</span><br><span class="hljs-comment">//无法修改值和指向</span><br><span class="hljs-comment">//但是可以修改类中的mutable修饰的对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;a = <span class="hljs-number">100</span>;  <span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> a;  <span class="hljs-comment">//特殊变量，可以被常函数引用和修改</span><br><span class="hljs-type">int</span> b;<br></code></pre></td></tr></table></figure><blockquote><p>常变量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> person p;  <br>p-&gt;b =<span class="hljs-number">10</span>; <span class="hljs-comment">//错误</span><br>p-&gt;a =<span class="hljs-number">100</span>;<span class="hljs-comment">//可以 常量可以修改mutable修饰的变量</span><br><br>p.<span class="hljs-built_in">func</span>();<span class="hljs-comment">//只能调用常函数</span><br><br></code></pre></td></tr></table></figure><h3 id="6-友元"><a href="#6-友元" class="headerlink" title="6. 友元"></a>6. 友元</h3><blockquote><p>在程序中，有些是私有属性，也想让类外特殊的一些函数或者类进行访问，这就需要友元技术</p><p>即朋友</p><p>【目的】让一个类或者函数访问另一个类的私有成员</p><p>【关键字】 friend</p><p>【用法】在类中加入 friend xxx       xxx表示全局方法或类</p></blockquote><blockquote><p>全局函数做友元</p><p>类做友元</p><p>类成员做友元：要指定哪个类的方法   **friend  void  Person::visit();    **</p></blockquote><h3 id="7-运算符重载"><a href="#7-运算符重载" class="headerlink" title="7. 运算符重载"></a>7. 运算符重载</h3><h4 id="号重载"><a href="#号重载" class="headerlink" title="+号重载"></a>+号重载</h4><blockquote><p>用于两个类相加，普通的+号不适用</p><p>可以在<strong>类中</strong>定义operator+(person &amp;p){…};方法，就可以用+号了，重载了普通+号</p><p>也可以在<strong>全局</strong>定义operator+(person &amp;p，perosn &amp;m){…};</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130105637224.png" alt="image-20221130105637224"></p><blockquote><p>运算符重载，也可以发生函数重载</p></blockquote><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130105857072.png" alt="image-20221130105857072" style="zoom:50%;"><p><strong>operator+()函数重载，参数不同，但是都可以作为+号的重载</strong></p><h4 id="lt-lt-重载"><a href="#lt-lt-重载" class="headerlink" title="&lt;&lt; 重载"></a>&lt;&lt; 重载</h4><blockquote><p>只能利用全局函数重载左移运算符</p></blockquote><p> <img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130111234668.png" alt="image-20221130111234668"></p><h4 id="号重载-1"><a href="#号重载-1" class="headerlink" title="= 号重载"></a>= 号重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> * age;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a)&#123;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(a);<br>    &#125;<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person p)&#123;<br>        <span class="hljs-comment">//浅拷贝 ： this-&gt;age = p.age;</span><br>        <br>        <span class="hljs-comment">//这个就是深拷贝，这堆区中重新new一块内存给这个对象</span><br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[p.age];<br>    &#125;<br>    ~<span class="hljs-built_in">Person</span>()&#123;<br>        <span class="hljs-keyword">if</span>(age !=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> age;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Person p)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;age != <span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> age;<br>        &#125;<br>        <span class="hljs-keyword">this</span>-&gt;age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(p.age);  <span class="hljs-comment">//实现了深拷贝</span><br>    &#125;<br>&#125;<br><br><br>person p1;<br>person p2 = p1; **<span class="hljs-comment">//这也是可以的，这个是调用的拷贝构造的，跟=号没关系**，本质是person p2(p1);</span><br>但是上面的是**拷贝构造导致的浅拷贝**，会出现重复释放内存的问题,所以要重写拷贝构造函数<br>    <br>    <br><span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//如果没有重载 = 号，就会崩掉，因为会导致浅拷贝的重复释放，</span><br><span class="hljs-comment">//如果重载了 = 号，就是将=号变为深拷贝，就会给p2在堆区重新申请空间</span><br>p2 = p1;  <br><span class="hljs-comment">//所以我们要重载 这个=号，使他进行深拷贝</span><br>  <br></code></pre></td></tr></table></figure><blockquote><p>对于那个拷贝构造函数出现的浅拷贝，是在构造的时候给对象赋值用的</p><p>=号是构造完成之后，要发生重新赋值的时候用的，用的地方不同</p></blockquote><h4 id="号重载-2"><a href="#号重载-2" class="headerlink" title="== 号重载"></a>== 号重载</h4><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载 *"></a>函数调用运算符重载 *</h4><p>STL用的比较多–也叫仿函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//实现了()重载，</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string s)</span></span>&#123;<br>            cout &lt;&lt; s &lt;&lt; endl;<br>        &#125;<br>&#125;<br><span class="hljs-built_in">test</span>()&#123;<br>person p;<br>        <span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">//像不像一个函数调用，所以也称作仿函数</span><br>       <span class="hljs-built_in">person</span>(<span class="hljs-string">&quot;hello&quot;</span>);<span class="hljs-comment">//这个叫做匿名对象+（）重载</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-继承"><a href="#8-继承" class="headerlink" title="8. 继承"></a>8. 继承</h3><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><blockquote><p>基本语法</p></blockquote><p>class 子类 ：继承方式 父类</p><p>子类也叫派生类</p><p>父类也叫基类</p><blockquote><p>继承方式</p></blockquote><ul><li>公共继承：到子类中，除了私有属性不可访问，其他的属性权限不变</li><li>保护继承：到子类中，除了私有属性不可访问，其他属性权限都变成protected</li><li>私有继承：到子类中，除了父类的私有属性无法访问，其他属性变成private</li></ul><p><strong>父类的私有成员可以被继承，但是子类自己也无法访问</strong></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130115752687.png" alt="image-20221130115752687"></p><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-type">int</span> A;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> B;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> C;  <span class="hljs-comment">//父类的私有变量会被继承下去，但是无法访问</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> D;<br>&#125;<br><br><span class="hljs-built_in">test</span>()&#123;<br>Son son;<br>    cout&lt;&lt; <span class="hljs-built_in">sizeof</span>(son) &lt;&lt; endl;<span class="hljs-comment">//这个输出是16 </span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在指定的类文件下使用  <code>cl /d1 reportSingleClassLayout类名 文件名</code>可以查看对象模型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221130120844425.png" alt="image-20221130120844425"></p><h4 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，同时会调用父类的构造函数创建父类对象</p><p>【问题】那么父类和子类的构造和析构顺序谁先谁后？</p><p>【答案】<strong>先父类的构造函数，在子类构造函数（从里到外），先子类的析构函数，再父类的析构函数（从外到里）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    Son son;<br>&#125;<br>father 构造函数<br>son 构造函数<br>son 析构函数<br>father 析构函数<br></code></pre></td></tr></table></figure><h4 id="继承中子类父类重名成员"><a href="#继承中子类父类重名成员" class="headerlink" title="继承中子类父类重名成员"></a>继承中子类父类重名成员</h4><blockquote><p>方法重名应该是重写？<strong>如果子类中出现了一个和父类重名的函数，那么会覆盖所有的父类相同函数名重载的函数</strong>，如果想调用，就必须指定作用域</p></blockquote><p>如果没有指定作用域，默认是子类的，如果子类没有，才会父类的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Father</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> A =<span class="hljs-number">20</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Son</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;son 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-type">int</span> A =<span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot; son&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    Son son;<br>    cout &lt;&lt; son.A &lt;&lt;endl; <span class="hljs-comment">//10</span><br>    cout &lt;&lt; son.Father::A &lt;&lt; endl ; <span class="hljs-comment">// 20  指定作用域</span><br>    son.<span class="hljs-built_in">f</span>(); <span class="hljs-comment">// son</span><br>    son.Father::<span class="hljs-built_in">f</span>();<span class="hljs-comment">//father   </span><br>    son.<span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">//错误，如果子类中出现了一个和父类重名的函数，那么会覆盖所有的父类相同函数名重载的函数</span><br>    son.Father::<span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//正确</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="继承中同名静态成员处理方式"><a href="#继承中同名静态成员处理方式" class="headerlink" title="继承中同名静态成员处理方式"></a>继承中同名静态成员处理方式</h4><p>和普通的一样，只是静态的访问方式可以直接类访问</p><blockquote><p><strong>父类中的静态变量和子类中的静态变量不是同一个全局变量</strong></p><p>静态变量只能在同一个类中共享，而不能在父类和子类中共享</p></blockquote><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>利用虚继承解决菱形继承问题</p><h3 id="9-多态"><a href="#9-多态" class="headerlink" title="9. 多态"></a>9. 多态</h3><h4 id="多态概念"><a href="#多态概念" class="headerlink" title="多态概念"></a>多态概念</h4><blockquote><p>多态分类：</p><ul><li>静态多态：函数重载和运算符重载都属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别</p><ul><li>静态多态的函数地址早绑定 - <strong>在编译阶段确定函数地址</strong></li><li>动态多态的函数地址晚绑定 - <strong>在运行阶段确定函数地址</strong></li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;father is eating&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;father&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Father&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;son is eating&quot;</span> &lt;&lt; endl; <br>   &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span></span>&#123;<br>       cout &lt;&lt; <span class="hljs-string">&quot;son&quot;</span> &lt;&lt;endl;<br>   &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Father &amp;f)</span></span>&#123;<br>    f.<span class="hljs-built_in">eat</span>();<br>    f.<span class="hljs-built_in">sing</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>Son s;<br>        <span class="hljs-built_in">test</span>(s);  <span class="hljs-comment">//输出 son is eating 、 father</span><br>    <span class="hljs-comment">//因为eat()是虚函数，在使用的时候才会被动态绑定，对于非虚函数就不行</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类的<strong>虚函数</strong></li></ul><p>多态使用：</p><ul><li><strong>父类指针或者引用指向子类对象</strong></li></ul></blockquote><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Anima</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物说话&quot;</span>  &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Animal == &quot;</span> &lt;&lt;  <span class="hljs-built_in">sizeof</span>(Animal) &lt;&lt; endl;  <span class="hljs-comment">// 1;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>非静态函数是分开存储的</p><p><strong>当加上virtual 就会变成4个字节了</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Anima</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;动物说话&quot;</span>  &lt;&lt; endl;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;sizeof Animal == &quot;</span> &lt;&lt;  <span class="hljs-built_in">sizeof</span>(Animal) &lt;&lt; endl;  <span class="hljs-comment">// 4;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>多态原理</p></blockquote><ul><li>首先只有继承了父类，并重写了父类的虚函数，就可以实现多态的效果</li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221206104124309.png" alt="image-20221206104124309"></p><p>如果一个父类有着虚函数，那么这个类中就会多一个变量 vfptr ,这个变量指向父类自己的虚函数表，</p><p>虚函数表中包含的是自己的虚函数的函数指针（地址）</p><p>如果一个子类继承了父类，那么就会继承这个虚函数表（重新复制一份，不是共享）和vfptr，这个vfptr指向自己的虚函数表，如果重写了父类的虚函数，那么就会将这个虚函数表的对应的父类的虚函数的指针指向自己实现的虚函数。</p><p>具体效果如上图所示。</p><p><strong>虚函数表是每个类都有的，父类和子类都有自己的虚函数表，如果子类继承父类，将父类中的虚函数表中的内容复制到自己的虚函数表中，如果重写了，写自己的虚函数表的地址</strong></p><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类的虚函数的实现往往是无意义的，因为都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>什么是纯虚函数，就是父类中的虚函数没有任何东西，相当于只有一个声明</p><p>语法：<code>virtual 返回值类型 函数名（参数列表） = 0；</code></p><blockquote><p> <strong>那么什么是抽象类呢？</strong></p></blockquote><p>一个类中有了纯虚函数，就是抽象类</p><p>【特点】：</p><ul><li><strong>无法实例化对象</strong></li><li><strong>子类继承后必须重写抽象类中的纯虚函数，否则也属于纯虚函数</strong></li></ul><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Animal</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;animal 构造函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Animal</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;animal 析构函数&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&#123;<br><span class="hljs-keyword">public</span>:<br>    string *s;<br>    <span class="hljs-built_in">Cat</span>(string name)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;cat 构造函数&quot;</span> &lt;&lt; endl;<br>        s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>    &#125;<br>    ~<span class="hljs-built_in">Cat</span>()&#123;<br>        <span class="hljs-keyword">if</span>(s !=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">delete</span> s;<br>            cout &lt;&lt; <span class="hljs-string">&quot;cat 析构函数&quot;</span> &lt;&lt; endl;<br>            s = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; *s &lt;&lt; <span class="hljs-string">&quot;cat speak&quot;</span> &lt;&lt;endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>&#125;;<br>    Animal *a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>    a-&gt;<span class="hljs-built_in">speak</span>();<br>    <span class="hljs-keyword">delete</span> a;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">animal 构造函数<br>cat 构造函数<br>Tom cat speak<br>animal 析构函数<br></code></pre></td></tr></table></figure><blockquote><p>上面说明了父类指针在析构的时候，不会调用子类的析构函数,就会导致子类总如果有堆区属性</p><p>就会出现堆区泄露现象。</p></blockquote><p>【解决方法】</p><ul><li><strong>在父类的析构函数加上virtual关键字，使其变成一个虚函数，这样就可以调用子类的析构函数了</strong></li><li>这样就可以父类指针释放子类对象不干净的问题</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">animal 构造函数<br>cat 构造函数<br>Tom cat speak<br>cat 析构函数<br>animal 析构函数<br></code></pre></td></tr></table></figure><blockquote><p>什么是纯虚析构？</p></blockquote><p>就是父类的虚构函数写成了纯虚函数形式：virtual ~Animal（） = 0；</p><p>但是这个直接运行是有问题的，因为父类中也需要析构函数，解决办法是在类的外面进行实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;<br>Animal::~<span class="hljs-built_in">Animal</span>()&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;纯虚析构&quot;</span> &lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>有点类似于静态变量，类内声明，类外实现</p><h2 id="【文件操作】"><a href="#【文件操作】" class="headerlink" title="【文件操作】"></a>【文件操作】</h2><p><strong>c++ 中文件操作需要包含头文件</strong><fstream></fstream></p><p>文件类型包含两种：</p><ul><li>文本文件 ：文件以文本的ascii码进行存储在计算机中</li><li>二进制文件： 文件以文本的二进制形式存储在计算机中</li></ul><h3 id="1-操作文件的类"><a href="#1-操作文件的类" class="headerlink" title="1. 操作文件的类"></a>1. 操作文件的类</h3><p>操作文件的三大类：</p><ul><li>ofstream ： 写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ul><h3 id="2-文本文件"><a href="#2-文本文件" class="headerlink" title="2. 文本文件"></a>2. 文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>基本步骤</p><ul><li>1.包含头文件 #include<fstream></fstream></li><li>2.创建流对象   ofstream ofs；</li><li>3.打开文件    ofs.open(“文件路径”，打开方式)；</li><li>4.写数据   ofs &lt;&lt; “写入的数据”；</li><li>5.关闭文件  ofs.close();</li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221206120103158.png" alt="image-20221206120103158"></p><p>如果想要多个方法使用，用 | 符号就行</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>基本步骤</p><ul><li>1.包含头文件 #include<fstream></fstream></li><li>2.创建流对象   ifstream ifs；</li><li>3.打开文件    ifs.open(“文件路径”，打开方式)；</li><li>4.读数据   四种方式读取</li><li>5.关闭文件  ifs.close();</li></ul><blockquote><p>读数据的四种方式</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(ifs &gt;&gt; buf)&#123;<br>cout &lt;&lt; buf &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span>(ifs.<span class="hljs-built_in">getline</span>(buf,<span class="hljs-built_in">sizeof</span>(buf)))&#123;<br>    cout &lt;&lt; buf &lt;&lt;endl;<br>&#125;<br><br>string buf;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">getline</span>(ifs,buf))&#123;<br>    cout &lt;&lt; buf &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">char</span> buf;<br><span class="hljs-keyword">while</span>((c = ifs.<span class="hljs-built_in">get</span>()) !=EOF)&#123;<br>    cout &lt;&lt; c &lt;&lt;endl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-二进制文件"><a href="#3-二进制文件" class="headerlink" title="3. 二进制文件"></a>3. 二进制文件</h3><p>以二进制方式对文件进行读写</p><p><strong>打开方式要指定ios::binary;</strong></p><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">64</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ofstream ofs;<br>    ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary);<br>    Person p = &#123;<span class="hljs-number">18</span>,<span class="hljs-string">&quot;张三&quot;</span>&#125;；<br>    ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)&amp;p,<span class="hljs-built_in">sizeof</span>(Person)); <span class="hljs-comment">//将p写入到文件中</span><br>    ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary);<br>    Person p = &#123;<span class="hljs-number">18</span>,<span class="hljs-string">&quot;张三&quot;</span>&#125;;<br>    ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span>*)&amp;p,<span class="hljs-built_in">sizeof</span>(Person)); <span class="hljs-comment">//读进来文件</span><br>    cout &lt;&lt; p.age &lt;&lt; p.name &lt;&lt;endl;<br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="【模板和STL】"><a href="#【模板和STL】" class="headerlink" title="【模板和STL】"></a>【模板和STL】</h2><h3 id="1-泛型编程"><a href="#1-泛型编程" class="headerlink" title="1. 泛型编程"></a>1. 泛型编程</h3><p>c++的一种编程思想就是泛型编程，主要是利用的技术就是模板</p><p>c++提供的两种模板机制：<strong>函数模板</strong>和<strong>类模板</strong></p><h3 id="2-函数模板"><a href="#2-函数模板" class="headerlink" title="2. 函数模板"></a>2. 函数模板</h3><blockquote><p>函数模板的作用</p></blockquote><p>建立一个通用函数，其函数的返回值类型和形参类型都可以不具体指定，用一个<strong>虚拟的类型</strong>来代表</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>函数声明或者定义<br><br><span class="hljs-keyword">template</span> --- 声明这是一个模板<br><span class="hljs-keyword">typename</span> --- 表明后面的符号代表一个数据类型，可以用<span class="hljs-keyword">class</span>代替<span class="hljs-keyword">typename</span><br>T --- 通用数据类型，名称可以替换<br></code></pre></td></tr></table></figure><blockquote><p>举例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myswap</span><span class="hljs-params">( T &amp;a, T &amp;b)</span></span>&#123;<br>    T temp = a;<br>    a = b;<br>    b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">20</span>;<br>    <span class="hljs-comment">//1. 自动类型推导</span><br>    <span class="hljs-comment">// myswap(a,b);</span><br>    <span class="hljs-comment">//2. 显示指定类型</span><br>    <span class="hljs-built_in">myswap</span>&lt;<span class="hljs-type">int</span>&gt; (a,b);<br>    cout &lt;&lt; a &lt;&lt; endl;<br>    cout &lt;&lt; b &lt;&lt; endl;<br><br></code></pre></td></tr></table></figure><blockquote><p>函数模板注意事项</p></blockquote><ul><li><p><strong>自动类型推导，必须推导出一直的类型才能使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> a;<br><span class="hljs-type">char</span> c;<br><span class="hljs-built_in">myswap</span>(a,c);<span class="hljs-comment">//这个就会出错，不能够推导出一致的数据类型</span><br></code></pre></td></tr></table></figure></li><li><p><strong>模板必须要确定出T的数据类型，才可以使用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; endl;  <span class="hljs-comment">//这个函数没有使用到T，但是在函数调用的时候必须也要指定类型</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">f</span>(); <span class="hljs-comment">//错误的</span><br>    <span class="hljs-built_in">f</span>&lt;<span class="hljs-type">int</span>&gt;(); <span class="hljs-comment">//正确</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="函数模板和普通函数的区别"><a href="#函数模板和普通函数的区别" class="headerlink" title="函数模板和普通函数的区别"></a>函数模板和普通函数的区别</h4><ul><li><p>普通函数在调用的时候是可以发生隐士类型转换的</p><ul><li>隐式类型转换有两种，一种是算术类型转换（就是比如int 和 long赋值会发生类型转换），一种是类类型转换（这个就是上面的隐士转换法）</li></ul></li><li><p>函数模板 用自动类型推导，不可以发生隐式类型转换</p></li><li><p>函数模板 用显示指定类型，可以发生隐式类型转换</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//普通函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">myadd1</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-comment">//模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">myadd2</span><span class="hljs-params">(T a,T b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br><span class="hljs-type">int</span> a =<span class="hljs-number">10</span>;<br>         <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>        cout &lt;&lt; <span class="hljs-built_in">myadd1</span>(a,c) &lt;&lt; endl ;<span class="hljs-comment">//这个结果是107，因为字符c被转换成了int，表示97，发生了隐士类型转换</span><br>        cout &lt;&lt; <span class="hljs-built_in">myadd2</span>(a,c) &lt;&lt; endl; <span class="hljs-comment">// 错误，无法发生隐式类型转换，无法推导出一致类型</span><br>        cout &lt;&lt; <span class="hljs-built_in">myadd2</span>&lt;<span class="hljs-type">int</span>&gt;(a,c) &lt;&lt; endl;  <span class="hljs-comment">//正确，可以发生隐式类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>建议使用显示指定类型</strong></p></blockquote><h4 id="普通函数和函数模板的调用规则"><a href="#普通函数和函数模板的调用规则" class="headerlink" title="普通函数和函数模板的调用规则"></a>普通函数和函数模板的调用规则</h4><blockquote><p>问题来源：普通函数名称和函数模板的名称相同，参数个数应该也相同吧</p></blockquote><ul><li>如果函数模板和函数模板都可以调用，那么优先调用普通函数（使用的是自动类型转换方式调用）</li><li>通过空模板参数列表，可以强制调用函数模板</li><li>函数模板间也可以发生重载，和一般重载一个意思，一般参数个数不同</li><li>如果函数模板可以产生更好的匹配，优先调用函数模板 </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;普通函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(T a, T b)</span></span>&#123;       <span class="hljs-comment">//允许同名函数存在，但是如果调用了 int a =9;int b =10; print(a,b);优先走普通函数</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;模板函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> b =<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">print</span>(a,b); <span class="hljs-comment">//优先普通函数</span><br>    <br>    print&lt;&gt;(a,b); <span class="hljs-comment">//这个时候强制调用函数模板</span><br>    <br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;k&#x27;</span>;<br>    <span class="hljs-type">char</span> d = <span class="hljs-string">&#x27;j&#x27;</span>;<br>    <span class="hljs-built_in">print</span>(c,d);<span class="hljs-comment">//这个时候调用函数模板，更好的匹配</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="模板的局限性"><a href="#模板的局限性" class="headerlink" title="模板的局限性"></a>模板的局限性</h4><h3 id="3-类模板"><a href="#3-类模板" class="headerlink" title="3. 类模板"></a>3. 类模板</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote><p>作用：建立一个通用类，类中的成员 数据类型可以不具体制定，用一个虚拟的类型代表</p></blockquote><blockquote><p>语法： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> K,....&gt;<br>类<br></code></pre></td></tr></table></figure></blockquote><p>template  声明创建模板</p><p>typename  表明后面的符号表示虚拟类型</p><p>T 虚拟类型，可以有多个</p><blockquote><p>案例</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    N name;<br>    T age;<br>    <span class="hljs-built_in">person</span>(N n,T t)&#123;<br>        <span class="hljs-keyword">this</span>.name = n;<br>        <span class="hljs-keyword">this</span>.age = t;<br>    &#125;<br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>       cout &lt;&lt; <span class="hljs-keyword">this</span>.name &lt;&lt; endl;<br>       cout &lt;&lt; <span class="hljs-keyword">this</span>.age &lt;&lt; endl;<br>   &#125;<br>&#125;<br><span class="hljs-comment">//使用类模板</span><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;  <br>    p.<span class="hljs-built_in">show</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h4><ul><li>类模板没有自动类型推导的方式</li><li>类模板在模板参数列表中可以有默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类模板没有自动类型推导的方式</span><br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">19</span>)</span></span>;<span class="hljs-comment">//这个是错误的，必须指明类型即person&lt;string,int&gt; p(&quot;hello&quot;,19);才正确</span><br>&#125;<br><span class="hljs-comment">//类模板在模板参数列表中可以有默认参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> = <span class="hljs-type">int</span>&gt; <span class="hljs-comment">//默认后面的那个类型是T，可以不用在创建时指定</span><br><span class="hljs-keyword">class</span> person&#123;<br>    ....<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="类模板中成员函数创建时机"><a href="#类模板中成员函数创建时机" class="headerlink" title="类模板中成员函数创建时机"></a>类模板中成员函数创建时机</h4><blockquote><p><strong>类模板的成员函数在调用的时候才会去创建</strong></p></blockquote> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    T obj;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span></span>&#123;<br>        obj.<span class="hljs-built_in">show1</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span></span>&#123;<br>        obj.<span class="hljs-built_in">show2</span>();<br>&#125;<br>    <span class="hljs-comment">//像上面f1和f2都是在调用的时候才会创建，因为它并不知道obj到底是个什么类型的对象</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板对象做函数参数"><a href="#类模板对象做函数参数" class="headerlink" title="类模板对象做函数参数"></a>类模板对象做函数参数</h4><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式</p><ul><li>指定传入类型   最常用</li><li>参数模板化</li><li>整个类模板化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">N</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    N name;<br>    T age;<br>    <br>    <span class="hljs-built_in">person</span>(N n,T t)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;name = n;<br>        <span class="hljs-keyword">this</span>-&gt;age = t;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;name &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;age&lt;&lt;endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//1. 指定传入类型,模板类作为参数，指定具体的虚拟类型 -------这个最常用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">( person&lt;string,<span class="hljs-type">int</span>&gt; &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-comment">//2. 参数模板化,模板类作为参数，不指定具体的虚拟类型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1,<span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">(person&lt;T1,T2&gt; &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><br><span class="hljs-comment">//3. 将整个类模板化,模板类作为参数，这个就是名副其实的模板函数了</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">(T &amp;p)</span></span>&#123;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    <span class="hljs-comment">//1.</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-built_in">test</span>(p);<br>    <span class="hljs-comment">//2.这个像一个模板函数</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-string">&quot;world&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-built_in">test2</span>(p1); <span class="hljs-comment">//正常输出</span><br>    <span class="hljs-comment">//3. test3就是一个模板函数，然后自动类型推导</span><br>    <span class="hljs-function">person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-string">&quot;he&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-built_in">test3</span>(p2); <span class="hljs-comment">//正常</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h4><blockquote><p>当类模板碰到继承时，需要注意以下几点</p></blockquote><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，需要指出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定父类中的T的类型，子类也需要变为类模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>&#123;<br>    T m;<br>&#125;<br><span class="hljs-comment">//1. 当子类继承的父类是一个类模板时，子类在声明的时候，需要指出父类中T的类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base   <span class="hljs-comment">//这是错误的，没有指定具体类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base&lt;<span class="hljs-type">int</span>&gt; &#123;&#125;<span class="hljs-comment">//这个是正确的</span><br><br><span class="hljs-comment">// 2. 如果想灵活指定父类中的T的类型，子类也需要变为类模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : Base&lt;T2&gt;<br>&#123;<br>    T1 obj;<br>&#125;<br><span class="hljs-built_in">main</span>()&#123;<br>    Son&lt;<span class="hljs-type">int</span>,<span class="hljs-type">char</span>&gt; son;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板成员函数的类外实现"><a href="#类模板成员函数的类外实现" class="headerlink" title="类模板成员函数的类外实现**"></a>类模板成员函数的类外实现**</h4><p>实际中类的声明和成员函数的声明都是在.h文件中，实现在.cpp文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Person</span>&#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T t, K k); <span class="hljs-comment">//类内声明，类外实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br> T t;<br>  K k;<br>&#125;<br><br><span class="hljs-comment">//类外实现，格式一定要正确</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br>Person&lt;T,K&gt;::<span class="hljs-built_in">Person</span>(T t, K k)&#123;  <br>    <span class="hljs-keyword">this</span>-&gt;t = t;<br>    <span class="hljs-keyword">this</span>-&gt;k = k;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br> <span class="hljs-type">void</span> Person&lt;T,K&gt;::<span class="hljs-built_in">show</span>()&#123;<br>     cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;t &lt;&lt; <span class="hljs-keyword">this</span>-&gt;k &lt;&lt; endl;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    p.<span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写**"></a>类模板分文件编写**</h4><p>分文件编写的时候，我们一般把类的声明和类成员函数的声明放在.h文件中</p><p>然后将类的成员函数的实现放到.cpp文件中</p><p>然后在使用的时候包含这个.cpp文件</p><p>在编写类模板的时，一般不分文件，将声明和实现都写到一个文件中，然后将这个文件命名为.hpp文件</p><h4 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h4><blockquote><p>目标：掌握类模板配合友元函数的类内实现和类外实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">//类内实现</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f11</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//全局函数先声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br><span class="hljs-keyword">class</span>  <span class="hljs-title class_">Person</span>&#123;<br>    <span class="hljs-comment">//这个函数是一个全局函数，只不过在类内部声明，并表示是这个类的友元</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">f11</span><span class="hljs-params">(Person&lt;T,K&gt; p)</span></span>&#123;<br>        cout &lt;&lt; p.k &lt;&lt; endl;   <span class="hljs-comment">//可以访问到这个类的私有成员</span><br>    &#125;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(T t, K k); <span class="hljs-comment">//类内声明，类外实现</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br> T t;<br>  K k;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br>Person&lt;T,K&gt;::<span class="hljs-built_in">Person</span>(T t, K k)&#123;<br>    <span class="hljs-keyword">this</span>-&gt;t = t;<br>    <span class="hljs-keyword">this</span>-&gt;k = k;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>,<span class="hljs-keyword">class</span> <span class="hljs-title class_">K</span>&gt;<br> <span class="hljs-type">void</span> Person&lt;T,K&gt;::<span class="hljs-built_in">show</span>()&#123;<br>     cout &lt;&lt;<span class="hljs-keyword">this</span>-&gt;k &lt;&lt; <span class="hljs-keyword">this</span>-&gt;t&lt;&lt; endl;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">Person&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>    p.<span class="hljs-built_in">show</span>();<br>    <span class="hljs-comment">// cout &lt;&lt; p.k &lt;&lt; endl;   //无法访问到私有成员</span><br>    <span class="hljs-built_in">f11</span>(p);<br>    <br>    <br><span class="hljs-comment">//类外实现</span><br> 直接看视频吧<br></code></pre></td></tr></table></figure><h2 id="【STL】"><a href="#【STL】" class="headerlink" title="【STL】"></a>【STL】</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>为了建立数据结构和算法的一套标准，诞生了STL</li><li>STL —  Standard Template Library 标准模板库</li><li>STL 从广义上分为： <strong>容器（container） 算法（algorithm） 迭代器（iterator）</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过迭代器进行无缝连接</li><li>STL几乎所有的代码都采用了模板类或模板函数</li></ul><h4 id="stl六大组件"><a href="#stl六大组件" class="headerlink" title="stl六大组件"></a>stl六大组件</h4><p>STL大体分为六大组件，分别是：容器、算法、迭代器、仿函数、适配器、空间配置器</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113455135.png" alt="image-20221212113455135"></p><h4 id="STL中的容器、算法、迭代器"><a href="#STL中的容器、算法、迭代器" class="headerlink" title="STL中的容器、算法、迭代器"></a>STL中的容器、算法、迭代器</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113532791.pngd" alt="image-20221212113532791"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113554789.png" alt="image-20221212113554789"></p><p>a<img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221212113657711.png" alt="image-20221212113657711"></p><h3 id="2-vector"><a href="#2-vector" class="headerlink" title="2. vector"></a>2. vector</h3><p>  STL中最常用的容器是Vector，可以理解为数组，</p><h4 id="vector存放内置数据类型"><a href="#vector存放内置数据类型" class="headerlink" title="vector存放内置数据类型"></a>vector存放内置数据类型</h4><p>容器： vector</p><p>算法： for_each</p><p>迭代器： vector<int>::iterator</int></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>     <span class="hljs-comment">// 提供vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;alogrithm&gt;</span> <span class="hljs-comment">// 提供for_each()</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myprint</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span></span>&#123;<br>    cout &lt;&lt; val &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 创建一个vector容器对象，通过模板参数指定容器中存放的数据类型</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-comment">// 向容器中添加数据</span><br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    <br>    <span class="hljs-comment">// 每个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span><br>    <span class="hljs-comment">// v.begin() 返回迭代器，这个迭代器指向容器中的第一个元素</span><br>    <span class="hljs-comment">// v.end() 返回迭代器，这个迭代器指向容器中的最后一个元素的下一个位置</span><br>    <span class="hljs-comment">// vector&lt;int&gt;::iterator  拿到vector&lt;int&gt; 这种容器的迭代器类型</span><br>    <br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator begin_m = v.<span class="hljs-built_in">begin</span>();<br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator  end_m = v.<span class="hljs-built_in">end</span>();<br><br>    <span class="hljs-keyword">while</span>(begin_m != end_m)&#123;<br>        cout &lt;&lt; *begin_m &lt;&lt; endl;<br>        begin_m++; <span class="hljs-comment">// 移动迭代器指向容器的下一个位置，迭代器暂时可以理解成指针，操作何指针相似</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>(); it != v.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br>    for_each(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>(),myprint); <span class="hljs-comment">// 这个是提供的遍历算法，myprint用来回调使用的，函数指针</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector存放自定义类型"><a href="#vector存放自定义类型" class="headerlink" title="vector存放自定义类型"></a>vector存放自定义类型</h4>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    string name;<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> age, string name)&#123;<br>               age = age;<br>               name =name;<br>        &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">person  <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;kk&quot;</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;ll&quot;</span>)</span></span>;<br>    <br>    vector&lt;person&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(p1);<br>    v.<span class="hljs-built_in">push_back</span>(p2);<br>    <span class="hljs-keyword">for</span>(vector&lt;person&gt;::iterator it = v.<span class="hljs-built_in">begin</span>()；  it != v.<span class="hljs-built_in">end</span>() ; it++)&#123;<br>        cout &lt;&lt; (*it).age &lt;&lt; (*it).name &lt;&lt; endl;<br>        cout &lt;&lt; it-&gt;age &lt;&lt; it -&gt;name &lt;&lt;endl;  <span class="hljs-comment">// 两种都可以</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>vector数据结构和数组非常相似，也称作单端数组</p><p>区别：</p><p>​    不同之处子啊与数组是静态空间，而vector是动态拓展的</p><blockquote><p><strong>动态拓展</strong></p></blockquote><ul><li><strong>==并不是在原来的空间之后续接新的空间，而是找到更大的空间，然后将原来的数据拷贝过去，释放原来的空间==</strong></li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216221251010.png" alt="image-20221216221251010"></p><h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><p>创建vector容器</p><blockquote><p>函数原型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216221418471.png" alt="image-20221216221418471"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">// vector&lt;int&gt; v2(v.begin(),v.end());</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v)</span></span>;<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it!= v2.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h4><p>给vector容器赋值</p><blockquote><p>函数原型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216222222960.png" alt="image-20221216222222960"> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">// vector&lt;int&gt; v2(v.begin(),v.end());</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; v2 ;<br>    v2.<span class="hljs-built_in">assign</span>(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v2.<span class="hljs-built_in">begin</span>(); it!= v2.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout &lt;&lt; *it &lt;&lt; endl;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h4><p>对vector容器的容量和大小操作</p><blockquote><p>函数原型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216222506798.png" alt="image-20221216222506798"></p><h4 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除*"></a>vector插入和删除*</h4><p>对vector进行插入和删除操作</p><blockquote><p>函数原型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216222845088.png" alt="image-20221216222845088"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">// 2,3,4</span><br><br>    v.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 2,3</span><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">100</span>);<span class="hljs-comment">// 100,2,3</span><br>    v.<span class="hljs-built_in">insert</span>(v.<span class="hljs-built_in">begin</span>(),<span class="hljs-number">2</span>,<span class="hljs-number">1000</span>);<span class="hljs-comment">// 1000,1000,100,2,3</span><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">// 1000,100,2,3</span><br>    v.<span class="hljs-built_in">erase</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<span class="hljs-comment">// 空</span><br></code></pre></td></tr></table></figure><h4 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取**"></a>vector数据存取**</h4><p>对vector中的数据进行存取操作</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216223531305.png" alt="image-20221216223531305"></p><h4 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器**"></a>vector互换容器**</h4><p>实现两个容器内的元素进行互换</p><p>函数原型：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216223731255.png" alt="image-20221216223731255"></p><blockquote><p>基本使用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; v2;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i+<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-comment">// printvector(v);</span><br>    v.<span class="hljs-built_in">swap</span>(v2);<br>    <span class="hljs-built_in">printvector</span>(v);<br></code></pre></td></tr></table></figure><blockquote><p>用处：内存收缩</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216224817021.png" alt="image-20221216224817021"></p><p>vector<int>(v).swap(v); //  vector<int>(v)创建了一个匿名类，相当于vector<int> x = v;x.swap(v);</int></int></int></p><p>因为匿名类使用完就释放了，所以收缩了空间</p><h4 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h4><p>减少vector在动态拓展容量时的拓展次数</p><p>函数原型：</p><p>​    <img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216225104464.png" alt="image-20221216225104464"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; v;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>* p = <span class="hljs-literal">NULL</span>;<br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">100000</span>); <span class="hljs-comment">// 一开始就预留空间</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10000</span>;i++)&#123;<br>        v.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">if</span>(p != &amp;v[<span class="hljs-number">0</span>])&#123;<br>            p = &amp;v[<span class="hljs-number">0</span>];<br>            num++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; num &lt;&lt;endl; <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h3 id="3-string"><a href="#3-string" class="headerlink" title="3. string"></a>3. string</h3><p><strong>string的本质是一个类</strong></p><h4 id="string-和-char-的区别"><a href="#string-和-char-的区别" class="headerlink" title="string 和 char *的区别"></a>string 和 char *的区别</h4><ul><li>char* 是一个指针</li><li>string是一个类，类的内部封装了char*，管理这个字符串，是一个<code>char*</code>型的容器</li></ul><p>特点：</p><p>string类内部封装了很多的成员方法</p><p>例如：查找：find 拷贝copy，删除delete，替换replace 插入insert</p><p>string 管理char*的所分配的内存，不用担心赋值越界和取值越界</p><h4 id="string构造函数"><a href="#string构造函数" class="headerlink" title="string构造函数"></a>string构造函数</h4><p>构造函数原型：</p><ul><li>string()   创建一个空的字符串，例如string str；</li><li>string(const char* s);  使用字符串s进行初始化</li><li>string(const string&amp; str);  使用一个string对象初始化另一个string对象</li><li>string(int n,char c);  使用n个字符c初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    <span class="hljs-type">char</span> * s = <span class="hljs-string">&quot;hello,world&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">str2</span><span class="hljs-params">(s)</span></span>;<br>    cout &lt;&lt; str2 &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">s3</span><span class="hljs-params">(str2)</span></span>;<br>    cout &lt;&lt; s3 &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">s4</span><span class="hljs-params">(<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;t&#x27;</span>)</span></span>;<br>    cout &lt;&lt; s4 &lt;&lt; endl;<br>    <br>    <br>    <span class="hljs-comment">// 输出</span><br>    hello,world<br>     hello,world<br>    tttt<br><br></code></pre></td></tr></table></figure><h4 id="string-赋值操作"><a href="#string-赋值操作" class="headerlink" title="string 赋值操作"></a>string 赋值操作</h4><blockquote><p>功能：给string字符串赋值</p></blockquote><p>赋值的函数原型</p><ul><li>string &amp; operator=(const char* s);   // char*类型字符串 赋值给当前的字符串</li><li>string &amp; operator=(const string &amp;s); // 把字符串付给当前的字符串</li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216211730250.png" alt="image-20221216211730250"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;hello&quot;</span>;<br>    string str2= s;<br>    cout &lt;&lt; str2 &lt;&lt; endl;<br>    string s4;<br>    s4.<span class="hljs-built_in">assign</span>(str);<br>    cout &lt;&lt; s4 &lt;&lt; endl;<br>    string s5;<br>    s5.<span class="hljs-built_in">assign</span>(s,<span class="hljs-number">3</span>);<br>    cout &lt;&lt; s5 &lt;&lt;endl;<br><br>hello<br>hello<br>hello<br>hel<br>   <br></code></pre></td></tr></table></figure><h4 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216213353739.png" alt="image-20221216213353739"></p><p><strong>从上面看出对于+号只能对 字符串或者字符可以，对于数字不行</strong></p><p><code>string&amp; append(cons string&amp; s,int pos,int n)</code>比较重要</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str += <span class="hljs-string">&quot;llll&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;world&quot;</span>;<br>    str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;kkkk&quot;</span>);<br>    str.<span class="hljs-built_in">append</span>(s);<br>    cout &lt;&lt; str &lt;&lt;endl;<br><br>    str.<span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    str.<span class="hljs-built_in">append</span>(s,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>hellollll<br>hellollllkkkkworld <br>hellollllkkkkworldwor<br>hellollllkkkkworldworld<br></code></pre></td></tr></table></figure><h4 id="string查找和替换"><a href="#string查找和替换" class="headerlink" title="string查找和替换"></a>string查找和替换</h4><p>查找：查找指定的字符串是否存在</p><p>替换：在指定的位置替换字符串</p><p>函数原型：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216214319972.png" alt="image-20221216214319972"></p><p><strong>find和rfind其实就是一个从左往右查，一个是从右往左找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">    string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <br>    <span class="hljs-type">int</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;l&quot;</span>);<br>    cout &lt;&lt; pos &lt;&lt; endl;<br><br>    cout &lt;&lt; str.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&quot;l&quot;</span>) &lt;&lt;endl;<br>    cout &lt;&lt; str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;kkkkkk&quot;</span>);<br><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br>hkkkkkklo<br></code></pre></td></tr></table></figure><h4 id="string字符串比较"><a href="#string字符串比较" class="headerlink" title="string字符串比较"></a>string字符串比较</h4><p>字符串之间的比较</p><p>比较方式：</p><ul><li>字符串比较按字符的ASCII码进行比较</li><li>=返回0</li><li><code>&gt;</code>返回1</li><li>&lt; 返回-1</li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216215145684.png" alt="image-20221216215145684"></p><h4 id="string字符存取"><a href="#string字符存取" class="headerlink" title="string字符存取*"></a>string字符存取*</h4><p>string中单个字符存取的方式有两种</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216215318884.png" alt="image-20221216215318884"></p><h4 id="string中的插入和删除"><a href="#string中的插入和删除" class="headerlink" title="string中的插入和删除*"></a>string中的插入和删除*</h4><p>对string字符串进行插入和删除字符操作</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216215736224.png" alt="image-20221216215736224"></p><p>都是从0开始，insert在pos位置开始，不是pos后面一位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;uuu&quot;</span>);<br>    cout &lt;&lt; str &lt;&lt;endl;<br>    str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br>    cout &lt;&lt;str &lt;&lt;endl;<br><br>huuuello<br>hello<br></code></pre></td></tr></table></figure><h4 id="string字串"><a href="#string字串" class="headerlink" title="string字串"></a>string字串</h4><p>从字符串中获取想要的字串</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221216220129777.png" alt="image-20221216220129777"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>    cout &lt;&lt; str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) &lt;&lt;endl;<br>    cout &lt;&lt; str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) &lt;&lt;endl;<br><br>hel<br>el<br>    <br>    string str = <span class="hljs-string">&quot;zhangsan@163.com&quot;</span>;<br>    <span class="hljs-type">int</span> pos = str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;@&quot;</span>);<br>    string s = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,pos);<br>    cout &lt;&lt; s &lt;&lt; endl;  <span class="hljs-comment">// zhangsan</span><br><br></code></pre></td></tr></table></figure><h3 id="4-deque"><a href="#4-deque" class="headerlink" title="4. deque"></a>4. deque</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>双端数组，可以进行头部插入删除操作</p><blockquote><p>deque与vector的区别</p></blockquote><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对于头部的插入删除速度会比vector快</li><li>vector访问元素时的速度比deque快，这和两者的内部实现有关</li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218192027988.png" alt="image-20221218192027988"></p><blockquote><p> 工作原理</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218195031162.png" alt="image-20221218195031162"></p><p>deque容器的迭代器也是支持随机访问的</p><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218195159713.png" alt="image-20221218195159713"></p><h4 id="deque赋值操作"><a href="#deque赋值操作" class="headerlink" title="deque赋值操作"></a>deque赋值操作</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218201440871.png" alt="image-20221218201440871"><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218201533529.png" alt="image-20221218201533529"></p><h4 id="deque大小操作"><a href="#deque大小操作" class="headerlink" title="deque大小操作"></a>deque大小操作</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218201627448.png" alt="image-20221218201627448"></p><h4 id="deque插入和删除"><a href="#deque插入和删除" class="headerlink" title="deque插入和删除"></a>deque插入和删除</h4><p>向deque容器中插入和删除元素</p><blockquote><p>函数原型</p></blockquote><ul><li>两端插入操作<ul><li><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202140955.png" alt="image-20221218202140955"></li></ul></li><li>指定位置插入<ul><li><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202232012.png" alt="image-20221218202232012"></li></ul></li></ul><h4 id="deque数据存取"><a href="#deque数据存取" class="headerlink" title="deque数据存取"></a>deque数据存取</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202831458.png" alt="image-20221218202831458"></p><h4 id="deque排序"><a href="#deque排序" class="headerlink" title="deque排序"></a>deque排序</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218202927241.png" alt="image-20221218202927241"></p><h3 id="5-stack"><a href="#5-stack" class="headerlink" title="5. stack"></a>5. stack</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>stack是一种先进后出的数据结构，他只有一个出口</p><p>栈不允许有遍历行为，但是可以返回他的元素的个数，以及判断它是不是为空</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204259504.png" alt="image-20221218204259504"></p><h4 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204422191.png" alt="image-20221218204422191"></p><h3 id="6-queue"><a href="#6-queue" class="headerlink" title="6. queue"></a>6. queue</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p>queue是一种先进先出的数据结构，他有两个出口</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204719955.png" alt="image-20221218204719955"></p><h4 id="常用接口-1"><a href="#常用接口-1" class="headerlink" title="常用接口"></a>常用接口</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218204810209.png" alt="image-20221218204810209"></p><h3 id="7-list链表"><a href="#7-list链表" class="headerlink" title="7. list链表"></a>7. list链表</h3><h4 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h4><p>功能： 将数据进行链式存储</p><p>链表是一种在物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针进行连接实现的</p><p>链表的组成：链表由一系列节点组成</p><p>结点的组成：一个存储数据元素的数据域，另一个是存储下一个结点地址的指针</p><p><strong>STL中的链表是一个双向循环链表</strong></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218214019740.png" alt="image-20221218214019740"></p><p><strong>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移属于双向迭代器</strong></p><blockquote><p>list优点</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218214311940.png" alt="image-20221218214311940"></p><h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p>创建list容器</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218214444063.png" alt="image-20221218214444063"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">list&lt;<span class="hljs-type">int</span>&gt; l1;<br>    l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    l1.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br>    l1.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-function">list&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l2</span><span class="hljs-params">(l1.begin(),l1.end())</span></span>;<br><br>    <span class="hljs-built_in">printlist</span>(l2);<br>    <br>    list&lt;<span class="hljs-type">int</span>&gt; l3 = l1;<br>    <span class="hljs-built_in">printlist</span>(l3);<br><br><span class="hljs-number">30</span><br><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br><span class="hljs-number">30</span><br><span class="hljs-number">10</span><br><span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h4 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h4><p>功能：</p><p>​    给list容器进行赋值，以及交换list容器</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218215106507.png" alt="image-20221218215106507"></p><h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218215442302.png" alt="image-20221218215442302"></p><h4 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218215750154.png" alt="image-20221218215750154"></p><p><strong>这个里面的pos都是迭代器，不是下标，并且list的迭代器不是随机访问的，只能前移和后移</strong></p><h4 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218220225643.png" alt="image-20221218220225643"></p><h4 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218220529979.png" alt="image-20221218220529979"></p><p>这个反转和排序都是list的成员函数，不是alogrithm中的sort，那个sort是只支持随机访问的迭代器的</p><p>sort默认是进行升序排列，如果想要进行降序排列</p><p>可以自定义一个函数，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mycompare</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><br>list&lt;<span class="hljs-type">int</span>&gt; l;<br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>l.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>l.<span class="hljs-built_in">sort</span>(mycompare); <span class="hljs-comment">// 20,10,就是他会调用我们这个函数，按照返回ture的规则进行排序，a代表老数据，b代表新数据</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218222821430.png" alt="image-20221218222821430"></p><p><strong>这个就是双重排序了</strong></p><h3 id="8-set-mutiset"><a href="#8-set-mutiset" class="headerlink" title="8. set / mutiset"></a>8. set / mutiset</h3><h4 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>对于set来说，所有的元素在插入的时候会被排序，并且set中不会有重复的元素</li></ul><blockquote><p>set本质</p></blockquote><ul><li>set/mutiset 是属于关联式容器，底层采用的是二叉树结构</li></ul><p>set和mutiset区别</p><ul><li>set不允许有重复的元素存在</li><li>mutiset允许有重复的元素存在</li></ul><h4 id="set构造函数和赋值"><a href="#set构造函数和赋值" class="headerlink" title="set构造函数和赋值"></a>set构造函数和赋值</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223330515.png" alt="image-20221218223330515"></p><h4 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223640356.png" alt="image-20221218223640356"></p><h4 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除**"></a>set插入和删除**</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223732001.png" alt="image-20221218223732001"></p><h4 id="set的查找和统计"><a href="#set的查找和统计" class="headerlink" title="set的查找和统计**"></a>set的查找和统计**</h4><p>功能：</p><p>​    对set容器进行查找数据和统计数据</p><p>函数原型</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218223917311.png" alt="image-20221218223917311"></p><p><strong>这个count因为set中不能存在相同的元素，所以可以使用count进行判断这个元素是否存在在这个set中</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">set&lt;<span class="hljs-type">int</span>&gt; myset;<br>myset.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>mysert.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br><br>set&lt;<span class="hljs-type">int</span>&gt;::iterator it = myset.<span class="hljs-built_in">find</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 返回这个set中的20对应的这个迭代器</span><br></code></pre></td></tr></table></figure><h4 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建**"></a>pair对组创建**</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218224910618.png" alt="image-20221218224910618"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">pair&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;k&quot;</span>,<span class="hljs-number">20</span>)</span></span>;<br>pair&lt;string,<span class="hljs-type">int</span>&gt; p1 = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-number">10</span>);<br><br>cout &lt;&lt; p.first &lt;&lt; p.second&lt;&lt;endl ;<span class="hljs-comment">// k , 20</span><br></code></pre></td></tr></table></figure><h4 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h4><p>目标：</p><p>​    set排序默认从小到大，掌握如何改变排序规则</p><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><blockquote><p>示例一：排序内置类型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218225819941.png" alt="image-20221218225819941"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218225913020.png" alt="image-20221218225913020"></p><blockquote><p>自定义类型排序</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20221218230102049.png" alt="image-20221218230102049"></p><h3 id="9-map"><a href="#9-map" class="headerlink" title="9. map"></a>9. map</h3><h2 id="【多线程】"><a href="#【多线程】" class="headerlink" title="【多线程】"></a>【多线程】</h2><p>==<a href="https://juejin.cn/post/7140448119104143373#heading-22">参考博客</a>==</p><p><a href="https://juejin.cn/post/7071030029659930632">https://juejin.cn/post/7071030029659930632</a></p><h3 id="c-线程同步"><a href="#c-线程同步" class="headerlink" title="c++ 线程同步"></a>c++ 线程同步</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p><strong>解决多线程数据混乱的方案就是进行线程同步，最常用的是互斥锁 ，在C++11 中提供了四种互斥锁：</strong></p><ol><li><code>std::mutex</code> : 独占的互斥锁，不能递归使用；</li><li><code>std::timed_mutex:</code> 带超时的独占互斥锁，不能递归使用；</li><li><code>std::recursive_mutex:</code> 递归互斥锁，不带超时功能；</li><li><code>std::recursive_timed_mutex :</code> 带超时的递归互斥锁；</li></ol><blockquote><p>mutex</p></blockquote><p>独占互斥锁提供了lock和unlock两个api，用来获得锁和释放锁</p><p><strong>使用互斥锁进行线程同步的流程：</strong></p><ol><li>找到多个线程操作的共享资源<code>（全局变量、堆内存、类成员变量）</code>，成为<strong>临界资源</strong> ；</li><li>找到共享资源相关的上下文代码，即<strong>临界区</strong></li><li>再临界区的上边调用互斥锁类的 <code>lock()</code> 方法；</li><li>再临界区的下边调用互斥锁类的 <code>unlock()</code> 方法；</li></ol><p>==线程同步的目的：==<code>使多线程按照顺序依次进行执行临界区代码，对共享资源的访问从并行访问变成线性访问，访问效率降低了但是保证了数据的正确性；</code></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/55643e30bcfb4c0381644f697778af3ctplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp" alt="互斥锁.png"></p><h4 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h4><p><code>lock_guard</code> 是C++11新增的一个模板类，可以==简化互斥锁 <code>lock()</code> 和 <code>unlock()</code> 的写法==，同时也更安全；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span>&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span>;<br><span class="hljs-comment">//常用构造</span><br><span class="hljs-function">eplicit <span class="hljs-title">lock_guard</span><span class="hljs-params">(mutex_type&amp; m)</span></span>;<br></code></pre></td></tr></table></figure><p><code>lock_guard</code> 在使用上面的构造函数构造对象时，<strong>会自动锁定互斥量</strong>，且在退出作用域后进行析构就会自动解锁，以保证互斥量的正确性，避免忘记 <code>unlock()</code> 而导致的线程死锁。</p><h4 id="条件变量-condition-variable"><a href="#条件变量-condition-variable" class="headerlink" title="条件变量 condition_variable"></a>条件变量 condition_variable</h4><p>C++11 提供了另一种用于等待的同步机制，能阻塞一个或多个线程，直到收到另一个线程发出的通知或超时时，才能唤醒当前阻塞的线程。<strong>条件变量需要和互斥量配合使用。</strong></p><p><code>condition_variable:</code> 配合 <code>std::unique_lock&lt;std::mutex&gt;</code> 进行 wait 操作，也就是阻塞线程的操作；</p><p><code>conditon_variable_any</code> : 可以和任意带有 <code>lock() 、unlock()</code>语义的 <code>mutex</code> 搭配使用，即存在四种：</p><ol><li><code>std::mutex :</code> 独占的非递归互斥锁；</li><li><code>std::timed_mutex:</code> 带超时的独占非递归锁；</li><li><code>std::recursive_mutex:</code> 不带超时功能的递归互斥锁；</li><li><code>std::recursive_timed_mutex:</code> 带超时的递归互斥锁；</li></ol><p><code>conditon_variable</code> 的成员函数主要分为两部分：<code>线程等待(阻塞)函数</code> 和 <code>线程通知(唤醒)函数</code> ，定义在头文件 <code>&lt;condition_variable&gt;</code>中</p><h5 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h5><p>wait方法是，由一个condition_variable变量来调用，其作用是，释放这个线程获取的锁lck.unlock()，然后进入阻塞状态，由别的线程通过相同的cv对象来唤醒自己重新去获取锁和判断条件是否继续阻塞。</p><p>当这个wait被唤醒之后，会调用lck.lock()重新上锁，然后wait退出，可以理解为lck的状态变换和wait函数的调用和退出是同时的</p><p>wait有两个重载版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当前线程的执行会被阻塞，直到收到 notify 为止。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck)</span></span>;<br><br><span class="hljs-comment">// 当前线程仅在pred=false时阻塞；如果pred=true时，不阻塞。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Predicate</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span> <span class="hljs-params">(unique_lock&lt;mutex&gt;&amp; lck, Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Unblocks当前正在等待此条件的一个线程。</span><br><span class="hljs-comment">// 如果没有线程在等待，则函数不执行任何操作。</span><br><span class="hljs-comment">// 如果有多个线程在等待，它不会指定具体哪个线程。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_one</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-comment">// Unblocks当前等待此条件的所有线程。</span><br><span class="hljs-comment">// 如果没有线程在等待，则函数不执行任何操作。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify_all</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br><br></code></pre></td></tr></table></figure><p>notify是用来唤醒某个阻塞的线程，没有操作这个锁（没有释放锁这一说）</p><h5 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h5><p>我们上面提到很多次虚假唤醒，这里详细解释一下。其实在正常情况下，wait类型函数返回时要不是因为被唤醒，要不是因为超时才返回，但是在实际中发现，因此操作系统的原因，wait类型在不满足条件时，它也会返回，这就导致了虚假唤醒。因此，我们一般都是使用带有谓词参数的wait函数，因为这种(xxx, Predicate pred )类型的函数等价于：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">pred</span>()) <span class="hljs-comment">//while循环，解决了虚假唤醒的问题</span><br>&#123;<br>    <span class="hljs-built_in">wait</span>(lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>假设系统不存在虚假唤醒的时，代码只要像下面这样写就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (不满足条件) &#123;<br>    <span class="hljs-comment">//没有虚假唤醒，wait函数可以一直等待，直到被唤醒或者超时，没有问题。</span><br>    <span class="hljs-comment">//但实际中却存在虚假唤醒，导致假设不成立，wait不会持续等待，会跳出if语句，</span><br>    <span class="hljs-comment">//提前执行其他代码，流程异常</span><br>    <span class="hljs-built_in">wait</span>();  <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">但因为存在虚假唤醒，所以，正确的方式应该是使用<span class="hljs-keyword">while</span>语句来解决：<br><br><span class="hljs-keyword">while</span> (!(xxx条件) ) &#123;<br>    <span class="hljs-comment">//虚假唤醒发生，由于while循环，再次检查条件是否满足，</span><br>    <span class="hljs-comment">//否则继续等待，解决虚假唤醒</span><br>    <span class="hljs-built_in">wait</span>();  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++ 内存管理"></a>C++ 内存管理</h1><h2 id="new-表达式"><a href="#new-表达式" class="headerlink" title="new 表达式"></a>new 表达式</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210113822159.png" alt="image-20230210113822159"></p><blockquote><p>new 表达式原理</p><ol><li>通过operator new 去malloc空间</li><li>使用构造函数在申请的空间上构造对象</li></ol></blockquote><p>底层调用的是operator new ，更底层是调用的malloc，我们再try中可以看到，new一个对象，首先是调用operator new去申请一块内存，然后通过编译器调用类的构造函数去构造这个对象，但是应用程序不能直接通过类调用构造函数，但是可以通过placement new，这个placement new就是在p指向的空间上调用构造函数去构造对象。</p><blockquote><p>new失败的时候调用的是callnewh(size)，这个函数就是new handler</p></blockquote><h2 id="delete-表达式"><a href="#delete-表达式" class="headerlink" title="delete 表达式"></a>delete 表达式</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210114710089.png" alt="image-20230210114710089"></p><blockquote><p>delete 表达式</p><ol><li>先析构对象</li><li>再释放空间</li></ol></blockquote><p>底层调用的是operator delete，底层再调用的是free函数，</p><p>析构函数可以直接调用，和构造函数不同</p><h2 id="构造和析构函数直接调用"><a href="#构造和析构函数直接调用" class="headerlink" title="构造和析构函数直接调用"></a>构造和析构函数直接调用</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210115032146.png" alt="image-20230210115032146"></p><p>构造函数不可以通过指针直接调用（可以通过placement new），但是析构函数可以通过指针直接调用</p><h2 id="array-new，-array-delete"><a href="#array-new，-array-delete" class="headerlink" title="array new， array delete"></a>array new， array delete</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210125754369.png" alt="image-20230210125754369"></p><p>在分配内存的时候，会给内存的多分配一些内存用来存储这个空间的长度等信息</p><p>当我们使用array new时，在释放内存的时候一般都是使用delete[]来释放，这个会逐个来析构每个对象，如果只是delete，那么就只会析构一个对象，并且导致内存泄漏，但是如果析构函数没有意义的话，其实可以不用delete[]</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210130108264.png" alt="image-20230210130108264"></p><blockquote><p>array new时，一般调用的是默认构造函数，这就会导致对象不能够对成员对象赋值操作，所以可以采用placement new 再次调用构造函数来进行成员对象的赋值</p></blockquote><blockquote><p>array size in memory</p></blockquote><p>使用new 的话就在堆空间中，不使用new 在stack中</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210131136064.png" alt="image-20230210131136064"></p><p>这个使用delete pi是因为没有析构函数，无关紧要的，直接释放</p><p>当如果是object的，就如下</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210131241480.png" alt="image-20230210131241480"></p><p>在内存中会多记录一个长度的数，并且基本一定要写delete[] p ，但是如果这个demo类中的析构函数无关紧要的，那么就会不记录这个长度数值，因为析构没啥意义，这个长度也是为析构时准备的</p><h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><blockquote><p>在已经分配的内存上构造对象而已</p><p>原理其实也是调用了operator new 只不过调用的是另一个重载的版本，源代码如下</p><p>这个operator new(sizeof(Complex),buf){</p><p>return buf //直接返回了这个地址，也就是省区了重新malloc的步骤，因为这个重载的版本就是为了能够调用类的构造函数而已</p><p>}</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210131900415.png" alt="image-20230210131900415"></p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="c-内存分配的途径"><a href="#c-内存分配的途径" class="headerlink" title="c++内存分配的途径"></a>c++内存分配的途径</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210133553299.png" alt="image-20230210133553299"></p><p>进行new 的时候，先调用operator new去申请空间，也就是调用malloc申请空间，然后再调用类的构造函数来进行构造对象</p><p>释放的时候，就先调用析构函数析构对象，然后调用operator delete去释放空间</p><blockquote><p>我们可以对这个operator new 和operator delete 进行重载，自己定义如何分配空间和释放空间动作，在stl中有体现</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210133903406.png" alt="image-20230210133903406"></p><h3 id="重载operator-new-和operator-delete"><a href="#重载operator-new-和operator-delete" class="headerlink" title="重载operator new 和operator delete"></a>重载operator new 和operator delete</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210134015838.png" alt="image-20230210134015838"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210134048191.png" alt="image-20230210134048191"></p><h3 id="重载实例"><a href="#重载实例" class="headerlink" title="重载实例"></a>重载实例</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140311502.png" alt="image-20230210140311502"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140351138.png" alt="image-20230210140351138"></p><h3 id="重载new（）-delete（）"><a href="#重载new（）-delete（）" class="headerlink" title="重载new（）/delete（）"></a>重载new（）/delete（）</h3><blockquote><p>new() 其实在我们的讲的那个placement new就是其中的一个，我们也可以进行重载operator new</p><p>使用new的时候一定会调用operator new，所以我们还是重载的operator new，</p><p>【记住】operator new 的第一个参数一定是object的大小，后面才是具体的参数</p></blockquote><blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140711652.png" alt="image-20230210140711652"></p><p>只有在operator new出现异常的时候我们才会调用这个operator delete</p></blockquote><h3 id="basic-string使用new（extra）扩充申请量"><a href="#basic-string使用new（extra）扩充申请量" class="headerlink" title="basic_string使用new（extra）扩充申请量"></a>basic_string使用new（extra）扩充申请量</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210140913511.png" alt="image-20230210140913511"></p><h2 id="per-class-allocator"><a href="#per-class-allocator" class="headerlink" title="per-class allocator"></a>per-class allocator</h2><blockquote><p>总共有三个版本，具体直接看ppt吧，代码很详细，就是每个类一下子多申请一些空间，省去cookie的占用率</p></blockquote><h2 id="new-handler"><a href="#new-handler" class="headerlink" title="new handler"></a>new handler</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210152056181.png" alt="image-20230210152056181"></p><blockquote><p>当分配内存失败后，我们会先调用一个自己的new_handler()函数，这个函数自己写的</p><p>然后就会一致循环的调用malloc和调用new handler（）函数</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210152316273.png" alt="image-20230210152316273"></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="vc6下的malloc内存布局"><a href="#vc6下的malloc内存布局" class="headerlink" title="vc6下的malloc内存布局"></a>vc6下的malloc内存布局</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210153058161.png" alt="image-20230210153058161"></p><p>两头有着相同的cookie，然后申请的大小必须是16的倍数，pad指向的区间就是保证16的倍数</p><h3 id="G2-9分配器"><a href="#G2-9分配器" class="headerlink" title="G2.9分配器"></a>G2.9分配器</h3><h4 id="std-alloc-运行模式"><a href="#std-alloc-运行模式" class="headerlink" title="std::alloc 运行模式"></a>std::alloc 运行模式</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230210201021058.png" alt="image-20230210201021058"></p><blockquote><p>std::allocator 是一个内存分配器，它自己维护了一个长度16的链表，这个链表是静态变量，所以头部一直存在，但是指向的真正内存是从堆中申请的，这个分配器在分配内存的时候6也是调用的malloc，只不过他每次申请的内存比较大，然后将多余的内存维护在自己的链表中，然后剩余的内存当下次分配时不用从malloc获取了</p></blockquote><blockquote><p>这个意义在于是消除了cookie，速度对于malloc并没有提升很多</p></blockquote><h2 id="malloc-和-free"><a href="#malloc-和-free" class="headerlink" title="malloc 和 free"></a>malloc 和 free</h2><h1 id="C-对象"><a href="#C-对象" class="headerlink" title="C++对象"></a>C++对象</h1><h2 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h2><p>一般建议是采用引用传递，因为引用传递更加的快，建议传参数和返回值使用引用，但是有些情况是不能用引用的，就是在函数内部创建的对象，离开了这个函数之后，这个变量就没了，所以应该进行值传递，不能引用传递。</p><h3 id="拷贝构造、拷贝赋值"><a href="#拷贝构造、拷贝赋值" class="headerlink" title="拷贝构造、拷贝赋值"></a>拷贝构造、拷贝赋值</h3><blockquote><p>string 内部有一个指针，这个指针指向的内容就是我们的真正的字符串</p><p>对于含有指针的类来说，一般要自己定义拷贝构造函数等（<strong>避免出现浅拷贝现象</strong>）</p></blockquote><blockquote><p>三个特殊函数：拷贝构造（进行深拷贝），拷贝赋值（其实就是重载=号），析构函数</p><p>temp a =c; 这个其实调用的是拷贝构造</p><p>temp a;</p><p>a =c;这个才调用的是拷贝赋值</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211204314635.png" alt="image-20230211204314635"></p><blockquote><p>深拷贝和浅拷贝区别就是一个拷贝的是整个对象的内容，一个只是拷贝了指针而已</p></blockquote><p>比如有一个类，他有一个指针成员变量，现在有一个对象，这个对象的指针指向了一块内存，然后调用拷贝构造去创建一个新的对象，如果我们没有自己定义自己的拷贝构造函数，那么就会由编译器给我们提供一个默认的拷贝构造函数，但是这个拷贝构造函数仅仅是将旧对象的值赋值给了新对象的值，结果就是新对象的这个指针现在和旧对象的指针内容一样（也就是指向了同一块内存）那么这个就是浅拷贝，当其中一个对象的指针去改变指针指向的内容时，就会影响两个对象，所以我们应该是写自己的拷贝构造函数，进行深拷贝，也就是重新申请一块空间，将旧对象指针指向的内容给拷贝到新申请的空间中去，然后将新对象的指针指向这个空间，这个就是深拷贝。</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211210029676.png" alt="image-20230211210029676"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211210122874.png" alt="image-20230211210122874"></p><blockquote><p>拷贝赋值</p></blockquote><p> 基本步骤就是：要有自我检测，因为没有自我检查，会改变这个内存的位置，然后清空自己之前的内容和内存，然后重新申请一块和要赋值的内容的大小空间，然后再赋值到新空间去</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211210522829.png" alt="image-20230211210522829"></p><blockquote><p>析构函数</p></blockquote><p>对于含有指针成员的对象，一定要定义析构函数，因为要析构掉指针指向的内容</p><h2 id="new-和delete搭配"><a href="#new-和delete搭配" class="headerlink" title="new 和delete搭配"></a>new 和delete搭配</h2><p>new 会被编译器编译成operator new（）–这个是去申请空间的，然后再调用构造函数在申请的空间上进行构造对象</p><p>delete会被编译器编译成先调用析构函数，然后再调用operator delete 去释放内存</p><p>使用new 的时候要搭配delete使用，防止内存泄漏</p><p>new[] 也要搭配delete[] 使用，如果使用delete，就会只会释放一个对象内存，并且对于含有指针成员的对象，会导致内存泄漏，泄漏的是指针指向的内容，不是对象自己。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态函数和静态成员，都是只有一份的，如果在一个类中定义一个静态函数，那么这个函数就不会包含这个this指针，所以他只能调用这个类的静态成员变量，无法像普通的函数那样，当调用自己的成员函数的时候，就会将自己的this指针传进去，这样就可以使用自己的成员对象。</p><h2 id="static版本的单例"><a href="#static版本的单例" class="headerlink" title="static版本的单例"></a>static版本的单例</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230211225601849.png" alt="image-20230211225601849"></p><h2 id="继承、虚函数、多态"><a href="#继承、虚函数、多态" class="headerlink" title="继承、虚函数、多态"></a>继承、虚函数、多态</h2><p><strong>base class 的dtor必须是virtual，否则会出现undefined behavior</strong></p><p>在继承中，成员变量可以被继承下来，成员函数也可以被继承下来，但是从内存的角度来说，应该是继承的函数的调用权</p><blockquote><p>虚函数</p></blockquote><ul><li>non-virtual ： 你不希望derived class（派生类）去重新定义（override，覆写重写）它</li><li>virtual函数： 你希望derived class 重新定义（override）它，而且你对这个函数有了一个默认的定义了</li><li>pure virtual 函数 ： 你希望你的子类<strong>一定要重新定义它</strong>，因为你对这个函数没有任何定义</li></ul><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230212152602042.png" alt="image-20230212152602042"></p><blockquote><p>虚函数本质</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/format,png.png" alt="img"></p><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><blockquote><p>为什么要有智能指针</p></blockquote><p>我们在动态分配内存时候，有时候忘记释放内存，导致内存泄漏，还有就是我们提前释放了内存，导致指针指向非法内存</p><p>为了更容易的使用动态内存，出现了智能指针来管理动态对象</p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p><a href="https://www.cnblogs.com/QG-whz/p/4777312.html"><strong>参考博客–智能指针shared_ptr的原理实现</strong></a></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230213135345916.png" alt="image-20230213135345916"></p><blockquote><p>允许多个指针指向同一个对象；</p></blockquote><p><strong>智能指针都共享一个计数器（也就是shared_ptr包含一个计数器的指针），和一个指向对象的指针</strong></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5Yqq5Yqb5a2m5Lmg55qE5bCR5bm0,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr拥有它指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个对象</p><blockquote><p>unique_ptr没有拷贝构造和拷贝赋值，但是它可以调用release()和reset将指针的控制权从一个unique_ptr转给另一个unique_ptr</p></blockquote><h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p><a href="https://www.cnblogs.com/QG-whz/p/4909359.html"><strong>参考博客–对象内存布局</strong></a></p><p><a href="https://cloud.tencent.com/developer/article/1755489"><strong>clang编译器下的对象模型</strong></a></p><h3 id="c-对象模型"><a href="#c-对象模型" class="headerlink" title="c++对象模型"></a>c++对象模型</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMTA4ODk=,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMwMTA4ODk=,size_16,color_FFFFFF,t_70-16765569750365.png" alt="img"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3oxNTAwNTk1MzAzMQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025195611333-359739251.png" alt="img"></p><ul><li>在此模型下，nonstaic数据成员被置于每一个类对象中，而static数据成员被至于类对象之外</li><li>static和nonstatic的函数也是置于对象之外，而对于virtual函数，则是通过虚函数表+虚函数指针来支持</li><li>每一个带有虚函数的类，都会生成一个表格，叫做虚表。<strong>虚表中存放着一堆指针，这些指针指向该类每一个虚函数。</strong>虚表中的函数地址将按声明时的顺序排列，不过当子类有多个重载函数时例外，后面会讨论。</li><li>每个类对象都有一个虚表指针（vtpr），由编译器生成，虚表指针的设定与重置皆由类的复制控制（即时构造函数，析构函数，赋值操作符）来完成。vptr的位置为编译器决定，传统上它被放在所有显示声明的成员之后，<strong>不过现在许多编译器把vptr放在一个类对象的最前端。</strong>关于数据成员布局的内容，在后面会详细分析。</li></ul><p><strong>另外，虚函数表的前面设置了一个指向type_info的指针，用以支持RTTI（Run Time Type Identification，运行时类型识别）。RTTI是为多态而生成的信息，包括对象继承关系，对象本身的描述等，只有具有虚函数的对象在会生成。</strong></p><h3 id="单继承下的对象模型"><a href="#单继承下的对象模型" class="headerlink" title="单继承下的对象模型"></a>单继承下的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derive</span>(<span class="hljs-type">int</span> d) :<span class="hljs-built_in">Base</span>(<span class="hljs-number">1000</span>),      <span class="hljs-built_in">DeriveI</span>(d)&#123;&#125;;<br>    <span class="hljs-comment">//overwrite父类虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive::Drive_print()&quot;</span> ; &#125;<br>    <span class="hljs-comment">// Derive声明的新的虚函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Drive_print</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive::Drive_print()&quot;</span> ; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Derive</span>()&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> DeriveI;<br>&#125;;<br><br></code></pre></td></tr></table></figure><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230217171455506.png" alt="image-20230217171455506" style="zoom:50%;"><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200700974-1784981192.png" alt="img"></p><p>在C++对象模型中，对于一般继承（这个一般是相对于虚拟继承而言），</p><p>若子类重写（overwrite）了父类的虚函数，则子类虚函数将覆盖虚表中对应的父类虚函数(<strong>注意子类与父类拥有各自的一个虚函数表</strong>)；</p><p>若子类并无overwrite父类虚函数，而是声明了自己新的虚函数，则该虚函数地址将扩充到虚函数表最后（在vs中无法通过监视看到扩充的结果，不过我们通过取地址的方法可以做到，子类新的虚函数确实在父类子物体的虚函数表末端）。</p><p>而对于虚继承，若子类overwrite父类虚函数，同样地将覆盖父类子物体中的虚函数表对应位置，而若子类声明了自己新的虚函数，则编译器将为子类增加一个新的虚表指针vptr，这与一般继承不同,在后面再讨论。</p><h3 id="多继承下的对象模型"><a href="#多继承下的对象模型" class="headerlink" title="多继承下的对象模型"></a>多继承下的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">baseI</span>(i)&#123;&#125;;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>()&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> baseI; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">countI</span><span class="hljs-params">()</span></span>&#123;&#125;;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base::print()&quot;</span>; &#125;<br> <br><span class="hljs-keyword">private</span>:<br> <br>    <span class="hljs-type">int</span> baseI;<br> <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> baseS;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base_2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base_2</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">base2I</span>(i)&#123;&#125;;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base_2</span>()&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">return</span> base2I; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">countI</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base_2::print()&quot;</span>; &#125;<br> <br><span class="hljs-keyword">private</span>:<br> <br>    <span class="hljs-type">int</span> base2I;<br> <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> base2S;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive_multyBase</span> :<span class="hljs-keyword">public</span> Base, <span class="hljs-keyword">public</span> Base_2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">Drive_multyBase</span>(<span class="hljs-type">int</span> d) :<span class="hljs-built_in">Base</span>(<span class="hljs-number">1000</span>), <span class="hljs-built_in">Base_2</span>(<span class="hljs-number">2000</span>) ,<span class="hljs-built_in">Drive_multyBaseI</span>(d)&#123;&#125;;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive_multyBase::print&quot;</span> ; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Drive_print</span><span class="hljs-params">()</span></span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Drive_multyBase::Drive_print&quot;</span> ; &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Drive_multyBaseI;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200614927-1378567718.png" alt="img"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200604380-2000558778.png" alt="img"></p><p>单继承中（一般继承），子类会扩展父类的虚函数表。在多继承中，子类含有多个父类的子对象，该往哪个父类的虚函数表扩展呢？当子类overwrite了父类的函数，需要覆盖多个父类的虚函数表吗？</p><ul><li>子类的虚函数被放在声明的第一个基类的虚函数表中。</li><li><strong>overwrite时，所有基类的print()函数都被子类的print()函数覆盖</strong>。（这里是有两个虚函数表吗？）</li><li>内存布局中，父类按照其声明顺序排列。</li></ul><p>其中第二点保证了父类指针指向子类对象时，总是能够调用到真正的函数。</p><p><strong>子类继承了两个父类，会把父类的两个虚函数表都复制过来，重写会覆盖所有同时出现在两个父类中的函数，如果自己有新的虚函数，会在第一个父类复制过来的虚函数表中扩加。</strong>，子类中的成员变量的布局也是根据继承时声明的顺序来的。</p><h3 id="菱形继承下的对象模型"><a href="#菱形继承下的对象模型" class="headerlink" title="菱形继承下的对象模型"></a>菱形继承下的对象模型</h3><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200532099-858573066.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> ib;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>) :<span class="hljs-built_in">ib</span>(i)&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Bf</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::Bf()&quot;</span> &lt;&lt; endl; &#125;<br> <br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span> : <span class="hljs-keyword">public</span> B<br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> ib1;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">B1</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">100</span> ) :<span class="hljs-built_in">ib1</span>(i) &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B1::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B1::f1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Bf1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B1::Bf1()&quot;</span> &lt;&lt; endl; &#125;<br> <br> <br> <br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span> : <span class="hljs-keyword">public</span> B<br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> ib2;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">B2</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1000</span>) :<span class="hljs-built_in">ib2</span>(i) &#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B2::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B2::f2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Bf2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B2::Bf2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>&#125;;<br> <br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B1, <span class="hljs-keyword">public</span> B2<br> <br>&#123;<br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-type">int</span> id;<br> <br> <br> <br><span class="hljs-keyword">public</span>:<br> <br>    <span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">10000</span>) :<span class="hljs-built_in">id</span>(i)&#123;&#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::f()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::f1()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::f2()&quot;</span> &lt;&lt; endl; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Df</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;D::Df()&quot;</span> &lt;&lt; endl; &#125;<br> <br>&#125;;<br><br></code></pre></td></tr></table></figure><p>这时，根据单继承，我们可以分析出B1，B2类继承于B类时的内存布局。又根据一般多继承，我们可以分析出D类的内存布局。我们可以得出D类子对象的内存布局如下图：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200514692-1054547262.png" alt="img"></p><p>D类对象内存布局中，图中青色表示b1类子对象实例，黄色表示b2类子对象实例，灰色表示D类子对象实例。从图中可以看到，由于D类间接继承了B类两次，导致D类对象中含有两个B类的数据成员ib，一个属于来源B1类，一个来源B2类。这样不仅增大了空间，更重要的是引起了程序歧义：</p><blockquote><p>问题描述：我们其实可以看作是一个多继承，因为对于D来说就是多继承，但是因为B1和B2都是继承的B，所以导致了D中有两个成员变量B::ib,这就会导致重复继承，在调用的时候出现歧义</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">D d;<br> <br>d.ib =<span class="hljs-number">1</span> ;               <span class="hljs-comment">//二义性错误,调用的是B1的ib还是B2的ib？</span><br> <br>d.B1::ib = <span class="hljs-number">1</span>;           <span class="hljs-comment">//正确</span><br> <br>d.B2::ib = <span class="hljs-number">1</span>;           <span class="hljs-comment">//正确</span><br><br></code></pre></td></tr></table></figure><p><strong>尽管我们可以通过明确指明调用路径以消除二义性</strong>，但二义性的潜在性还没有消除，我们可以通过虚继承来使D类只拥有一个ib实体。</p><p>我们会用虚继承来解决这个问题</p><h3 id="虚继承下的对象模型"><a href="#虚继承下的对象模型" class="headerlink" title="虚继承下的对象模型"></a>虚继承下的对象模型</h3><h4 id="虚继承作用"><a href="#虚继承作用" class="headerlink" title="虚继承作用"></a>虚继承作用</h4><p>虚继承解决了菱形继承中最派生类拥有多个间接父类实例的情况。虚继承的派生类的内存布局与普通继承很多不同，主要体现在：</p><ul><li><strong>虚继承的子类，如果本身定义了新的虚函数，则编译器为其生成一个虚函数指针（vptr）以及一张虚函数表。该vptr位于对象内存最前面。</strong><ul><li><strong>vs非虚继承：直接扩展父类虚函数表。</strong></li></ul></li><li><strong>虚继承的子类也单独保留了父类的vprt与虚函数表。这部分内容接与子类内容以一个四字节的0来分界。</strong></li><li>虚继承的子类对象中，含有四字节的虚表指针偏移值。</li></ul><p>为了分析最后的菱形继承，我们还是先从单虚继承继承开始。</p><h4 id="虚基类表解析"><a href="#虚基类表解析" class="headerlink" title="虚基类表解析"></a>虚基类表解析</h4><p>在C++对象模型中，虚继承而来的子类会生成一个隐藏的虚基类指针（vbptr），在Microsoft Visual C++中，<strong>虚基类表指针总是在虚函数表指针之后</strong>，因而，对某个类实例来说，如果它有虚基类指针，那么虚基类指针可能在实例的0字节偏移处（该类没有vptr时，vbptr就处于类实例内存布局的最前面，否则vptr处于类实例内存布局的最前面），也可能在类实例的4字节偏移处。<br>一个类的虚基类指针指向的虚基类表，与虚函数表一样，虚基类表也由多个条目组成，条目中存放的是<strong>偏移值</strong>。第一个条目存放虚基类表指针（vbptr）所在地址到该类内存首地址的偏移值，由第一段的分析我们知道，这个偏移值为0（类没有vptr）或者-4（类有虚函数，此时有vptr）。我们通过一张图来更好地理解。</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200459817-94705070.png" alt="img"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200451380-675544058.png" alt="img"></p><p>虚基类表的第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值，这点我们在下面会验证。</p><h4 id="简单虚继承"><a href="#简单虚继承" class="headerlink" title="简单虚继承"></a>简单虚继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类的内容与前面相同</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> B<br><br><br></code></pre></td></tr></table></figure><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230217215955888.png" alt="image-20230217215955888" style="zoom:50%;"><p>根据我们前面对虚继承的派生类的内存布局的分析，B1类的对象模型应该是这样的：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200421083-639353686.png" alt="img"></p><blockquote><p>第二、第三…个条目依次为该类的最左虚继承父类、次左虚继承父类…的内存地址相对于虚基类表指针的偏移值。</p></blockquote><p><strong>在我们的例子中，也就是B类实例内存地址相对于vbptr的偏移值，也即是：[4]-[1]的偏移值，结果即为12，从地址上也可以计算出来：007CFDFC-007CFDF4结果的十进制数正是12。现在，我们对虚基类表的构成应该有了一个更好的理解。</strong></p><h4 id="虚拟菱形继承"><a href="#虚拟菱形继承" class="headerlink" title="虚拟菱形继承"></a>虚拟菱形继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B1</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span>  B&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B2</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span>  B&#123;...&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span> : <span class="hljs-keyword">public</span> B1,<span class="hljs-keyword">public</span> B2&#123;...&#125; <span class="hljs-comment">// 这个就是普通的多继承 </span><br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200354427-697488742.png" alt="img"></p><p>菱形虚拟继承下，最派生类D类的对象模型又有不同的构成了。在D类对象的内存构成上，有以下几点：</p><ul><li>在D类对象内存中，基类出现的顺序是：先是B1（最左父类），然后是B2（次左父类），最后是B（虚祖父类）</li><li>D类对象的数据成员id放在B类前面，两部分数据依旧以0来分隔。</li><li>编译器没有为D类生成一个它自己的vptr，而是覆盖并扩展了最左父类的虚基类表，与简单继承的对象模型相同。</li><li>超类B的内容放到了D类对象内存布局的最后。</li></ul><p>菱形虚拟继承下的C++对象模型为：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200237724-1193009551.png" alt="img"></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/610439-20151025200219192-322378663.png" alt="img"></p><h3 id="继承中构造和析构调用顺序"><a href="#继承中构造和析构调用顺序" class="headerlink" title="继承中构造和析构调用顺序"></a>继承中构造和析构调用顺序</h3><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/7b8a3c3bbe924eacafb8ab424ecc68fe.png" alt="img"></p><h1 id="C-effective"><a href="#C-effective" class="headerlink" title="C++ effective"></a>C++ effective</h1><h2 id="04-确定对象被使用前已经被初始化"><a href="#04-确定对象被使用前已经被初始化" class="headerlink" title="04. 确定对象被使用前已经被初始化"></a>04. 确定对象被使用前已经被初始化</h2><ul><li>为内置对象进行手工初始化（int,long,char..）</li><li>构造函数做好使用成员初值列，而不要在构造函数本体内使用赋值操作。初始化的顺序是根据你在类中的声明顺序，而不是你成员初值列的初始化顺序，尽量抱持一致。<ul><li>如果是在构造函数内的赋值相当于先调用default 构造函数，再对对象进行赋值</li><li>而使用成员初值列则是直接采用copy构造函数进行初始化，效率更高</li></ul></li><li>为免除”跨编译单元之初始化次序“，请以localstatic对象替换non-local static对象，因为定义在函数内的local static对象，在调用函数的时候，一定回发生初始化。</li></ul><h2 id="05-了解c-默默编写并调用了哪些函数"><a href="#05-了解c-默默编写并调用了哪些函数" class="headerlink" title="05. 了解c++默默编写并调用了哪些函数"></a>05. 了解c++默默编写并调用了哪些函数</h2><p>几乎你写的每一个class都会有一个或者多个构造函数、一个析构函数、一个copy assignment操作符。</p><p>如果你定义了一个空类，里面什么都没有</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><p>那么在编译期间，编译器会给你默认的生成一个copy构造函数、一个copy assignment操作符、一个析构函数、一个default 构造函数,<strong>这些函数都是public 和inline的</strong>。</p><p>就相当于下面：<strong>但是只有在这些函数被调用的时候才会被创建出来</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Empty</span>()&#123;&#125;;<br>    <span class="hljs-built_in">Empty</span>(<span class="hljs-type">const</span> Empty&amp; temp)&#123;&#125;;<br>    ~<span class="hljs-built_in">Empty</span>()&#123;&#125;;<br>    Empty&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Empty&amp; temp)&#123;&#125;;<br>&#125; /<br></code></pre></td></tr></table></figure><blockquote><p>有的时候编译器会拒绝编译一些operator=，比如一个类中的成员是一个引用和const常量，当发生copy assignment时，相当于将引用的指向更改，这是不允许的，并且const常量也不允许更改，所以这个时候不能生成这个operator=，但是可以生产copy构造函数，因为copy构造函数只在初始化被调用，引用和常量都可以在初始化赋值</p></blockquote><h2 id="07-为多态基类声明virtual析构函数"><a href="#07-为多态基类声明virtual析构函数" class="headerlink" title="07. 为多态基类声明virtual析构函数"></a>07. 为多态基类声明virtual析构函数</h2><p>首先我们要清楚子类继承父类的时候，当创建子类对象的时候，构造函数顺序和析构函数顺序</p><p>对于构造函数，先调用父类的构造函数，在调用子类的构造函数内容，</p><p>对于析构函数，先调用子类的析构函数，然后调用父类的析构函数</p><blockquote><p>如果没有在子类中定义自己的copy 构造，那么会生成一个调用父类拷贝构造函数的自己的拷贝构造函数。（无论父类的构造函数是自己定义的还是由编译器生成的，只要子类没有定义，就会在编译器合成时调用它）</p><p><strong>如果自己在子类中定义了自己的拷贝构造函数，那么在进行调用子类的copy构造函数时会调用父类的默认构造函数。都是调用默认构造函数</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-built_in">person</span>()&#123;<br>        cout&lt;&lt; <span class="hljs-string">&quot;调用了person()&quot;</span>&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt;endl;;<br>    &#125;<br>     ~<span class="hljs-built_in">person</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了~person----&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ming</span>: <span class="hljs-keyword">public</span> person&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ming</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了ming()&quot;</span> &lt;&lt;endl;<br>    &#125;<br>    ~<span class="hljs-built_in">ming</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了~ming&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ming* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ming</span>();<span class="hljs-comment">//只有将析构函数声明为virtual的，才能通过父类的指针调用子类的析构函数（就是将虚函数表的父类虚析构函数给覆盖了），实现全部析构（子类的析构函数无论如何都会调用父类的析构函数的）</span><br>    <span class="hljs-keyword">delete</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">调用了<span class="hljs-built_in">person</span>()<br>调用了<span class="hljs-built_in">ming</span>()<br>调用了~ming<br>调用了~person----<br></code></pre></td></tr></table></figure><p>这个在子类的构造函数和析构函数中，编译器都会生成父类的构造函数和析构函数，无论析构函数是不是virtual类型的。</p><blockquote><p><strong>将父类的析构函数声明为virtual类型的作用：通过父类指针析构掉子类对象</strong></p></blockquote><p>例如我们使用父类的指针指向了子类的对象，但是在析构的时候，我们只会通过父类指针调用到父类的析构函数，而无法调用子类的析构函数（子类的析构函数自己拥有，所以无法通过父类的指针找到），这样就导致”局部销毁“的现象，就是将父类的内容给析构掉了，但是子类自己的内容没有析构掉。</p><p>如果我们将父类的析构函数定义为virtual就会生成一个虚函数表，子类的析构函数就会覆盖虚函数表中的父类的虚析构函数，这样当父类指针指向之类对象时，因为会通过vptr找到虚函数表，然后找到子类的析构函数，这样就完成了对子类对象的析构（子类的析构函数里调用了父类的析构函数）。</p><h2 id="09-不要在析构函数和构造函数中调用虚函数"><a href="#09-不要在析构函数和构造函数中调用虚函数" class="headerlink" title="09. 不要在析构函数和构造函数中调用虚函数"></a>09. 不要在析构函数和构造函数中调用虚函数</h2><p>因为在继承关系中，当我们构造子类对象时，我们调用的时父类构造再子类构造，如果在父类构造函数中调用了虚函数，那么此时调用的函数是属于父类的，而不是属于子类的，因为子类还没有构建呢，当调用父类构造时此时其实是一个父类对象，只有在后面调用了子类构造时才会转变成子类对象。</p><h2 id="13-以对象管理资源"><a href="#13-以对象管理资源" class="headerlink" title="13. 以对象管理资源"></a>13. 以对象管理资源</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f1</span>()&#123;<br>    Person * p =<span class="hljs-built_in">PersonFactory</span>(); <span class="hljs-comment">// 通过工厂模式获得一个对象</span><br>   ......<span class="hljs-comment">//中间经过了一些步骤，有可能直接return或者异常离开了这个函数</span><br>   <span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 就无法执行这个语句，导致内存泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解决方法：以对象管理资源</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">f1</span>()&#123;<br>    shared_ptr&lt;person&gt; p =<span class="hljs-built_in">PersonFactory</span>(); <span class="hljs-comment">// 通过工厂模式获得一个对象</span><br>   ......<span class="hljs-comment">//中间经过了一些步骤，有可能直接return或者异常离开了这个函数</span><br>&#125;<br><span class="hljs-comment">// 当离开这个函数的时候，智能指针p会在自己的析构函数内调用delete去释放创建的person对象</span><br><span class="hljs-comment">// 以shared_ptr 这个对象来管理资源</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：但是shared_ptr只能调用delete，不能调用delete[],所以不要用智能指针管理数组</p></blockquote><blockquote><p>总结：为防止内存泄漏，请使用RAII对象，他们在构造函数中获取资源，并在析构函数中释放资源</p></blockquote><h2 id="16-成对使用new和delete时采用相同形式"><a href="#16-成对使用new和delete时采用相同形式" class="headerlink" title="16. 成对使用new和delete时采用相同形式"></a>16. 成对使用new和delete时采用相同形式</h2><p>如果在new中使用了[]，那么在相应的delete表达式中也是用[]，如果你没有new数组，就不要delete数组</p><p>因为在delete的时候，会先拿到数组头部的数组长度N，然后根据这个n进行逐个析构，如果你对单一对象使用delete[]，那么就有可能发生额外的析构。</p><h2 id="17-以独立语句将newed对象置入智能指针"><a href="#17-以独立语句将newed对象置入智能指针" class="headerlink" title="17. 以独立语句将newed对象置入智能指针"></a>17. 以独立语句将newed对象置入智能指针</h2><p><strong>这是为了防止内存泄漏，虽然我们使用RAII就是为了防止泄漏，但是由于一些原因，我们还是会导致内存泄漏，所以说不是使用了智能指针就一定不会发生泄漏</strong></p><p>比如在一个函数的参数是，</p><p>void processWidget(std::tr1::shared_ptr<Widget> pw,int priority);</Widget></p><p>当我们这样使用时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">procesWidget</span>(std::tr1:<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Widget</span>()),<span class="hljs-built_in">priority</span>());<br>在调用这个方法之前，编译器会创建代码，做以下三件事：<br>    调用priority<br>    执行<span class="hljs-keyword">new</span><br>    调用智能指针的构造函数<br>那么<span class="hljs-keyword">new</span>和构造函数的调用顺序肯定抱持一前一后，但是priority有可能在<span class="hljs-keyword">new</span>执行之后执行，如果发生意外，就会导致内存泄漏，因为还没有将创建的对象指针赋予智能指针<br><br></code></pre></td></tr></table></figure><h2 id="20-宁以pass-py-reference-to-const-替换pass-by-value"><a href="#20-宁以pass-py-reference-to-const-替换pass-by-value" class="headerlink" title="20. 宁以pass-py-reference-to-const 替换pass-by-value"></a>20. 宁以pass-py-reference-to-const 替换pass-by-value</h2><p><strong>除非你另外指定，函数的参数都是以实际实参的复件为初值，而调用端所获得的也是函数返回值的一个复件。这些复件都是由对象的copy构造函数产出的，这可能使得pass-by-value称为费时的操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span>&#123;<br>    <span class="hljs-built_in">person</span>();<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">person</span>();<br><span class="hljs-keyword">private</span>:<br>    string name;<br>    string address;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> : <span class="hljs-keyword">public</span> person&#123;<br> <span class="hljs-keyword">private</span>:<br>    string schoolname;<br>    string schooladdress;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isvalidate</span><span class="hljs-params">(student s)</span></span>;<br>student s;<br><span class="hljs-type">bool</span> flag = <span class="hljs-built_in">isvalidate</span>(s);<br></code></pre></td></tr></table></figure><p>当调用函数时，会发生什么事情，我们可以看到这个是值传递，所以相当于调用了子类的copy构造函数，那么就会先调用父类的copy构造函数（如果子类定义了自己的copy构造，则默认调用父类的无参构造），再调用子类的copy构造函数（因为函数参数的student，如果是perosn不调用），然后再调用内部的成员的构造函数，析构函数也是一样。</p><blockquote><p>总结：尽量使用pass-by-reference-to-const，高效，且不会发生切割问题</p><p>但是对于内置类型和STL的迭代器以及函数对象是采用值传递的。</p></blockquote><h2 id="21-必须返回对象时，别返回引用"><a href="#21-必须返回对象时，别返回引用" class="headerlink" title="21. 必须返回对象时，别返回引用"></a>21. 必须返回对象时，别返回引用</h2><p>因为一个local 变量在出了作用域之后会被销毁，那么此时引用就会指向非法地址</p><blockquote><p>总结：绝不要返回一个引用指向一个local stack 对象，可以返回一个指向heap的对象，或者指向一个local static对象</p></blockquote><h2 id="22-将成员变量设置为private"><a href="#22-将成员变量设置为private" class="headerlink" title="22. 将成员变量设置为private"></a>22. 将成员变量设置为private</h2><p>减少由于成员变量更改而导致的代码破坏量，比如一个public的变量名字修改了，那么很多使用这个变量的代码都要修改，因此使用封装最好（private，提供setter和getter）</p><h2 id="27-尽量少做转型"><a href="#27-尽量少做转型" class="headerlink" title="27. 尽量少做转型"></a>27. 尽量少做转型</h2><h3 id="c-新特性–-四种转型"><a href="#c-新特性–-四种转型" class="headerlink" title="c++新特性– 四种转型"></a>c++新特性– 四种转型</h3><p>const_cast<T>(expression)</T></p><p>dynamic_cast<T>(expression)</T></p><p>static_cast<T>(expression)</T></p><p>reinterpret_cast<T>(expression)</T></p><blockquote><p>基本概念：</p></blockquote><ul><li><p>const_cast<T>(expression):它是将cont类型转换成non-const类型</T></p></li><li><p>dynamic_cast<T>(expression)：主要用来执行“安全向下转型”，也就是用来决定某对象是否归属于继承体系中的某个类型。成本较高</T></p><p> 只能用于含有虚函数的类转换，用于类向上和向下转换</p><p>​      <strong>向上转换：</strong>指子类向基类转换。  </p><p>​      <strong>向下转换：</strong>指基类向子类转换。</p><p>​      这两种转换，子类包含父类，当父类转换成子类时可能出现非法内存访问的问题。</p><p>  dynamic_cast通过判断变量运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。dynamic_cast可以做类之间上下转换，转换的时候会进行类型检查，类型相等成功转换，类型不等转换失败。运用RTTI技术，RTTI是”Runtime Type Information”的缩写，意思是运行时类型信息，它提供了运行时确定对象类型的方法。在c++层面主要体现在dynamic_cast和typeid，vs中虚函数表的-1位置存放了指向type_info的指针，对于存在虚函数的类型，dynamic_cast和typeid都会去查询type_info。</p></li><li><p>reinterpret_cast<T>(expression)：  reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。</T></p></li><li><p>static_cast<T>(expression): 最常用的转型方式，它可以用于任何的隐式转换，比如non-const转成const（不能反过来，只有const_cast有那个功能），也可以用于向上转换，但是向下转换不安全</T></p></li></ul><h1 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h1><p>参考博客： <a href="https://www.cnblogs.com/skynet/p/3343726.html">https://www.cnblogs.com/skynet/p/3343726.html</a></p><h2 id="需要多少内存才能够表现一个object"><a href="#需要多少内存才能够表现一个object" class="headerlink" title="需要多少内存才能够表现一个object"></a>需要多少内存才能够表现一个object</h2><p>一般而言：</p><ul><li><p>其nonstatic data members</p></li><li><p>加上任何由于alignment（译注）的需求而填补（padding）上去的空间（可能存在members之间，也可能存在集合体边界）</p><blockquote><p>译注：alignment就是将数值调整到某数的倍数。在32位计算机上，通常alignment为4字节，以使bus的“运输量”达到最高效率</p></blockquote></li><li><p>加上为了支持virtual而由内部产生的任何额外负担</p></li></ul><blockquote><p>关于多态下的父类指针指向子类对象，以及将子类对象赋值给父类发生什么事情</p></blockquote><ul><li>通过父类的指针指向子类的对象，就可以实现多态的现象，但是父类的指针只能调用子类public继承的父类的内容，关于子类自己独有的member，无法使用父类的指针调用，我们可以将这个指针转换成子类的指针，就可以调用了</li><li>如果将子类的对象赋值给一个父类对象，就会出现“切割问题”，也就是子类会被切割塞入到较小的父类的base type内存中，对于派生类没有留下任何一个东西。（<strong>虚函数表依然是父类自己的虚函数表</strong>），因此这个多态也就没有了。</li></ul><h2 id="Default-Constructor的生成的四种情况"><a href="#Default-Constructor的生成的四种情况" class="headerlink" title="Default Constructor的生成的四种情况"></a>Default Constructor的生成的四种情况</h2><blockquote><p>如果一个类定义了其中一个构造函数，那么编译器就不会帮你构建任何一个构造函数了，所以如果子类</p></blockquote><p>【参考博客】<a href="https://imzlp.com/posts/7666/">https://imzlp.com/posts/7666/</a></p><p>什么时候才会合成一个default constructor呢？当编译器需要它的时候才会合成构造函数</p><p>1.“带有Default Constructor”的Member Class Object（<strong>如果这个成员对象没有默认构造函数，也不会合成</strong>）</p><blockquote><p>结论： 如果一个class<strong>没有任何constructor</strong>,但是它包含一个member object，<strong>并且</strong>后者有default constructor，编译器才会给这个class合成一个构造函数，并且这个构造函数只有在调用的时候才会合成</p></blockquote><blockquote><p>如果我们定义了构造函数，但是内部有很多的member object ，那么这个class就会在自己的每一个constructor内调用每一个member object 的default constructor来初始化这个object</p><p>这个就是编译器的扩张。</p></blockquote><p>2.“带有Default Constructor”的Base class</p><p>如果一个类派生自一个带有默认构造函数的base class，然后自己没有任何一个构造函数，那么编译器就会给这个class生成一个默认构造函数，</p><p><strong>如果这个派生类有自己的构造函数，那么编译器就会扩张这个构造函数，调用父类的默认构造函数（父类的默认构造函数也有可能是编译器生成 的）</strong></p><p>3.“带有一个virtual function”的class</p><p>有两个扩张行为会在编译期间发生：</p><ol><li>一个 virtual function table (虚函数表) 会被编译器生成出来，内放 Class 的 virtual function 的地址 (函数指针的地址)</li><li>每一个 Class Object 中有一个额外的 Pointer Member (也就是 vptr) 会被编译器生成出来，内放指向下虚函数表的指针。</li></ol><p>对象 b 中包含了</p><ul><li><p>一个 Base 的完整对象：数据成员 x 和 Base 的 virtual function table，其中具有一个指向 Derived::func () 的指针</p></li><li><p>一个在 b 中定义的 Data Member (数据成员) z。</p></li></ul><p>假如我们使用 b 对象来调用 func：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">b.func()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>1.则该代码可以正确执行的前提是，<strong>编译器必须为对象 b 的 vptr 设定初始值</strong>，放置适当的 virtual Table 地址，<strong>对于类所定义的每一个的构造函数，编译器都会安插一些必要的代码来实现这个行为</strong>。</p><p>2.对于那些没有声明任何构造函数的类，编译器会为他们合成一个默认构造函数，以便正确的初始化每一个类对象的 vptr。</p><p>4.“带有一个virtual Base Class”的class</p><p>因为牵扯到这个菱形继承的问题，要有一个指针指向这个Base，所以子类在构造函数中要扩张构建这个变量。</p><p>有构造函数就扩展，没有就合成。</p><blockquote><p>总结：如果没有上面四种情况，就不会给他合成一个默认的构造函数</p><p>在合成的默认构造函数中，只有base class subobjects和member class会被初始化，而其他的nonstatic data member（整数、整数指针、整数数组等），因为这些初始化是对程序员需要的，而对于编译器不需要。</p></blockquote><p>所以：不是所有类都会生成默认构造函数，编译器合成的默认构造函数也不是会对class中的每一个成员初始化。</p><h2 id="Copy-Constructor的构造操作"><a href="#Copy-Constructor的构造操作" class="headerlink" title="Copy Constructor的构造操作"></a>Copy Constructor的构造操作</h2><p>copy构造函数即使显示定义了default 构造函数也会被编译器合成（在需要的时候）</p><blockquote><p>Bitwise Copy Semantics 位逐次拷贝</p></blockquote><p>如果一个class没有定义explicit copy constructor，那么是否会有一个编译器合成的实例别调用？</p><p><strong>这就取决于这个class是否展现了”bitwise copy semantics“ 而定了</strong>，下面的就是没有展示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()&#123;<br><br>    &#125;<br>    <span class="hljs-built_in">Derived</span>(string&amp; d)&#123;<br>        j = d;<br>        cout &lt;&lt; <span class="hljs-string">&quot;执行了&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;B::func()&quot;</span> &lt;&lt; endl; &#125;<br>    string j;<br><span class="hljs-type">int</span> z;<br>    <span class="hljs-type">int</span> t;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>这种情况下，编译器必须合成一个copy constructor，目的是为了调用string j的copy 构造函数，值得注意的一点是，在合成的copy构造函数中，是对所有的成员变量进行复制，如下。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Drived</span>(Drived&amp; d)&#123;<br>    j.string::<span class="hljs-built_in">string</span>(d.j);<br>    z = d.z;<br>    t = d.t;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>**什么时候不展现了”bitwise copy semantics“ **，分以下四种情况</p></blockquote><ol><li><p>当class内含有一个member object而后者的class声明一个copy constructor（这个可以是自己声明的，也可以是编译器生成的）</p></li><li><p>当class继承自一个base class，并且这个base存在一个copy constructor（可以是自己定义，也可以是编译器生成的）</p></li><li><p>当class声明了一个或者多个virtual function</p><blockquote><p>Drived d;</p><p>Drived f(d);这个会调用派生类的copy构造函数，然后会在派生类的构造函数调用父类的copy构造（子类的copy是编译器生成的）</p><p>在派生类中，有一个vptr，会直接复制过去</p><p>但是如果下面这种：</p><p>Base b(d);</p><p>这个就会发生切割问题，就是子类的成员被切割掉了，然后其他的会直接复制过去吗，包括这个vptr？</p><p>答案是vptr会有编译器生成的copy构造函数自己生成，然后其他的变量拷贝过去。</p></blockquote></li><li></li></ol><h2 id="程序装换"><a href="#程序装换" class="headerlink" title="程序装换"></a>程序装换</h2><h3 id="参数初始化"><a href="#参数初始化" class="headerlink" title="参数初始化"></a>参数初始化</h3><p>X xx；</p><p>foo(X xx);</p><p>编译器如何实现这个foo(X xx)函数的，首先它会生成一个临时变量，然后对这个临时变量进行copy构造，然后改写函数调用的操作，以便使用上述的临时对象,如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">X temp0<br>temp0.X::<span class="hljs-built_in">X</span>(xx);<br><span class="hljs-built_in">foo</span>(temp0);<br></code></pre></td></tr></table></figure><p>但是上面只做的一部分工作，在这个foo的声明上，此时要变成void foo(X&amp; xx)</p><h3 id="返回值的初始化"><a href="#返回值的初始化" class="headerlink" title="返回值的初始化"></a>返回值的初始化</h3><p>X foo();</p><p>X X = Foo();</p><p>更改函数的参数多一个返回值类型的引用，然后在return前执行这个参数的copy构造函数</p><p>别更改成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">( foo&amp; result )</span></span>&#123;<br>    X xx;<br>    xx.X::<span class="hljs-built_in">X</span>();<br>    <br>    result.X::<span class="hljs-built_in">X</span>(xx);<span class="hljs-comment">// 编译器产生的copy 构造操作</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br>因此上面的两句变成：<br>    X xx;<br>  <span class="hljs-built_in">foo</span>(xx);<br></code></pre></td></tr></table></figure><h2 id="Copy构造要还是不要"><a href="#Copy构造要还是不要" class="headerlink" title="Copy构造要还是不要"></a>Copy构造要还是不要</h2><h2 id="成员的初始化队伍"><a href="#成员的初始化队伍" class="headerlink" title="成员的初始化队伍"></a>成员的初始化队伍</h2><p>一般我们采用在构造函数后面通过<code>:</code>这个符号接着调用成员对象的构造函数进行直接初始化，而不是在这个构造函数体内采用赋值的方式进行初始化，这样就会先调用成员变量的默认构造函数，然后创建一个临时对象，然后再将临时对象赋值给成员变量操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">如果对word类的name初始化以赋值方式，编译器就会生成如下<br>    name.String::<span class="hljs-built_in">String</span>(); 先调用默认构造函数<br>    string temp = string（“hellop”）；生成临时对象<br>    name.string::<span class="hljs-keyword">operator</span>=(temp);<br>    temp.string::~<span class="hljs-built_in">string</span>();析构掉<br></code></pre></td></tr></table></figure><p>所以编译器扩充之后代码量较大，效率不高。</p><h2 id="内存对象布局-重要"><a href="#内存对象布局-重要" class="headerlink" title="内存对象布局(重要)"></a>内存对象布局(重要)</h2><h3 id="有用的命令"><a href="#有用的命令" class="headerlink" title="有用的命令"></a>有用的命令</h3><p><code>g++ -fdump-lang-class XXX.cpp</code> 这个命令可以生成对象的内存结构</p><p><code>objdump -S xxxx</code> 可以生成反汇编文件</p><p><code>c++filt xxxx</code> 可以查看汇编文件中的字符对应c++中的内容</p><p><code>size a.out</code> 查看一个文件的各个段的大小以及占用的磁盘空间</p><p><code>readelf -S a.out </code>查看可执行文件的段表</p><h3 id="内存对齐和字节对齐"><a href="#内存对齐和字节对齐" class="headerlink" title="内存对齐和字节对齐"></a>内存对齐和字节对齐</h3><h3 id="c-程序如何如何存储的"><a href="#c-程序如何如何存储的" class="headerlink" title="c++程序如何如何存储的"></a>c++程序如何如何存储的</h3><p>一般情况下，一个C可执行程序在内存中主要包含5个区域，分别是：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aWU6LeR55qE5qmY5a2Q,size_18,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li>.text 代码段</li><li>.bss </li><li>.data</li><li>heap</li><li>stack</li></ul><ol><li>.text :他就是存放程序指令的地方，只读</li><li>.bss： 用来存放未初始化的全局变量或者静态变量，编译器全给初始化0</li><li>.data：用来存放已经初始化的全局变量或者静态变量以及常量数据</li><li>stack：存放函数调用相关的参数、局部变量的值，以及任务切换时的上下文环境。栈区是由操作系统进行操作和管理的区域</li><li>heap：动态内存分配区域，也就是molloc申请的内存区，使用free进行释放，堆内存的申请和管理全部由程序员来控制，容易发生内存泄漏。</li></ol><blockquote><p>【注意】：对于.bss在文件中是不体现出来的，不占用文件大小，<a href="https://blog.csdn.net/qq_39748622/article/details/125991569">https://blog.csdn.net/qq_39748622/article/details/125991569</a></p></blockquote><h3 id="Data-member布局"><a href="#Data-member布局" class="headerlink" title="Data member布局"></a>Data member布局</h3><p>目前各家编译器都是把一个以上的access sections 连锁在一起，依照声明的顺序，连接成一个区块</p><h3 id="Data-member的存取"><a href="#Data-member的存取" class="headerlink" title="Data member的存取"></a>Data member的存取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point3d origin<br>Point3d *pt = &amp;origin<br><br>   origin.x = <span class="hljs-number">0.0</span>;<br>   pt-&gt;x = <span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure><p>以上两种赋值方式的差别</p><p> 如果Point3d是一个Derived class那么指针的存取操作会被延迟到执行期，如果是origin，那就不会有这个问题。</p><p>以上两个需要进一步补充，下面，我们直接进入继承下的对象布局</p><h3 id="继承与Data-member"><a href="#继承与Data-member" class="headerlink" title="继承与Data member"></a>继承与Data member</h3><p>在C++继承模型中，一个derived class object表现出来的东西，是其自己members和base class(es) members的总和。</p><p>至于derived class members 和 base class members的布局顺序，则在c++ standard中没有指定，但是现实中大部分的编译器都是先把base的members先出现。</p><p><strong>在继承过程中，会涉及到边界调整</strong></p><h3 id="带有虚函数的继承"><a href="#带有虚函数的继承" class="headerlink" title="带有虚函数的继承"></a>带有虚函数的继承</h3><p><a href="https://blog.csdn.net/shichao1470/article/details/91563282">https://blog.csdn.net/shichao1470/article/details/91563282</a></p><p><a href="https://blog.csdn.net/qq_31442743/article/details/117689375">https://blog.csdn.net/qq_31442743/article/details/117689375</a> 这个展示了c++的程序存储位置</p><p><a href="https://cloud.tencent.com/developer/article/1755489">https://cloud.tencent.com/developer/article/1755489</a></p><h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><p>当带有虚函数的继承时，会在父类和子类有以下的负担：</p><ul><li>导入一个和子类或者父类相关的virtual table，用来存放它声明的每一个虚函数的地址，这个虚函数表大小是所有虚函数的个数加上一两个slots，存放type_info等</li><li>在每一个class object中导入一个vptr，提供执行期间的链接，使得每一个obje能够找到相应的virtual table</li><li>加强constructor，使他能够为vptr赋初值，指向class对应的虚函数表</li><li>加强destructor，使他能够析构掉vptr</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">stand</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504224026194.png" alt="img"></p><blockquote><p>存储模型</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504225719867.png" alt="img"></p><p>我们看到，这个dog类，包含了一个vptr指向这个虚函数表的偏移16位的地方，然后下面就是一个个的函数指针。在gcc和64位的编译器上，vptr是一个long类型的指针，因为虚函数表存的也是一个个指针，指针大小在64位机器上是8个字节，所以我们要设置vptr为8字节的指针，方便我们取出8字节的内容（即正确取出8字节的函数指针，如果vptr是int*，那么我们只能取出4字节的函数地址，这显然是错误的）</p><blockquote><p>上面没有出现重写，下面是一个重写</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504230137136.png" alt="img"></p><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><blockquote><p>多继承无重写</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190414231512498.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> sleepType;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">stand</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs shell">Vtable for Animal<br>Animal::_ZTV6Animal: 4 entries<br>0     (int (*)(...))0<br>8     (int (*)(...))(&amp; _ZTI6Animal)<br>16    (int (*)(...))Animal::eat<br>24    (int (*)(...))Animal::run<br><br>Class Animal<br>   size=16 align=8<br>   base size=16 base align=8<br>Animal (0x0x7f87d2169420) 0<br>    vptr=((&amp; Animal::_ZTV6Animal) + 16)<br><br>Vtable for Sleeper<br>Sleeper::_ZTV7Sleeper: 4 entries<br>0     (int (*)(...))0<br>8     (int (*)(...))(&amp; _ZTI7Sleeper)<br>16    (int (*)(...))Sleeper::sleep<br>24    (int (*)(...))Sleeper::action<br><br>Class Sleeper<br>   size=16 align=8<br>   base size=12 base align=8<br>Sleeper (0x0x7f87d2169600) 0<br>    vptr=((&amp; Sleeper::_ZTV7Sleeper) + 16)<br><br>Vtable for Dog<br>Dog::_ZTV3Dog: 10 entries<br>0     (int (*)(...))0<br>8     (int (*)(...))(&amp; _ZTI3Dog)<br>16    (int (*)(...))Animal::eat<br>24    (int (*)(...))Animal::run<br>32    (int (*)(...))Dog::shout<br>40    (int (*)(...))Dog::stand<br>48    (int (*)(...))-16<br>56    (int (*)(...))(&amp; _ZTI3Dog)<br>64    (int (*)(...))Sleeper::sleep<br>72    (int (*)(...))Sleeper::action<br><br>Class Dog<br>   size=32 align=8<br>   base size=28 base align=8<br>Dog (0x0x7f87d217c1c0) 0<br>    vptr=((&amp; Dog::_ZTV3Dog) + 16)<br>Animal (0x0x7f87d2169720) 0<br>      primary-for Dog (0x0x7f87d217c1c0)<br>Sleeper (0x0x7f87d2169780) 16<br>      vptr=((&amp; Dog::_ZTV3Dog) + 64)<br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504231424359.png" alt="img"></p><p>【总结】：<strong>我们可以看出，Dog把两个父类的虚函数表都赋值过来了，并且在第一个继承的父类中扩展添加自己的虚函数。</strong></p><blockquote><p>有重写的多继承</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>     <span class="hljs-keyword">private</span>:<br>         <span class="hljs-type">int</span> name;<br>         <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> sleepType;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>         <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shut</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vtable <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTV6Animal: <span class="hljs-number">4</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><br>Class Animal<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7fde52d69420) <span class="hljs-number">0</span><br>    vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTV7Sleeper: <span class="hljs-number">4</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><br>Class Sleeper<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7fde52d69600) <span class="hljs-number">0</span><br>    vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTV3Dog: <span class="hljs-number">10</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::eat<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::action<br><span class="hljs-number">40</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::shut<br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">72</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::_ZThn16_N3Dog6actionEv<br><br>Class Dog<br>   size=<span class="hljs-number">32</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">28</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7fde52d7c1c0) <span class="hljs-number">0</span><br>    vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7fde52d69720) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7fde52d7c1c0)<br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7fde52d69780) <span class="hljs-number">16</span><br>      vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">64</span>)<br><br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504232732177.png" alt="img"></p><p>只要被子类重写的虚函数，都会添加到最左父类指向的格子中，上图子类重写了右边父类的action函数，该函数指针被添加到了左边父类的vptr指向的虚表中。而Sleeper中虚表的action位置则利用了一个thunk，跳转到重写的Dog : : action()。</p><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><blockquote><p>菱形继承</p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504203000972.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> number;<br>&#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> : <span class="hljs-keyword">public</span> Creature&#123;<br>      <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>      <span class="hljs-keyword">private</span>:<br>          <span class="hljs-type">int</span> name;<br>          <span class="hljs-type">int</span> age;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span> : <span class="hljs-keyword">public</span> Creature&#123;<br> <span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-keyword">private</span>:<br> <span class="hljs-type">int</span> sleepType;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shut</span><span class="hljs-params">()</span></span>&#123;&#125;<br> &#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vtable <span class="hljs-keyword">for</span> Creature<br>Creature::_ZTV8Creature: <span class="hljs-number">3</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI8Creature)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Class Creature<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b69420) <span class="hljs-number">0</span><br>    vptr=((&amp; Creature::_ZTV8Creature) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTV6Animal: <span class="hljs-number">5</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><br>Class Animal<br>   size=<span class="hljs-number">24</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">20</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e1a0) <span class="hljs-number">0</span><br>    vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b695a0) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e1a0)<br><br>Vtable <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTV7Sleeper: <span class="hljs-number">5</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><br>Class Sleeper<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e208) <span class="hljs-number">0</span><br>    vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b69720) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e208)<br><span class="hljs-comment">// Dog的对象布局</span><br>Vtable <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTV3Dog: <span class="hljs-number">12</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::action<br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::shut<br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-24</span><br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">72</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><span class="hljs-number">80</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">88</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::_ZThn24_N3Dog6actionEv<br><br>    <span class="hljs-comment">// 下面是Dog的对象布局</span><br>Class Dog<br>   size=<span class="hljs-number">40</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">40</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7faf48b7b230) <span class="hljs-number">0</span><br>    vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">16</span>)<br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e270) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7faf48b7b230)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b69840) <span class="hljs-number">0</span><br>        primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7faf48a0e270)<br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e2d8) <span class="hljs-number">24</span><br>      vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">72</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7faf48b698a0) <span class="hljs-number">24</span><br>        primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7faf48a0e2d8)  <br><br><br></code></pre></td></tr></table></figure><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504234140138.png" alt="img"></p><p>【总结】：即基类Creature的数据成员和虚函数同时存在两份，这显然不是我们想要的</p><blockquote><p>下面是虚继承：</p><p>通过虚继承解决菱形继承的问题，即解决上面父类对象有两份的现象</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Creature</span>&#123;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">live</span><span class="hljs-params">()</span></span>&#123;&#125;<br>  <span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> number;<br>&#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Creature&#123;<br>      <span class="hljs-keyword">public</span>:<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>          <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;&#125;<br>      <span class="hljs-keyword">private</span>:<br>          <span class="hljs-type">int</span> name;<br>          <span class="hljs-type">int</span> age;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sleeper</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Creature&#123;<br> <span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-keyword">private</span>:<br> <span class="hljs-type">int</span> sleepType;<br> &#125;;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>  : <span class="hljs-keyword">public</span> Animal,<span class="hljs-keyword">public</span> Sleeper&#123;<br>     <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br>        <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">shut</span><span class="hljs-params">()</span></span>&#123;&#125;<br> &#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vtable <span class="hljs-keyword">for</span> Creature<br>Creature::_ZTV8Creature: <span class="hljs-number">3</span> entries<br><span class="hljs-number">0</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI8Creature)<br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Class Creature<br>   size=<span class="hljs-number">16</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f8916769420) <span class="hljs-number">0</span><br>    vptr=((&amp; Creature::_ZTV8Creature) + <span class="hljs-number">16</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTV6Animal: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">16</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>VTT <span class="hljs-keyword">for</span> Animal<br>Animal::_ZTT6Animal: <span class="hljs-number">2</span> entries<br><span class="hljs-number">0</span>     ((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">24</span>)<br><span class="hljs-number">8</span>     ((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">64</span>)<br><br>Class Animal<br>   size=<span class="hljs-number">32</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">16</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7f891660e1a0) <span class="hljs-number">0</span><br>    vptridx=<span class="hljs-number">0</span> vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">24</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f89167695a0) <span class="hljs-number">16</span> <span class="hljs-keyword">virtual</span><br>      vptridx=<span class="hljs-number">8</span> vbaseoffset=<span class="hljs-number">-24</span> vptr=((&amp; Animal::_ZTV6Animal) + <span class="hljs-number">64</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTV7Sleeper: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">16</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>VTT <span class="hljs-keyword">for</span> Sleeper<br>Sleeper::_ZTT7Sleeper: <span class="hljs-number">2</span> entries<br><span class="hljs-number">0</span>     ((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">24</span>)<br><span class="hljs-number">8</span>     ((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">64</span>)<br><br>Class Sleeper<br>   size=<span class="hljs-number">32</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">12</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7f891660e270) <span class="hljs-number">0</span><br>    vptridx=<span class="hljs-number">0</span> vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">24</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f8916769780) <span class="hljs-number">16</span> <span class="hljs-keyword">virtual</span><br>      vptridx=<span class="hljs-number">8</span> vbaseoffset=<span class="hljs-number">-24</span> vptr=((&amp; Sleeper::_ZTV7Sleeper) + <span class="hljs-number">64</span>)<br><br>Vtable <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTV3Dog: <span class="hljs-number">16</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">32</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::action<br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::shut<br><span class="hljs-number">56</span>    <span class="hljs-number">16</span><br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">72</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">80</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">88</span>    (<span class="hljs-built_in">int</span> (*)(...))Dog::_ZThn16_N3Dog6actionEv<br><span class="hljs-number">96</span>    <span class="hljs-number">0</span><br><span class="hljs-number">104</span>   (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-32</span><br><span class="hljs-number">112</span>   (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI3Dog)<br><span class="hljs-number">120</span>   (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Construction vtable <span class="hljs-keyword">for</span> <span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7f891660e340 instance) in Dog<br>Dog::_ZTC3Dog0_6Animal: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">32</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::eat<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Animal::run<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-32</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI6Animal)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>Construction vtable <span class="hljs-keyword">for</span> <span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7f891660e3a8 instance) in Dog<br>Dog::_ZTC3Dog16_7Sleeper: <span class="hljs-number">9</span> entries<br><span class="hljs-number">0</span>     <span class="hljs-number">16</span><br><span class="hljs-number">8</span>     (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">0</span><br><span class="hljs-number">16</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">24</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::sleep<br><span class="hljs-number">32</span>    (<span class="hljs-built_in">int</span> (*)(...))Sleeper::action<br><span class="hljs-number">40</span>    <span class="hljs-number">0</span><br><span class="hljs-number">48</span>    (<span class="hljs-built_in">int</span> (*)(...))<span class="hljs-number">-16</span><br><span class="hljs-number">56</span>    (<span class="hljs-built_in">int</span> (*)(...))(&amp; _ZTI7Sleeper)<br><span class="hljs-number">64</span>    (<span class="hljs-built_in">int</span> (*)(...))Creature::live<br><br>VTT <span class="hljs-keyword">for</span> Dog<br>Dog::_ZTT3Dog: <span class="hljs-number">7</span> entries<br><span class="hljs-number">0</span>     ((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">24</span>)<br><span class="hljs-number">8</span>     ((&amp; Dog::_ZTC3Dog0_6Animal) + <span class="hljs-number">24</span>)<br><span class="hljs-number">16</span>    ((&amp; Dog::_ZTC3Dog0_6Animal) + <span class="hljs-number">64</span>)<br><span class="hljs-number">24</span>    ((&amp; Dog::_ZTC3Dog16_7Sleeper) + <span class="hljs-number">24</span>)<br><span class="hljs-number">32</span>    ((&amp; Dog::_ZTC3Dog16_7Sleeper) + <span class="hljs-number">64</span>)<br><span class="hljs-number">40</span>    ((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">120</span>)<br><span class="hljs-number">48</span>    ((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">80</span>)<br><br>Class Dog<br>   size=<span class="hljs-number">48</span> align=<span class="hljs-number">8</span><br>   base size=<span class="hljs-number">28</span> base align=<span class="hljs-number">8</span><br><span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7f891677b230) <span class="hljs-number">0</span><br>    vptridx=<span class="hljs-number">0</span> vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">24</span>)<br><span class="hljs-built_in">Animal</span> (<span class="hljs-number">0x0</span>x7f891660e340) <span class="hljs-number">0</span><br>      primary-<span class="hljs-keyword">for</span> <span class="hljs-built_in">Dog</span> (<span class="hljs-number">0x0</span>x7f891677b230)<br>      subvttidx=<span class="hljs-number">8</span><br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f89167698a0) <span class="hljs-number">32</span> <span class="hljs-keyword">virtual</span><br>        vptridx=<span class="hljs-number">40</span> vbaseoffset=<span class="hljs-number">-24</span> vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">120</span>)<br><span class="hljs-built_in">Sleeper</span> (<span class="hljs-number">0x0</span>x7f891660e3a8) <span class="hljs-number">16</span><br>      subvttidx=<span class="hljs-number">24</span> vptridx=<span class="hljs-number">48</span> vptr=((&amp; Dog::_ZTV3Dog) + <span class="hljs-number">80</span>)<br><span class="hljs-built_in">Creature</span> (<span class="hljs-number">0x0</span>x7f89167698a0) alternative-path<br></code></pre></td></tr></table></figure><blockquote><p><strong>一定要注意内存对齐</strong></p></blockquote><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20190504235614359.png" alt="img"></p><p><strong>这个图的number和sleepType位置反了</strong></p><h3 id="多继承父指针和子类指针转化时情况"><a href="#多继承父指针和子类指针转化时情况" class="headerlink" title="多继承父指针和子类指针转化时情况"></a>多继承父指针和子类指针转化时情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base的构造&quot;</span> &lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">Base</span>(Base&amp; b)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了Base的copy&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;A::func()&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Base</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了Base的析构函数&quot;</span> &lt;&lt;endl;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-comment">// string s;</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span>&#123;<br> <span class="hljs-keyword">public</span>:<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">action</span><span class="hljs-params">()</span></span>&#123;&#125;<br> <span class="hljs-keyword">private</span>:<br> <span class="hljs-type">int</span> sleepType;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> :<span class="hljs-keyword">public</span> Base,<span class="hljs-keyword">public</span> AA &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>()&#123;<br>    &#125;<br>    <span class="hljs-comment">// Derived(Derived&amp; d)&#123;</span><br>        <br>    <span class="hljs-comment">//     cout &lt;&lt; &quot;执行了&quot;&lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    ~<span class="hljs-built_in">Derived</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;调用了Drived的析构函数&quot;</span>&lt;&lt;endl;<br>    &#125;<br><span class="hljs-comment">// virtual void func() &#123; cout &lt;&lt; &quot;B::func()&quot; &lt;&lt; endl; &#125;</span><br>    <span class="hljs-comment">// string j;</span><br><span class="hljs-comment">// int z;</span><br>    <span class="hljs-comment">// int t;</span><br>&#125;;<br><span class="hljs-comment">// void (*p)(void);</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Derived * d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    AA *a = d;<br>    cout &lt;&lt; d &lt;&lt;endl;  <span class="hljs-comment">// 0x55555556aeb0</span><br>    cout &lt;&lt; a &lt;&lt;endl;  <span class="hljs-comment">// 0x55555556aec0</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>Drived 继承 Base ，和AA，由上可以看到a和d地址偏移16，也就是我们上述分析的偏移了两个int和vptr。</strong></p></blockquote><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><h3 id="函数的各种调用方式"><a href="#函数的各种调用方式" class="headerlink" title="函数的各种调用方式"></a>函数的各种调用方式</h3><h4 id="非静态成员函数"><a href="#非静态成员函数" class="headerlink" title="非静态成员函数"></a>非静态成员函数</h4><p>既然他叫成员函数，那么成员函数也会被转成非成员函数，主要转换步骤</p><ul><li>改写函数原型，安插一个额外的参数在member function中，这个额外参数就是<strong>this指针</strong>，这个指针不能指向别的对象，因此他是Person * const p；这种形式的</li><li>对每一个非静态成员数据都是通过这个this指针完成的</li><li>将成员函数改写成一个外部函数，然后给这个函数重新mangling处理，也就是重新设置名字，对于数据成员也是重新命名</li></ul><h4 id="虚拟成员函数"><a href="#虚拟成员函数" class="headerlink" title="虚拟成员函数"></a>虚拟成员函数</h4><p>如果normalize()是一个虚拟函数，那么对于以下的调用</p><p>ptr-&gt;normalize()；</p><p>会被转换成如下：</p><p>（* ptr-&gt;vptr[1]）(ptr);</p><ul><li>vprt 是虚函数表指针，这个虚函数表指针的名称不一定知识vptr，还有可能也被mangling（重命名），因为在一个复杂的继承体系中，可能存在多个vptr</li><li>1是代表虚函数表项的索引，关联到normalize（）函数</li><li>第二个ptr指的是this指针</li></ul><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul><li><strong>静态成员函数的主要特征是它没有this指针</strong></li><li>它不能直接存取class中的非静态成员（数据和函数都不行）</li><li>它不能够被声明为const volatile或者virtual</li><li>它不需要经由class object 调用</li></ul><h1 id="C-新特性"><a href="#C-新特性" class="headerlink" title="C++ 新特性"></a>C++ 新特性</h1><p><a href="https://blog.csdn.net/weixin_46873777/article/details/122948389?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_46873777/article/details/122948389?spm=1001.2014.3001.5502</a></p><p><a href="https://blog.csdn.net/weixin_58450087/article/details/124510851?spm=1001.2014.3001.5502">https://blog.csdn.net/weixin_58450087/article/details/124510851?spm=1001.2014.3001.5502</a></p><h1 id="C-静态链接和动态链接"><a href="#C-静态链接和动态链接" class="headerlink" title="C++ 静态链接和动态链接"></a>C++ 静态链接和动态链接</h1><h2 id="源代码到可执行文件过程"><a href="#源代码到可执行文件过程" class="headerlink" title="源代码到可执行文件过程"></a>源代码到可执行文件过程</h2><p>源代码到可执行文件，一般会经历预处理、编译、汇编、链接这几个操作</p><ul><li>预处理主要是对一些宏定义进行文本替换，对include进行处理，对条件编译指令进行处理，删除所有的注释，添加行号和文件标识，方便在调试和编译错误时显示行号</li><li>编译：编译阶段是将预处理后的文件进行语法分析和语义解析与优化生成对应的汇编代码</li><li>汇编：汇编就是将汇编文件解析成机器指令，生成目标文件</li><li>链接：</li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>静态链接是通过链接器，将多个目标文件链接成一个可执行文件。静态链接是发生在程序运行前就完成的，它主要做了两件事：</p><ul><li><strong>空间与地址分配</strong>：将多个目标文件中的相同的段进行合并，然后为新的段分配虚拟内存地址，并在section table中记录每个段在新的文件中的偏移量，即VMA和file off信息，然后将每个目标文件中的符号表进行重计算和合并，放到一个符号表中（即重新计算每个符号属于哪个段，以及<strong>每个符号的虚拟地址 – 因为符号只有一个）</strong>；</li><li><strong>符号解析与重定位</strong>：基于上一步和每个section的重定位表，我们可以对符号进行重定位，将要重定位的地方修改为正确的虚拟地址。<strong>重定位表中记录了重定位的位置以及重定位符号在符号表中的下标等信息</strong>。      <strong>重定位的地方有很多，可能多个重定位地方对应相同的符号。</strong></li></ul><blockquote><p>符号表：记录和每个符号的名字，所在的段，和在每个段中的偏移位置（链接后直接记录的是虚拟地址）</p><p>重定位表：重定位表记录了所有的要重定位的位置，即重定位位置属于哪个段，重定位的符号在符号表中的下标。这样就能够将这个重定位的位置替换对应的符号的真实虚拟地址了。</p></blockquote><blockquote><p>静态链接带来的弊端：</p></blockquote><p>静态链接会直接将其他的目标文件的段合到一起而形成一个新的可执行文件，这样就会导致形成的可执行文件中包含了大量的目标文件的副本。造成磁盘和内存空间的浪费。</p><p>而且当其中一个目标文件修改之后，必须重新链接成新的可执行文件。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><blockquote><p> 为什么要引入动态连接</p></blockquote><p>在静态链接中，多个目标文件进行链接的时候会在可执行文件中合并所有目标文件中的相同的段，也就是最终的可执行文件是包含了所有目标文件的一个副本。这样就会造成空间的浪费，因为在内存和磁盘中会有很多目标文件的副本存在。并且当参与静态链接的目标文件发生改变的时候，需要重新进行链接，这对于大量使用此目标文件的程序的运行更新带来很多麻烦。因此，针对于这两个现象，引入了动态链接技术，动态链接能够将目标文件的链接推迟到运行阶段，而不是发生在程序的装载前。但是这样也会导致运行时链接降低了程序的运行效率。</p><blockquote><p>共享模块的在编译的时候，目标地址是不确定的（就是它里面的一些重定位符号），只有当链接的时候才会确定这个地址。（比如共享模块访问自己模块中的全局变量，共享模块的.data会被复制一块然后映射到进程的虚拟空间中，当共享模块发生重定位时，由于每个进程可能为共享模块分配的虚拟空间不同，由于重定位时会发生指令变化，将可重定位地方转成对应的地址，这样由于不同进程中.data中各个变量虚拟地址不同，就会导致这个共享模块无法在所有进程共享。）</p><p><strong>简而言之就是：在共享模块中的代码有采用绝对地址访问变量的指令，在重定位时，由于各个进程为共享模块分配的虚拟空间不一样，导致重定位时每个进程访问同种变量时地址不一致，因此这就无法实现共享模块指令的共享。</strong></p></blockquote><blockquote><ol><li>装载时重定位：就是在发生装载的时候才进行重定位操作。但是这个方法不能实现指令在内存中的共享，依然需要占用很多内存对于多个进程使用同一个共享模块</li><li>地址无关代码：这个就是用来解决动态模块中<strong>有绝对地址引用</strong>的方法，并且实现了共享模块指令在进程间的共享</li></ol></blockquote><blockquote><p>下面我们就介绍一下这个地址无关代码：</p><ul><li>基本思想就是：将指令中那些需要被修改的部分分离出来，和数据部分放在一起</li><li>将.data段单独复制一份出来并映射到自己进程的虚拟空间</li><li>这样其他的指令是可以在进程间共享的</li></ul></blockquote><p>我们进行分类讨论这个指令寻址方式：</p><ul><li><p>模块内数据访问：采用的是相对寻址</p></li><li><p>模块内数据的访问与调用：采用的是相对寻址</p></li><li><p>模块间的数据访问：</p><blockquote><p>对于模块间的数据访问，通过采用的GOT（global offset table）全局偏移表实现，在GOT表中记录了要访问的其他模块的变量的地址（当然被调用的共享模块中的.data已经被复制一份并映射到自己进程的虚拟空间中了），这样指令中访问其他模块的变量的指令就是直接访问这个GOT表了，通过相对寻址，这就实现了地址代码无关的指令了（因为所有模块中都没有绝地地址寻址了），都相当于转换成了模块内的相对寻址了。</p><ul><li>我们在编译的时候就可以确定GOT相对当前指令的偏移量，然后根据变量在GOT中的偏移量就可以确定这个变量位于GOT那个地方（由编译器规定每个变量的位置）然后在装载的时候，就可以将变量的实际虚拟地址给填充到这个GOT中。然后就可以通过这个GOT进行间接寻址了。</li></ul></blockquote></li><li><p>模块间的函数访问与调用：</p><blockquote><p>这个也是通过GOT进行实现的，存放函数地址。</p></blockquote></li></ul><p>【动态链接带来的缺点】：</p><ul><li>在动态链接下，程序的链接是发生在运行时期的，他会装载所有相关的共享模块，然后进行符号查找与重定位工作，这些都降低了程序初始运行的速度</li><li>并且，动态链接中一些模块间数据的访问是要通过GOT表进行间接寻址的，先要找到GOT表，然后确定访问变量的地址，然后再根据地址去访问变量。</li></ul><blockquote><p>我们如何对动态链接进行优化呢？</p></blockquote><ul><li>延迟绑定</li></ul><p>因为在程序运行前，就将所有的函数进行符号查找和重定位操作，但是有些函数可能从始至终都没有使用过，所以我们可以在函数的第一次使用的时候才进行绑定（符号查找和重定位）</p><p>【具体原理】：</p><p>在elf中维护了一个PLT表，对于函数的调用是通过这个PLT进行调用的，而不是之前的那个GOT表了，但是实际就是先通过PLT再通过GOT进行调用。PLT表和GOT表的填充都是在运行时进行填充的。</p><blockquote><p>我们现在开始说一下这个动态链接的具体过程</p></blockquote><p>先回顾一下静态链接中elf文件加载过程：</p><p>就是先读取elf header，然后进行文件的格式版本检查等操作，然后根据Program header table读取所有的段进入内存，并完成物理空间分配和地址映射操作，执行完成这些之后，就将eip指向程序的入口地址。</p><p>但是在动态链接中不是这样的：</p><p>当加载完成所有的段后，它会把eip指向动态链接器程序入口地址，动态连接器其实也是一个共享模块，然后对当前的可执行文件进行动态链接操作，然后执行完成之后，再把eip指向可执行文件的入口地址。</p><ul><li><p>动态链接器存在哪里？</p><p>动态链接模块在可执行文件中.inter段（interpreter）这个段记录了这个链接器的地址</p></li><li><p>.dynamic段是什么</p><p>他是专门用于动态链接的，在这个段中记录了动态链接符号表、动态链接重定位表位置等等</p><p>它和静态链接中ELF文件中文件头差不多，记录了这些符号表、重定位表信息</p></li></ul><blockquote><p>什么是动态符号表？.dynsym表</p></blockquote><p>在目标文件中，符号表记录了这个文件中的所有定义的符号的信息，比如这个符号的名字，这个符号在段中的偏移量等信息，在静态链接结束后，就会在符号表中记录了这个符号的地址信息。</p><p>动态符号表其实和静态符号表差不多</p><p><strong>在动态符号表中记录了动态链接模块中符号的导入和导出关系。</strong>动态符号表只记录了动态链接的符号，对于那些模块内部的符号存在.symtab中，.symtab中包含了.dynsym表信息</p><blockquote><p>什么是动态链接重定位表？</p></blockquote><p>主要是用来重定位.got和.got.plt段中的地址。因为这两个段记录了每个引用的全局变量和函数的地址。我们需要在装载完之后进行重定位这些变量的地址。</p><p>主要步骤和静态链接差不多，就是先去符号表中获取这个符号对应的地址，然后将地址填入到指定的.got或.got.plt位置处。</p><blockquote><p>下面我介绍一下动态链接的步骤于与实现</p></blockquote><h1 id="Gcc基本使用"><a href="#Gcc基本使用" class="headerlink" title="Gcc基本使用"></a>Gcc基本使用</h1><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>【参考博客】<a href="https://blog.csdn.net/IT_Mitchell/article/details/83932742">编译阶段+链接阶段+运行原理</a></p><p>gcc编译的四大过程：</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA54yq56qB54yb6L-b6L-b6L-b,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><blockquote><p> gcc -E hello.c -o hello.i  //-E只对其预处理，其注释被删除，且宏也被替代之后删除，</p></blockquote><blockquote><p> gcc -S hello.i -o hello.s // -S将.i文件生成.s汇编文件</p></blockquote><blockquote><p>gcc -c hello.s -o hello.o  //-c汇编文件，不链接，汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。</p></blockquote><blockquote><p>gcc hello.o -o hello // 链接阶段，<strong>这里才会分配地址空间</strong></p></blockquote><h2 id="反汇编等命令"><a href="#反汇编等命令" class="headerlink" title="反汇编等命令"></a>反汇编等命令</h2><p><a href="https://blog.csdn.net/qq_38048756/article/details/115517983">https://blog.csdn.net/qq_38048756/article/details/115517983</a></p><blockquote><p>objdump -S a    // 其中a为a.out文件，反汇编之后会有地址的分配，</p><p>objdump -S person.o // 后面那个.o可以要也可以不要，看你具体生成的文件，这个反汇编生成的.s文件是没有地址分配的。</p></blockquote><h1 id="基本知识（汇总）"><a href="#基本知识（汇总）" class="headerlink" title="基本知识（汇总）"></a>基本知识（汇总）</h1><p><a href="https://blog.csdn.net/qq_31442743/article/details/116119490">https://blog.csdn.net/qq_31442743/article/details/116119490</a>  c++面试高频题-速记版</p><h2 id="const-和static"><a href="#const-和static" class="headerlink" title="const 和static"></a>const 和static</h2><p><a href="https://www.yuque.com/orwell/vkefvt/axhgel#Uy4F0">https://www.yuque.com/orwell/vkefvt/axhgel#Uy4F0</a></p><h3 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h3><p>static（静态）主要有三个作用：</p><p>1.修饰局部变量，成为静态局部变量</p><p>2.修饰全局变量，成为静态全局变量</p><p>3.修饰函数，成为静态函数</p><blockquote><p><strong>static只能在类外进行初始化，因为静态成员属于类的，而不是对象的，所以不能在构造函数等地方进行初始化，不然的话，每次创建对象的时候都会更改这个static的值</strong></p><ul><li>但是常量静态成员可以在类内初始化</li><li>关键字static只出现类的内部。</li><li>在类外定义且初始化</li></ul></blockquote><blockquote><p>静态成员函数</p></blockquote><p>不考虑类情况：</p><ul><li>隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件所在的编译模块中使用</li><li>默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区</li><li>静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存在，但不能使用</li></ul><p>考虑类： 静态成员函数是类中的特殊成员函数</p><ul><li>静态成员函数没有this指针，就是在编译的时候，不会产生this指针参数，普通的非静态成员函数是有this指针的，当我们调用的时候，系统会给这个对象的起始地址作为this指针给到函数，实现不同对象复用函数代码的隔离性</li><li>静态函数可以通过类和对象访问</li><li>静态成员函数只能访问静态函数/对象，不能访问非静态成员函数/对象</li><li>使用静态函数主要是为了处理静态成员变量。</li><li><strong>不能被声明为const、虚函数和volatile</strong>；可以被非static成员函数任意访问</li></ul><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><ul><li>不考虑类的情况<ul><li>const常量必须在定义的时候必须初始化，之后再也无法更改</li><li>const形参可以接收const和非const的实参</li></ul></li><li>考虑类的情况<ul><li><code>const成员变量</code>：不能在类内定义外部初始化，只能通过构造函数初始化列表进行初始化和类内声明时初始化(但是这个由于const属于对象数据，如果在类内声明后就初始化，那所有的对象都是一样的，通过初始化列表初始化可以为不同的类制定不同的数据，所以不建议直接初始化)</li><li><code>const成员函数</code>：不可以改变非mutable（用该关键字声明的变量可以在const成员函数中被修改）数据的值–<strong>C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this</strong>*，因此不能const和static关键字同时修饰函数。因为static是没有this指针的</li><li>const对象不可以调用非const成员函数；非const对象都可以调用；</li></ul></li></ul><blockquote><p><strong>当const在函数名前面的时候修饰的是函数返回值，在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。修饰谁，谁就不能发生修改！</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> <span class="hljs-type">const</span> </span>&#123; <br>xxxx<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>常量指针和指针常量</p></blockquote><p>const int * p //表示常量指针–无法修改指针指向的空间的内容，所指向的变量是个const</p><p>int * const p // 表示这个指针不能更改指向的空间，但是可以改变指向空间的内容</p><h2 id="内存字节对齐"><a href="#内存字节对齐" class="headerlink" title="内存字节对齐"></a>内存字节对齐</h2><p><a href="https://blog.csdn.net/qq_62932195/article/details/125821103">https://blog.csdn.net/qq_62932195/article/details/125821103</a></p><p>为了提高cpu的读取效率，会使数据存放进行对齐。</p><p>对齐的规律：</p><ul><li><strong>数据类型自身的对齐值</strong>：就是基本数据类型的自身对齐值，比如char类型的自身对齐值为1字节，int类型的自身对齐值为4字节。</li><li><strong>指定对齐值</strong>：预编译命令#pragma pack （value）指定的对齐值value。</li><li><strong>结构体或者类的自身对齐值</strong>：其成员中自身对齐值最大的那个值，比如以上的struct A的对齐值为4。</li><li><strong>数据成员、结构体和类的有效对齐值</strong>：自身对齐值和指定对齐值中较小的那个值。</li></ul><h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><p>c++将内存空间分为<strong>堆、栈、自由存储区、全局/静态变量区、常量存储区和代码区，</strong>他比c内存模型多了一个自由存储区。</p><p>或则说可以分为文本段（主要存放我们编写的代码，属于read only）、Data段（主要存放一些初始化的静态、全局变量和常量等）、bss段主要用来存放一些未初始化的静态、全局变量和常量（一般它不占文件大小，只有加载到内存后才会分配空间，它记录在elf header里面）、堆（主要是在运行时期申请和分配的空间）、栈（主要存放一些函数参数和局部变量这些）。</p><blockquote><p>那么自由存储区和堆的区别是什么？</p></blockquote><p>堆是C语言的关键语，是操作系统所维护的一块特殊内存，它提供了内存动态分配的功能。用户可以使用malloc进行堆内存的申请，使用free实现堆内存的释放。</p><p>而自由存储区是c++的抽象概念。C++将使用new/delete申请和释放的区域称为自由存储区。因此，自由存储区的实际位置和new/delete 申请释放的位置有关。 大部分编译器的new申请空间基于malloc实现的，默认在堆上实现自由存储区。但是用户也可以通过重载new关键字实现在其他区域的自由存储。</p><p>总之：自由存储区不等于堆，它只是C++的一个抽象概念，位置在哪取决于new/delete的实现，堆是操作系统维护的一块特殊内存。</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230329105118345.png" alt="image-20230329105118345"></p><h2 id="STL内存池"><a href="#STL内存池" class="headerlink" title="STL内存池"></a>STL内存池</h2><p>一般来说，我们使用new运算符的时候，它会执行两个操作，一个是operator new （即分配空间），然后是构造对象，对于delete运算符，先析构对象再调用operator delete释放内存</p><p>但是在STL中：</p><ul><li>内存的<code>申请和释放</code>由<code>alloc::allocate()</code>和<code>alloc::deallocate()</code>这两个函数负责,<ul><li>在头文件<code>&lt;stl_alloc.h&gt;</code>中</li></ul></li><li>对于对象的<code>构造和析构</code>则由<code>::construct()和::destroy()</code>负责<ul><li>在construct中，会调用placement new去构造对象</li><li>在destroy中，直接调用对象的析构函数析构对象</li><li>在头文件<code>&lt;stl_construct.h&gt;</code>中</li></ul></li></ul><p>这两个头文件都在<code>&lt;memory&gt;</code>文件中</p><blockquote><p>下面我们讲一下这个STL中的内存申请与释放原理</p></blockquote><p>为了减少这个小型区块可能造成的内存碎块的问题，SGI设计了双层空间配置器</p><ul><li>第一级配置器直接采用malloc和free进行内存的申请和释放</li><li>第二级配置器采用维护一个内存池进行空间的分配</li></ul><blockquote><p>第一级配置器：</p></blockquote><p>第一级配置器以malloc、free、realloc()等C函数进行内存的申请、释放、重配置操作，并且设计了类似C++ new-handler机制（对于operator new也是封装了malloc，为什么不直接使用operator new呢，因为STL不能直接使用C++ new-handler机制，所以不能使用，所以自己设计了一个new-handler机制）</p><blockquote><p>第二级配置器</p></blockquote><p>SGI的二级配置器的做法是，如果申请的区块足够大，则给一级配置器处理，如果申请的内存块小于128KB，那么以内存池进行管理</p><p>二级配置器会维护16个链表，每个链表负责管理8、16、24一直到128为8的倍数的空间，它的节点是一个联合体，维护空间的时候可以看成一个节点(只包含一个next)，分配出去空间的时候，就是一个char数组了，用来存储数据。</p><p>同时还有一个空闲的内存池，由两个指针<code>start_free</code>和<code>end_free</code>两个指针维护</p><p>它的空间配置流程：</p><ol><li>对于申请空间：<ul><li>如果大于128kb就走一级配置器，否则走二级</li><li>一般申请的空间会是20*2个要申请的空间大小，然后1个返回给用户，19个挂在指定的链表上，然后剩下的20个作为内存池使用</li><li>首先我们会根据申请的空间找到对应的free_list节点，然后看看这个链表中有没有剩余的空间<ul><li>如果这个链表不为空，则将这个链表中取下一块内存分配给用户，并将free_list数组中的头节点指向新的空闲节点</li><li>如果链表为空，我们就先去这个内存池中去找对应的内存，然后申请20*2个，不够40，就有多少分多少，然后第一个给用户，剩余的放在指定的链表中维护</li><li>如果这个内存池没了，就重新使用malloc进行申请</li><li>如果整个heap空间没了，就会在freelist中找剩余的空间进行分配</li></ul></li></ul></li><li>对于释放空间就是上面的逆过程。</li></ol><h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><h2 id="值、引用、指针传递"><a href="#值、引用、指针传递" class="headerlink" title="值、引用、指针传递"></a>值、引用、指针传递</h2><blockquote><p>值传递</p></blockquote><p>在栈上压入参数的时候，会copy一份实参数据到栈上，对于栈上对象的更改不会影响实参本身</p><blockquote><p>指针传递</p></blockquote><p>指针传递实质也是值传递，只不过这个值是地址罢了，copy了一份指针的内容到栈上，这两个同时指向一个对象，所以可以通过栈上的指针来改变对象的内容</p><blockquote><p>引用传递</p></blockquote><p>引用的本质是指针常量，不会发生这个对象的拷贝构造，但是会有这个指针的拷贝，就是在栈上也会开辟空间，但是这个引用不能指向别人，对于那个指针传递，传进来的指针可以改变指向，但是无法改变实参指针的指向。</p><blockquote><p>指针返回和引用返回</p></blockquote><blockquote><p>对于返回值是引用还是指针，一定要保证这个引用和指针指向的内容在函数结束之后还存在，不能是局部变量（在栈上申请的局部变量不能使用引用或者指针返回），在堆上的可以使用指针返回（前提是没有delete掉，但是最好别这样干，因为很可能导致内存泄漏，也可以使用引用返回，但是无法delete）。</p></blockquote><h2 id="几种指针类型"><a href="#几种指针类型" class="headerlink" title="几种指针类型"></a>几种指针类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> *p[<span class="hljs-number">10</span>]  <span class="hljs-comment">// 表示指向一个指针数组  即 (int*) p[10];数组都是指针</span><br><span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>] <span class="hljs-comment">// 表示一个指向一个二维数组的指针，每行10个元素，如下代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>   <span class="hljs-comment">// 表示是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</span></span><br><span class="hljs-function"><span class="hljs-title">int</span> <span class="hljs-params">(*p)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>  <span class="hljs-comment">// 是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</span></span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">1</span>][<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-built_in">int</span> (*p)[<span class="hljs-number">10</span>];<br>    p = a; <span class="hljs-comment">// p可以看成一个指针的指针，指向一个 指向数组元素的指针数组</span><br>    cout &lt;&lt; *(*p +<span class="hljs-number">1</span>) &lt;&lt; endl;  <span class="hljs-comment">// 1  *p得到第一个数组的指针，p+2得到第3个数组的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="new-delete-和-malloc-free"><a href="#new-delete-和-malloc-free" class="headerlink" title="new/delete 和 malloc/free"></a>new/delete 和 malloc/free</h2><blockquote><p>相同点：</p></blockquote><p>都是用来申请动态内存的。</p><blockquote><p>不同点</p></blockquote><p>new/delete 是c++的关键字，new不需要自己计算内存大小，他会自动计算，而malloc需要自己计算</p><p>new是类型安全的，int *p = new int[100];正确，只能是int申请int的，不能int申请long之类的。</p><p><code>new关键字</code>：</p><ul><li>先调用operator new标准库函数进行空间申请，然后再调用对象的构造函数进行构造对象</li></ul><p><code>delete关键字</code>：</p><ul><li>先调用指针所指对象的析构函数进行析构对象，然后调用operator delete标准库函数进行内存释放</li></ul><p><strong>而malloc和free都是直接申请空间和释放操作，就是operator new和operator delete的操作，而不会构造对象和析构对象</strong></p><p><em><em>malloc和free返回的指针式void</em> 类型的，而new和delete式返回的具体的类型的指针</em>*</p><p>对于new之后，可以直接free，但是不会析构对象，只会释放函数</p><h3 id="malloc是如何申请内存的"><a href="#malloc是如何申请内存的" class="headerlink" title="malloc是如何申请内存的"></a>malloc是如何申请内存的</h3><p>malloc申请内存的时候，会有两种方式向操作系统申请堆内存</p><ul><li>方式一：通过brk()系统调用从堆中分配内存 <ul><li>通过brk()函数将堆顶指针向高地址移动，获取新的内存空间。</li></ul></li><li>方式二：通过mmap()系统调用在文件映映射区进行分配<ul><li>同mmap函数在文件映射区分配一块内存。</li></ul></li></ul><blockquote><p><strong>什么场景下mallco函数会通过brk来申请内存空间？什么场景下用mmap申请</strong></p></blockquote><ul><li>当用户分配的内存小于128KB的时候，使用brk申请内存</li><li>当用户申请的内存高于128KB的时候，使用mmap申请内存</li></ul><p>不同的malloc实现，阈值也是不同的</p><ul><li>使用brk申请空间，他会一次性申请较多的空间，然后执行free后也不会将申请的空间归还给操作系统，只有当进程结束的时候才会将空间还给操作系统<ul><li>malloc（1）会申请一大块内存，使用brk，剩下的内存可以作为内存池下次使用。</li></ul></li><li>使用mmap申请空间，free之后会直接将空间还给操作系统。</li></ul><blockquote><p><strong>malloc分配的是物理内存吗？</strong></p></blockquote><p>malloc分配的是虚拟内存。</p><p>当分配的虚拟内存空间没有被访问的时候，他是不会分配物理空间的，只有当用户访问了分配的虚拟空间，这个时候就会触发缺页异常，然后操作系统就会申请相应的物理页内存，并建立虚拟内存和物理内存的映射关系</p><blockquote><p>为什么free函数只传入一个内存地址，为什么能够知道要释放多大的空间</p></blockquote><p><strong>malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节</strong></p><p>这多出来的16字节就是存储这块内存块的信息，比如内存大小之类的</p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/cb6e3ce4532ff0a6bfd60fe3e52a806e.png" alt="图片"></p><p>这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。</p><h3 id="malloc和free底层实现"><a href="#malloc和free底层实现" class="headerlink" title="malloc和free底层实现"></a>malloc和free底层实现</h3><h2 id="Java和C-区别"><a href="#Java和C-区别" class="headerlink" title="Java和C++区别"></a>Java和C++区别</h2><p>java的代码首先会经过一次编译形参字节码，也就是.class文件，这个.class文件在运行时会被jvm加载到内存并解释成字节码。而c++只需要一次编译链接就形成了机器码，所以程序执行的速度C++相对快点</p><p>但是java程序可以跨平台，通过在不同的平台上安装不同版本的jvm，就能够将.class文件解释成对应的机器码进行执行。</p><p>c++中包含指针，而java程序没有指针，他只有引用。</p><p>java程序是纯面向对象语言，所有的函数和变量都必须在类中定义，而C++可以有全局的函数和变量，可以面向过程</p><p>C++是需要自己管理内存的，而Java中的jvm是有自己垃圾回收机制，不用自己释放内存。</p><p>C++的运算符可以重载，而java的运算符不能重载。</p><p>C++程序适用于桌面程序和底层硬件控制之类的程序，而java适合web应用，因为其相关的web开发的框架十分多。</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p><a href="https://www.linuxidc.com/Linux/2019-03/157819.htm">https://www.linuxidc.com/Linux/2019-03/157819.htm</a></p><p><a href="https://blog.csdn.net/yaxuan88521/article/details/127333854">https://blog.csdn.net/yaxuan88521/article/details/127333854</a></p><p><a href="https://blog.csdn.net/weixin_58450087/article/details/124353529?spm=1001.2014.3001.5502%E3%80%90%E8%AF%A6%E7%BB%86%E3%80%91">https://blog.csdn.net/weixin_58450087/article/details/124353529?spm=1001.2014.3001.5502【详细】</a></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/84e80cdb0785e2711c677bcc943e05c7.png" alt="img"></p><ul><li><p>进程是资源分配的最小单位，一个进程可以有多个线程，每个线程执行不同的任务</p></li><li><p>而线程是cpu调度和分配的最小单位（cpu调度的就是一个个task_struct结构，每个线程和进程具有一个task_struct结构标识），它被包含在进程之中，是进程中的实际运行单位</p></li><li><p>每个task_struct中包含一个pid用来标识自己，然后还有一个tgid用来标识自己隶属于哪个进程（也就是线程组id），通过这个就可以共享这个进程的内存空间。</p></li><li><p>一个进程至少包含一个线程，进程是线程的容器</p></li><li><p>进程在创建子进程的时候，是拷贝整个内存空间，后面进行优化成了写时拷贝</p></li><li><p>而线程本身不具有内存空间，它和创建它的进程共享内存空间</p></li><li><p>进程有自己独立的地址空间，一个进程崩溃时，一般不会影响其他进程，而线程只是有自己的堆栈，但没有独立的地址空间，多个线程共享进程的内存空间，一个线程崩溃后，整个进程崩溃</p></li><li><p>线程之间的通信更加方便，因为他们共享进程的地址空间，可以访问全局变量和静态变量这些，而进程间的通信比较复杂。</p></li></ul><blockquote><p>为什么线程的切换比进程的切换的代价小？</p></blockquote><p>在切换进程的时候，会导致TLB的缓存失效，而对于线程的切换来说则不会影响TLB，所以在地址转换过程就比较慢了，开销就比较大了。</p><h2 id="内存泄漏、检测和解决办法"><a href="#内存泄漏、检测和解决办法" class="headerlink" title="内存泄漏、检测和解决办法"></a>内存泄漏、检测和解决办法</h2><blockquote><p> 什么是内存泄漏？</p></blockquote><ul><li>内存泄漏是指程序动态申请内存后，没有及时的释放掉不再使用的内存的情况。内存泄漏并不是指内存在物理上消失，而是指应用程序在分配某段内存后，由于某种原因，失去了对这块内存的控制。</li></ul><blockquote><p>产生内存泄漏的几种原因：</p></blockquote><ul><li>new 和delete没有成对使用，new完之后，没有及时delete，以及使用new申请的是数组空间，要使用delete + [] 进行释放，不然只会释放一个。</li><li>在继承关系中，基类的析构函数没有设计为虚函数<ul><li>对于析构过程，一般来说，对于子类的析构一般会先调用子类的析构函数，然后调用父类的析构函数</li><li>但是对于基类对象指针指向子类对象，如果没有采用虚析构设计，就会导致只析构父类对象，不会析构子类对象，因为无法通过父类指针来调用子类独有的方法和变量</li></ul></li></ul><blockquote><p>解决办法</p></blockquote><ul><li><p>手动释放:malloc和new之后一定要及时的free和delete，对于new数组，要使用delete数组的形式</p></li><li><p>使用智能指针，智能指针是资源获取即初始化的一种体现，使用智能指针管理我们的内存，可以在对象销毁时进行释放内存</p></li></ul><blockquote><p>如何检测内存泄漏？</p></blockquote><p>在Linux上比较常用的内存泄漏检测工具是<code>valgrind</code>，所以咱们就以valgrind为工具，进行检测。</p><h2 id="智能指针-1"><a href="#智能指针-1" class="headerlink" title="智能指针"></a>智能指针</h2><p><a href="https://blog.csdn.net/qq_56673429/article/details/124837626">https://blog.csdn.net/qq_56673429/article/details/124837626</a></p><p><a href="https://blog.csdn.net/weixin_46873777/article/details/123279167">https://blog.csdn.net/weixin_46873777/article/details/123279167</a></p><p>智能指针一般指的是std::unique_ptr，std::shared_ptr,weak_ptr</p><blockquote><p>shared_ptr：共享智能指针</p></blockquote><p>共享智能指针是指多个此智能指针可以同时指向管理同一块区域。</p><p>【如何让共享智能指针指向一块区域（初始化）：】</p><ul><li>通过构造函数</li><li>std::make_shared辅助函数</li><li>reset函数</li></ul><p>【获取原始指针？？？】：</p><p><strong>对于基础类型来说，通过操作智能指针和操作原始指针效果一样。但是如果共享智能指针管理的是一个对象，那么就需要取出管理的对象的原始指针，然后基于原始指针进行操作，可以使用get()方法获取原始指针</strong></p><p>【指定删除器】：</p><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就被智能指针释放掉了。另外，我们在初始化智能指针的时候也可以自己指定删除动作，<strong>这个删除操作对应的函数被称之为删除器</strong>，<strong>这个删除器函数本质是一个回调函数</strong>，我们只需要进行实现，其调用是由智能指针完成的。</p><blockquote><p>unique_ptr：独占智能指针</p></blockquote><p>他不允许其他的智能指针共享其内部的指针，也就是无法进行拷贝和复制，在unique_ptr中，拷贝构造函数的=号操作符都被标识为delete了</p><p>使用和共享智能指针基本一样</p><blockquote><p>weak_ptr：弱引用的智能指针</p></blockquote><p>它的存在主要是解决共享智能指针存在的循环引用的问题。它不能够操作资源，它只能判断资源是否有效，主要是配合shared_ptr进行预防循环引用，当指向一个和shared_ptr指向的对象时，并不会引起这个计数器的增加。</p><h2 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h2><ul><li>C++中的new和delete进行内存的申请和释放，不同于C的malloc和free</li><li>C++可以进行函数重载，C不能</li><li>C++中新增了引用</li><li>c的结构中只有变量，而c++的结构中可以有成员变量和成员函数</li><li>c++是面向对象的，而c是面向过程的。</li><li>C++比C多了一些关键字，如bool、using、namespace等</li></ul><h2 id="C-的直接初始化、拷贝初始化、赋值"><a href="#C-的直接初始化、拷贝初始化、赋值" class="headerlink" title="C++的直接初始化、拷贝初始化、赋值"></a>C++的直接初始化、拷贝初始化、赋值</h2><p>我们先确定一下什么是初始化，什么是赋值操作</p><ul><li><p>初始化就是，<strong>创建变量的时候赋予其初值</strong>（如果使用=号初始化对象就是拷贝初始化，否则就是直接初始化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">string  str1 = <span class="hljs-string">&quot;first&quot;</span>;    <span class="hljs-comment">//拷贝初始化，编译器允许把这句话改写为string str(“first”)，但是string类必须有public的拷贝(移动)构造函数</span><br><span class="hljs-function">string  <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;a&#x27;</span>)</span></span>;     <span class="hljs-comment">//直接初始化</span><br><span class="hljs-function">string  <span class="hljs-title">str3</span><span class="hljs-params">(str2)</span></span>;      <span class="hljs-comment">//直接初始化  -------- 这个不是拷贝，而是直接初始化</span><br>string  str4 = <span class="hljs-built_in">string</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;b&#x27;</span>);  <span class="hljs-comment">//拷贝初始化</span><br>string  str5 = str4;        <span class="hljs-comment">//拷贝初始化</span><br><span class="hljs-function">string  <span class="hljs-title">str6</span> <span class="hljs-params">(<span class="hljs-string">&quot;strr&quot;</span>)</span></span>;       <span class="hljs-comment">//直接初始化</span><br><br>【结论】：上面凡是使用了=号就是拷贝构造函数的调用，没有使用=号就是直接初始化。<br></code></pre></td></tr></table></figure></li><li><p>赋值就是：已经存在了这个变量，我们需要将其当前的值擦除掉，然后赋予新的值</p></li></ul><blockquote><p> 什么时候会出现临时变量呢？</p></blockquote><p>通常在以下三种情况会产生临时对象</p><ul><li><strong>以值传递的方式给函数传值</strong><ul><li>以值的形式传递参数，会调用拷贝构造函数产生一个副本，然后之后都是对这个副本进行操作</li></ul></li><li>类型转换</li><li>函数需要返回一个对象时<ul><li>当函数返回一个对象的时候，就会在栈中创建一个临时对象，用来存储函数的返回值。</li></ul></li></ul><blockquote><p>RVO–<strong>return value optimization</strong></p><p><a href="https://blog.csdn.net/nbu_dahe/article/details/119142610">https://blog.csdn.net/nbu_dahe/article/details/119142610</a></p></blockquote><p>现在的返回值优化手段，可以省去了临时对象的产生。</p><p>如果没有返回值优化，那么就会有临时对象的产生。</p><blockquote><p>例子：明白各个初始化的构造函数的调用</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">P</span>()&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;默认构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">P</span>(<span class="hljs-type">const</span> P&amp; p)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = p.a;<br>        cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">P</span>(<span class="hljs-type">int</span> c)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;a = c;<br>        cout &lt;&lt; <span class="hljs-string">&quot;普通构造&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function">P <span class="hljs-title">f1</span><span class="hljs-params">(P p)</span></span>&#123;<br>    <span class="hljs-function">P <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    P p = <span class="hljs-number">10</span>; <span class="hljs-comment">// 只输出了普通构造    == P p(10);</span><br>    P m = p; <span class="hljs-comment">// 只输出了拷贝构造     == P m(p);</span><br>    <span class="hljs-function">P <span class="hljs-title">d</span><span class="hljs-params">(m)</span></span>; <span class="hljs-comment">// 只输出了拷贝构造</span><br>    P e = <span class="hljs-built_in">P</span>(); <span class="hljs-comment">//  只输出了默认构造  == P e();</span><br>    P f = <span class="hljs-built_in">P</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 只输出了普通构造 == P f(10);</span><br>    <span class="hljs-comment">// P k = f1(f); // RVO (return value optimization) 优化之后，不会产生临时对象了</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h2><blockquote><p>函数重载的条件</p></blockquote><ul><li>函数名必须相同</li><li>函数的参数的顺序、类型、个数满足一个不同就行</li></ul><p>对于函数的返回值可以相同也可以不同，<strong>但是不能作为函数重载的判断条件</strong>。即不能有函数名相同，参数也相同，只有返回值不同的函数重载</p><ul><li><strong>C语言不支持函数重载</strong></li></ul><blockquote><p>函数重写</p></blockquote><p>函数重写是指派生类将基类的名字和参数都相同的虚函数在自己类中进行重新定义，派生类重写的函数必须和父类的对应的虚函数的参数，返回值，函数名称一致。</p><blockquote><p>重载和重写的区别</p></blockquote><p>重载一般是函数水平关系体现，而重写是父类和子类垂直关系的体现。重载要求函数名相同，参数的类型、个数、顺序不同，返回值可以相同也可以不同，但是重写必须是子类重写的父类的虚函数，函数名称、参数、返回值全都相同。</p><h2 id="volatile、mutable和explicit关键字"><a href="#volatile、mutable和explicit关键字" class="headerlink" title="volatile、mutable和explicit关键字"></a>volatile、mutable和explicit关键字</h2><blockquote><p>volatile关键字</p></blockquote><p>用它来修饰变量，表示修饰的变量不希望编译器对访问该变量的代码进行优化，每次都从这个变量的实际内存中读取内容（有时候会将变量缓存在cpu的寄存器中直接访问）</p><p>在多线程中，如果多个线程都对一个变量进行访问，可以将这个变量设置为volatile类型的，每次都是从该变量的实际内存地址进行读取数据而不是读取寄存器中的备份。这个volatile变量修饰的变量能够实现每个线程对其的修改使得别的线程可见。如果不用这个修饰的共享变量，编译器会对一些访问此变量的代码进行优化，可能会将这个变量缓存在cpu的寄存器中，导致自己对这个数据的读取的修改先从寄存器开始，这就会导致实际内存地址的值没有改变，自己线程对此变量的修改没有实现别的线程立即可见。</p><blockquote><p>mutable关键字</p></blockquote><p>它和C++中的const意思相反，在一个const修饰的函数中，这个函数是可以访问和修改这个mutable修饰的变量的。</p><ul><li>在const修饰的函数中，可以修改它修饰的变量</li><li>在const修饰的对象时，可以修改它修饰的变量</li></ul><blockquote><p>explicit关键字</p></blockquote><p>explicit关键字修饰的类的构造函数，是不能发生隐士类型转换的，只能是显示的进行类型转换。</p><blockquote><p>所谓的隐士类型转换，就是当我们的构造函数自由一个参数的时候，我们用一个这个参数的类型的值去初始化一个对象，这个时候会发生<strong>先调用这个构造函数，然后再调用拷贝构造函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> x) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;be invoked&quot;</span>&lt;&lt;endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(A a)</span> </span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 符合隐式转换规则，自动执行隐式转换，符合拷贝构造函数的调用时机（用实参初始化形参）；最终被转换为func(A(1))的形式。</span><br>    A a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 执行了隐式转换，等价于A a(1)；&#x27;=&#x27; 调用了默认拷贝构造函数。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>如果我们用explicit关键字修饰了这个构造函数，就不能够发生隐士类型转换了。</p><ul><li><strong>explicit关键字只能修饰构造函数，并且构造函数的没有默认值的参数个数为1个</strong></li></ul><h2 id="const修饰成员函数的本质"><a href="#const修饰成员函数的本质" class="headerlink" title="const修饰成员函数的本质"></a>const修饰成员函数的本质</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>这个本质是const修饰了this指针，this指针本质是一个指针常量，被const修饰后，它就不能改变指向和通过指针改变所指的内容</strong></p></blockquote><h2 id="C-的string和C的char"><a href="#C-的string和C的char" class="headerlink" title="C++的string和C的char*"></a>C++的string和C的char*</h2><p>C++的string类是继承自basic_string,其实就是对char*的封装，然后增加了容量，长度等属性</p><p>string是可以进行动态扩容的，每次扩容都是申请一块比原来空间2倍大的空间，然后将内容复制过去，然后释放原来的空间。</p><h2 id="C-函数调用的压栈过程"><a href="#C-函数调用的压栈过程" class="headerlink" title="C++函数调用的压栈过程"></a>C++函数调用的压栈过程</h2><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1134295-ce2aa08820b11888.png" alt="img"></p><p>每一个函数在执行的时候，操作系统都会为其在栈空间上维护一个栈帧，栈帧基址存在ebp中，栈顶基址存在esp中，当我们调用一个函数的时候，现在调用函数中从右向左将参数压入栈中，然后接着将eip寄存器中的地址压入到栈中，也就是等会调用完这个函数之后要返回的地址，然后将ebp压入到栈中，然后将ebp更新为esp中的值，形成了新的栈帧，然后eip指向要调用的函数地址，开始执行被调用函数，将临时变量存储在栈中。出栈的时候，就是刚才的逆过程，恢复调用函数的栈帧，将栈中的数据pop到ebp，eip中，恢复调用函数的状态。</p><blockquote><p>对于虚函数来说</p><ul><li>先找到this指针，然后获取这个对象的虚函数表指针，找到虚函数表之后，再找到这个函数的地址</li></ul></blockquote><h2 id="移动构造和移动赋值"><a href="#移动构造和移动赋值" class="headerlink" title="移动构造和移动赋值"></a>移动构造和移动赋值</h2><ul><li>默认构造函数</li><li>拷贝构造函数</li><li>移动构造函数（move和右值引用）</li><li>普通有参构造函数</li></ul><blockquote><p><strong>什么是移动构造函数</strong></p></blockquote><p>介绍这个构造函数之前，我们先了解以下C++11新特性移动语义和右值引用的知识</p><blockquote><p>什么是右值引用</p></blockquote><p>我们之前说的引用都是左值引用，C++11引入了右值引用的概念，就是给右值取别名。左值引用和右值引用都是给变量其别名，只不过两个取别名的对象特性不同。</p><p>【使用】：<code>左值引用是用&amp;，而右值引用使用&amp;&amp;</code></p><p><img src="/2023/04/13/C++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20230401204507804.png" alt="image-20230401204507804"></p><p>举个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a =<span class="hljs-number">10</span>; <span class="hljs-comment">// a是左值，可以取地址和赋值</span><br>    <span class="hljs-type">int</span>&amp; la = a; <span class="hljs-comment">// 左值引用</span><br>    <br>    <span class="hljs-type">int</span> &amp;&amp; ra = <span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// 右值引用，函数返回的值是一个临时变量，是一个右值</span><br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>【总结】：</p><ul><li><p>左值</p><ul><li>普通类型的变量，可以取地址</li><li><code>const修饰的常量</code>，可以取地址，也是变量 const int&amp; a = 100;</li><li>加了const的左值，既可以引用左值，也可以引用右值</li></ul></li><li><p>右值</p><ul><li>纯右值：基本类型的常量或临时变量，如 a+b，10，20这个字面常量</li><li>将亡值：自定义类型的临时对象用完自动析构，如：函数以值的形式返回一个对象</li></ul></li></ul><p>【引用是可以取地址的，对于左值引用来说，取得地址就是变量的地址，对于右值引用来说，取的地址也是右值的地址】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">【左值引用不能给右值取别名，右值引用也不能给左值取别名。】<br> 【左值可以通过<span class="hljs-built_in">move</span>()赋值给右值引用，右值可以在左值加上<span class="hljs-type">const</span>赋值给左值引用--&gt; <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; a  =<span class="hljs-number">100</span>;】<br><span class="hljs-comment">//  int&amp;&amp; c = a;//右值引用不能给左值取别名</span><br><span class="hljs-comment">//  int&amp; d = add(3, 4);//左值引用不能给右值取别名</span><br><span class="hljs-type">int</span>&amp;&amp; e = <span class="hljs-built_in">move</span>(a);<span class="hljs-comment">//当对左值加move的时候可以,这样e就可以改变a的值了</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; f = <span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<span class="hljs-comment">//当对引用加const后可以取别名</span><br><br></code></pre></td></tr></table></figure><blockquote><p>什么是右值引用的移动语义</p></blockquote><p>【<strong>什么是移动语义？</strong>】</p><p><strong><code>移动语义</code> ：就是将一个对象的资源移动到另一个对象中的方式，可以有效的减少拷贝，减少资源的浪费，提高效率。</strong></p><p>我们在进行深拷贝的时候，一般对于对象中的指针变量，我们会重新开辟一块空间，然后将指针指向的内容复制过去，然后将这个新内存的地址赋给新的对象的指针。但是如果对于一个临时变量来说，比如函数返回的临时变量，我们使用深拷贝，就会再开辟新的空间，将临时对象的中指针变量指向的内存复制过去。这样就会在操作中占用较多的空间，我们可以直接进行浅拷贝，然后再将临时对象的指针指向NULL，这样在临时对象被析构的时候就不会释放那个空间，也减少了新空间的开辟，提升了效率</p><p>下面我们就介绍以下什么是移动构造和移动赋值</p><blockquote><p>移动构造和移动赋值</p></blockquote><p>其实就是将上面的移动语义思想应用在构造函数和赋值上面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;&quot;</span>)<br>:_str(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>])<br>, _size(<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">strcpy</span>(_str, str);<br>_str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">String</span>(<span class="hljs-type">const</span> String&amp; s)<br>:_str(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(s._str) + <span class="hljs-number">1</span>])<br>, _size(s._size)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;深拷贝&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">strcpy</span>(_str, s._str);<br>&#125;<br>           <span class="hljs-built_in">String</span>(String&amp;&amp; s)  <span class="hljs-comment">// 移动构造，如果参数是右值的话，就会调用移动构造，而不是调用拷贝构造</span><br>            :_str(s._str)<br>            &#123;<br>                <span class="hljs-comment">// 对于将亡值，内部做移动拷贝</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;移动拷贝&quot;</span> &lt;&lt; endl;<br>                s._str = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>String&amp; <span class="hljs-keyword">operator</span>=(String&amp; s)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;s)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;深拷贝&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> _str;<br>_str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(s._str) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy</span>(_str, s._str);<br>_size = s._size;<br>_str[_size] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>    <br>            String&amp; <span class="hljs-keyword">operator</span>=(String&amp;&amp; s) <span class="hljs-comment">// 移动赋值，如果参数是右值，就会调用移动赋值，不会调用深拷贝赋值</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;移动赋值&quot;</span> &lt;&lt; endl;<br>            _str = s._str;<br>            _size = s._size;<br>            s._str = <span class="hljs-literal">nullptr</span>;<br><br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>        &#125;<br><br>~<span class="hljs-built_in">String</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> _str;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* _str;<br><span class="hljs-type">size_t</span> _size;<br>&#125;;<br><span class="hljs-function">String <span class="hljs-title">func</span><span class="hljs-params">(String&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">String <span class="hljs-title">tmp</span><span class="hljs-params">(str)</span></span>;<br><span class="hljs-keyword">return</span> tmp; <span class="hljs-comment">// 这里也是会调用移动构造进行创建临时对象</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">String <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;123&quot;</span>)</span></span>;<span class="hljs-comment">// </span><br><span class="hljs-function">String <span class="hljs-title">s2</span><span class="hljs-params">(s1)</span></span>;<br><span class="hljs-function">String <span class="hljs-title">s3</span><span class="hljs-params">(func(s1))</span></span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>【总结：】</p><ul><li><strong>对于支持深拷贝的类，我们可以提供移动构造和移动赋值操作</strong></li><li><strong>这样就可以在参数为右值的时候，通过调用移动构造或移动赋值减少深拷贝带来的额外空间分配和复制操作，提升效率</strong></li></ul><p><strong>【<code>对于函数返回值的时候是return temp还是return std::move(temp)呢</code>，如下的类型1和类型2】</strong></p><p><strong>可以直接参考这篇博客<a href="https://blog.csdn.net/dreamvyps/article/details/82467608">https://blog.csdn.net/dreamvyps/article/details/82467608</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 类型一</span><br><span class="hljs-function">std::string <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> str;   <span class="hljs-comment">// 这里编译器会做优化，也是调用了一次移动构造</span><br>&#125;<br> <br><span class="hljs-comment">// 类型二</span><br><span class="hljs-function">std::string <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str); <span class="hljs-comment">// 这里是自己手动进行将左值改成右值，然后调用了移动构造</span><br>&#125;<br> <br><span class="hljs-comment">// 类型三</span><br><span class="hljs-function">std::string&amp; <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str);<br>&#125;<br> <br><span class="hljs-comment">// 类型四：运行期崩溃</span><br><span class="hljs-function">std::string&amp;&amp; <span class="hljs-title">getTimeNowString</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;aaaa&quot;</span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(str);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Moveable</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Moveable</span>():<span class="hljs-built_in">h</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">3</span>)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;construct &quot;</span> &lt;&lt; endl;<br>    &#125;   <br> <br>    ~<span class="hljs-built_in">Moveable</span>() &#123;<br>        <span class="hljs-keyword">delete</span> h;<br>    &#125;   <br>    <br>    <span class="hljs-built_in">Moveable</span>(<span class="hljs-type">const</span> Moveable&amp; m): <span class="hljs-built_in">h</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*m.h)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;   <br> <br>    <span class="hljs-built_in">Moveable</span>(Moveable&amp;&amp; m): <span class="hljs-built_in">h</span>(m.h) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>        m.h = <span class="hljs-literal">nullptr</span>;<br>    &#125;   <br>    <br>    <span class="hljs-type">int</span>* h;<br>&#125;;<br> <br><span class="hljs-function">Moveable <span class="hljs-title">GetTemp</span><span class="hljs-params">()</span> </span>&#123;<br>    Moveable tmp;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    Moveable a = <span class="hljs-built_in">GetTemp</span>(); <span class="hljs-comment">// 我们关闭返回值优化(RVO)，这里会调用一次默认构造函数，两次移动构造函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>还有一种技术是RVO技术，返回值优化技术。对于连续出现拷贝构造函数或者移动构造函数，就会调用一次构造。</p><p><code>-fno-elide-constructors</code>使用这个可以关闭RVO技术。</p><p>【对于RVO和move的关系】</p><ul><li>对于return obj<ul><li>结果就是调用了一次构造和析构，相当于外部对象直接使用了栈的对象</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Obj</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Obj</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;construct \n&quot;</span>);<br>    &#125;   <br><br>    ~<span class="hljs-built_in">Obj</span>() &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;destructor\n&quot;</span>);<br>    &#125;   <br>    <br>    <span class="hljs-built_in">Obj</span>(<span class="hljs-type">const</span> Obj&amp; o) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;copy constructor\n&quot;</span>);<br>    &#125;    <br>&#125;;<br><br><span class="hljs-function">Obj <span class="hljs-title">ReturnObj</span><span class="hljs-params">()</span> </span>&#123;<br>    Obj obj;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    Obj obj = <span class="hljs-built_in">ReturnObj</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>对于return move(obj)<ul><li>结果就是先默认构造，然后调用移动构造，然后调用两次析构</li><li>使用move强制生成了临时对象，但是只是调用了一次移动构造，</li><li>这是因为ROV的结果，如果没有ROV会调用两次移动构造</li></ul></li></ul><p><a href="https://blog.csdn.net/dreamvyps/article/details/97394411?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-97394411-blog-120302300.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-97394411-blog-120302300.235%5Ev27%5Epc_relevant_3mothn_strategy_recovery&utm_relevant_index=3">参考博客</a></p><blockquote><p><strong>move：</strong> 当需要用右值引用引用一个左值时，可以通过move来获得绑定到左值上的右值引⽤。C++11中，std::move()函数位于 头文件中，该函数名字具有迷惑性，它并不搬移任何东西，唯一的功能就是将一个<code>左值强制转化为右值引用</code>，然后实现移动语义。</p></blockquote><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><h2 id="什么是一致性哈希"><a href="#什么是一致性哈希" class="headerlink" title="什么是一致性哈希"></a>什么是一致性哈希</h2><blockquote><p>普通hash会带来什么问题？</p><p><a href="https://blog.csdn.net/a745233700/article/details/120814088">https://blog.csdn.net/a745233700/article/details/120814088</a></p></blockquote><p>普通hash一般在增加和删除一些节点的时候，对于key的映射关系的影响十分大。</p><p>比如我们举一个图片负载均衡缓存中几台服务器中的例子，我们通过普通hash将图片进行hash，然后通过取余，获得这个图片应该存放的位置。如果此时我们将增加一个服务器，那么我们取余的数就变了，之前的映射关系也都没了。如果一台服务器宕机了，我们的余数也发生了变化，这样就会导致映射关系发生变化</p><p>如果想要恢复映射关系，必须将所有的数据都重新映射。</p><blockquote><p>一致性hash</p></blockquote><p>一致性hash就是为了解决在增加或者减少一个节点的时候，能够尽可能的减少key的映射关系的改变</p><p>一致性hash算法将整个hash值空间按照顺时针方向组织成一个虚拟的圆环，然后对节点进行hash。比如我们继续举这个服务器的例子。我们根据服务器的ip进行hash，然后得到在环上的位置。</p><p>然后我们对每个图片hash取余，然后得到在hash环上的位置，得到之后，我们就顺时针的进行在hash环上找，找到第一个遇到的服务器对应的位置，然后就将这个放到指定的服务器中。<strong>如果有一个服务器宕机了，我们可以重新将这些图片hash，然后继续顺时针的找到下一个可以放的服务器，这样我们就不用更改之前已经映射完成的图片了。</strong>如果我们增加了一个节点，也是一样。不用像普通hash那样所有的值都rehash一下。</p><p>【总结】：<strong>一致性hash的优点就是在增加或者减少桶节点的时候，能够尽可能少的减少对已有映射关系的改变。</strong></p><blockquote><p>hash环的缺点：hash环的倾斜</p></blockquote><p>就是节点的分布在hash环上不均匀，节点较少的时候，出现在hash环上局部聚集分布现象，这种现象就是hash环的倾斜。<strong>导致大量的数据存在了一个节点中</strong>。</p><p>因此引入虚拟节点，就是在hash环上，让一个实际的节点对应在hash环上多个位置，这样就能够使得缓存被均匀分布的概率大了些。</p><h2 id="C-从代码到执行经历什么"><a href="#C-从代码到执行经历什么" class="headerlink" title="C++从代码到执行经历什么"></a>C++从代码到执行经历什么</h2><blockquote><p>源代码到可执行程序中间要经历什么步骤</p></blockquote><ul><li>预处理</li><li>编译</li><li>汇编</li><li>链接</li></ul><p>一般一个C/C++程序到可执行程序都要经历这几个阶段</p><blockquote><p>预处理：</p><ul><li>将所有的宏定义指令进行文本替换操作</li><li>对条件编译指令进行处理</li><li>处理所有的include指令，将文件内容复制到它所在的地方。</li><li>删除所有的注释</li><li>添加行号和文件标识，方便调试和编译错误时显示行号</li></ul></blockquote><blockquote><p>编译：</p><ul><li>将预处理完成的文件进行一系列的词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件</li><li>优化包括循环优化，还有就是利用寄存器存放有关变量的值进行访问优化，因为寄存器的速度远大于内存的访问速度。但是如果假如volatile不会产生访问优化。</li></ul></blockquote><blockquote><p>汇编：</p><ul><li>将汇编代码转换成目标机器指令的过程，最总得到一个目标文件。</li><li>目标文件中至少有两个段，代码段和数据段</li></ul><p>在unix中，主要有三种类型的目标文件</p><ul><li>可重定位文件：这个文件中包含了适合其他的目标文件链接来创建一个可执行或者共享的目标文件的代码和数据</li><li>共享的目标文件：这种文件存放了适合于在两种上下文里链接的代码和数据。第一种事链接程序可把它与其它可重定位文件及共享的目标文件一起处理来创建另一个目标文件；第二种是动态链接程序将它与另一个可执行文件及其它的共享目标文件结合到一起，创建一个进程映象。</li><li>可执行文件：它是一个可以被操作系统识别和当作一个进程来运行的文件</li></ul></blockquote><blockquote><p>链接：</p><p>我们单独来说一下这个链接</p></blockquote><h2 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h2><h2 id="几种典型的锁"><a href="#几种典型的锁" class="headerlink" title="几种典型的锁"></a>几种典型的锁</h2><blockquote><p>互斥锁：互斥锁保证一次只能有一个线程获取互斥锁，获取锁的线程才能执行某些动作，即对共享变量进行修改。</p><ul><li>一个线程在抢夺互斥锁的时候，如果没有获取到互斥锁，就会放弃CPU进入睡眠状态，等到锁的状态发生改变后，操作系统调度到这个线程进而获取这个互斥锁。</li><li>常用的互斥锁 mutex</li></ul></blockquote><blockquote><p>条件变量：condition_valuable</p><ul><li>条件变量一般配合互斥锁使用，用来实现多线程之间的同步效果</li><li>当一个线程不满足一定条件的时候，会使用条件变量来阻塞这个线程，释放互斥锁，而不是一直循环的判断条件是否满足</li><li>当一个线程更改了条件之后就会利用这个条件变量来唤醒正在阻塞的线程</li></ul></blockquote><blockquote><p>自旋锁：</p><ul><li>自旋锁就是在互斥锁锁的基础上，如果一个线程没有获取到这个锁，那么就会一直循环的去申请获取，一直到获取到锁或者线程的时间片使用完毕</li><li>一般可以适当的自旋有利于锁的获取。</li></ul></blockquote><blockquote><p>信号量和互斥锁和条件变量的区别</p><p><a href="https://blog.csdn.net/weixin_53762042/article/details/119704477">https://blog.csdn.net/weixin_53762042/article/details/119704477</a></p></blockquote><p>【互斥锁】</p><ul><li>他是为了保护共享资源某一时刻只能被一个线程操作，一个线程获取了互斥锁，另外的线程就无法获取了，只有当这个线程释放这个锁，其他线程才有机会获取，并且互斥锁的释放只能由获取它的线程释放。</li></ul><p>【信号量】</p><ul><li>信号量更多的是用于线程或进程间的同步操作，信号量的本质是一个非负的整数计数器，用来控制对公共资源的访问。只要信号量大于0，其他的线程就可以进行操作其控制的共享资源。</li></ul><p>信号量可以用来互斥也可以用来同步操作；对信号量+1可以称为P操作，对信号量-1可以称为V操作</p><ul><li>互斥操作：<ul><li><strong>一般只设置一个信号量</strong>，相当于互斥锁的加强版，当信号量只取0和1的时候，就相当于互斥锁</li><li>信号量的获取和释放都由一个线程完成</li></ul></li><li>同步操作<ul><li><strong>一般设置多个信号量</strong>，在一个线程中我们可以对一个信号量进行P操作，然后对另一个信号量进行V操作，这样就能使得其他正在等待第二个信号量的线程能够获取信号量进行P操作</li><li>一个线程可以对一个信号量进行P操作，对另一个信号量进行V操作</li></ul></li></ul><p>【条件变量】</p><ul><li>条件变量一般配合互斥锁使用，实现线程同步的功能，和信号量的功能基本一致，但是条件变量可以唤醒所有正在等待的线程’</li><li>条件变量一般是一个线程因为某个条件不成立会挂起这个线程，然后等待别的线程修改条件使得条件成立并唤醒等待的线程。条件的检测是在互斥锁的保护下进行的，当条件为假的时候就会挂起这个线程处于阻塞状态，然后等待别的线程修改条件成立并唤醒自己，获取互斥锁重新判断条件。</li></ul><p>c++中通过互斥锁和条件变量可以实现和C中的信号量相同的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议</title>
    <link href="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><h3 id="七层模型主要分为"><a href="#七层模型主要分为" class="headerlink" title="七层模型主要分为"></a>七层模型主要分为</h3><p>四层模型主要分为数据链路层、网络层、运输层、应用层</p><p>物理层：主要是用来基于传输介质实现比特流的传输</p><p>数据链路层：负责建立和管理节点间的链路。能够将从物理层接收到的数据进行检查错误和打包成数据帧，然后基于MAC地址进行寻址，主要设备有网卡、交换机等</p><p>网络层：他会检查每一帧的数据，然后选择合适的网间路由和交换节点，确保数据的及时传送，将从下层接收到的数据进行ip地址的封装和解封装。这一层的数据称为数据包，主要涉及设备有路由器</p><p>传输层：这一层主要是定义了一些数据传输的协议，负责端到端的数据传输，如TCP/UDP协议，主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组，这一层数据叫做段。</p><p>应用层：该层直接向用户进程提供服务，这一层包含的协议有http协议，FTP协议等</p><h3 id="TCP-IP四层参考模型"><a href="#TCP-IP四层参考模型" class="headerlink" title="TCP/IP四层参考模型"></a>TCP/IP四层参考模型</h3><ul><li>应用层：应用层主要负责各种不同应用之间的协议，比如http协议、smtp协议等。</li><li>传输层：传输层主要负责可靠传输的TCP协议、高效传输的UDP协议。主要是传输应用层的数据包。</li><li>网络层：负责寻址的IP协议。网络层可以进行网络连接的建立和中止以及IP地址的寻址功能</li><li>网络接口层：主要负责将数字信号在物理通道中的准确传输。</li></ul><blockquote><ul><li>网络接口层：这一层主要负责数据在主机和网络之间的交换，它和OSI参考模型中的物理层和数据链路层相对应。同时它实现网卡接口的网络驱动，以处理数据在以太网线等物理媒介上的传输。</li><li>网络层：网络层负责实现数据包的选路和转发。将从下层接收到的数据进行ip地址的封装和解封装，然后选择合适的网络路由和交换节点进行数据包的转发。</li><li>传输层：这一层主要负责数据端到端的传输，这一层定义了两个协议，一个是面向连接的传输控制协议TCP和一个高效传输的UDP协议</li><li>应用层：应用层主要负责各种不同应用之间的协议，比如HTTP协议，smtp协议等</li></ul><p><strong>数据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等。</strong></p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p><a href="https://www.cnblogs.com/YouJeffrey/p/15334068.html">https://www.cnblogs.com/YouJeffrey/p/15334068.html</a></p><blockquote><p>HTTP协议的组成：</p></blockquote><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/2432200-20210925120910224-253956630.png" alt="img"></p><h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><h5 id="请求行："><a href="#请求行：" class="headerlink" title="请求行："></a><strong>请求行：</strong></h5><ul><li><code>请求方法post/get</code>、<code>URL字段</code>、<code>HTTP协议版本字段</code></li></ul><h5 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a><strong>请求头：</strong></h5><ul><li>Host: 请求的主机名</li><li>User-Agent：产生请求的浏览器类型</li><li>Accept：客户端可识别的内容类型列表</li><li>cookie字段</li><li>……</li></ul><h5 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a><strong>请求正文</strong></h5><ul><li>get请求的内容在URL字段后面</li><li>post请求在请求正文body里</li></ul><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><h5 id="相应行"><a href="#相应行" class="headerlink" title="相应行"></a>相应行</h5><p><code>响应状态码</code>(404,200这些)、<code>响应信息</code>、<code>HTTP版本</code></p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><ul><li>Content-Length：表示内容长度</li><li>Content-Type: 表示后面的文档格式类型</li><li>Server：表示服务器类型</li><li>…..</li></ul><h5 id="相应正文"><a href="#相应正文" class="headerlink" title="相应正文"></a>相应正文</h5><p>响应正文：就是响应的消息体</p><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p>HTTP协议是信息明文传输，存在安全风险的问题，HTTPS则解决了HTTP协议不安全的缺点，通过在TCP和HTTP协议网络层之间加入了SSL/TLS安全协议，使得报文加密传输</p><p>HTTPS在TCP三次握手之后还要进行SSL/TLS的握手过程，才能进行加密报文的传输</p><p>HTTP默认端口是80,而HTTPS默认的端口是443</p><h3 id="HTTP1-1-2-3的区别"><a href="#HTTP1-1-2-3的区别" class="headerlink" title="HTTP1.1/2/3的区别"></a>HTTP1.1/2/3的区别</h3><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230328160911584.png" alt="image-20230328160911584"></p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230328160939384.png" alt="image-20230328160939384"></p><h2 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP/UDP"></a>TCP/UDP</h2><h3 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h3><p>进程的信息交付和传输都是通过socket套接字完成的，套接字也是完成多路复用和分解的</p><p>当进程使用网络传输的时候，会生成一个套接字，并将这个套接字交给操作系统内核维护，套接字会绑定每个进程的，得到了指定的套接字就能够知道指定的进程。</p><ol><li>每个套接字有唯一的标识</li><li>消息报文段有特殊的字段来指示该报文段所要交付的套接字</li><li>这些特殊字段包括了源端口号字段和目的端口号字段</li></ol><blockquote><p>运输层分解服务的基本流程</p></blockquote><p>在主机上每个套接字都能够分配一个端口号，当有报文来到主机的时候，我们会提取出报文段的目的端口号，然后找到指定的绑定该端口号的套接字，并把这个报文内容给到套接字，然后数据就会通过这个套接字进入到了进程当中。</p><h4 id="1-无连接的多路分解"><a href="#1-无连接的多路分解" class="headerlink" title="1. 无连接的多路分解"></a>1. 无连接的多路分解</h4><p>一个udp的套接字是由一个二元组标识的，也就是只需要目的端口号和目的ip，因为udp不需要建立连接，所以，假如有数据报来到了主机，直接看这个报文对应的目的端口号和ip对应的套接字，然后将数据给到这个套接字就行，这个套接字可以让很多的不同源ip和端口号的来使用。</p><blockquote><p>补充：当我们开启一个线程之后，这个套接字就生成了，后面不会生成对应端口号的套接字</p><p>如果是udp连接，那么就可以一个主机给多个主机发送数据，但是tcp不行，因为要建立一对一的连接。</p></blockquote><h4 id="2-面向连接的多路分解"><a href="#2-面向连接的多路分解" class="headerlink" title="2. 面向连接的多路分解"></a>2. 面向连接的多路分解</h4><p>一个tcp的套接字是由四个二元组标识的，因为tcp在传输内容的之前需要建立连接，这个建立连接就是在服务器端创建一个四元组的套接字，包括源ip和端口号，以及目的IP和端口号。也就是说和服务器进行数据传输的都是通过各自的套接字，但是这些套接字都是针对于同一个进程而言的。</p><blockquote><p>补充：每一个连接的socket都是维护的连接状态，如果后面连接断开，就会把这个socke给删除</p></blockquote><h3 id="UDP–无连接运输"><a href="#UDP–无连接运输" class="headerlink" title="UDP–无连接运输"></a>UDP–无连接运输</h3><p>针对于无连接，主动权是在自己，我想发送就行，至于对面有没有收到我不管。</p><h4 id="1-udp报文段结构"><a href="#1-udp报文段结构" class="headerlink" title="1. udp报文段结构"></a>1. udp报文段结构</h4><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20220915142213404.png" alt="image-20220915142213404" style="zoom:50%;"><h4 id="2-字段：校验和"><a href="#2-字段：校验和" class="headerlink" title="2. 字段：校验和"></a>2. 字段：校验和</h4><p>用来检查这个报文段是否出现错误。</p><p>将所有要发送的数据进行相加，然后取反码就得到了所谓的校验和</p><p>然后在接收端通过校验和再和所有的数据相加，得到了结果如果不是FFFF那么就出现了错误在传输过程中。</p><p><strong>但是udp对于差错是无法进行恢复的，他最多就是将这个出了错的报文段给丢弃掉，或者给出一个警告。</strong></p><h3 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h3><h4 id="停等协议"><a href="#停等协议" class="headerlink" title="停等协议"></a>停等协议</h4><blockquote><p>可靠数据传输协议 –reliable data transfer protocol         rdt</p></blockquote><p>rdt1.0 - rdt3.0 停等协议</p><p>这一块看书</p><h4 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h4><p>rdt3.0协议是一个功能正确的协议，但是他的性能不好，因为他需要每次发送一个数据之后要停下来等待这个数据的发送结果，然后再发送第二个数据。所以性能不好。</p><p>然后流水线协议就是我一直发，我不等你回来，我先发过去再说，如果发送过程出错了我再回到出错的地方通过手段解决出错的地方</p><blockquote><p>流水线协议带来的影响</p></blockquote><ol><li><p>必须添加序号范围，因为每个输送中的分组（不计算重传的）必须有一个唯一的序号，而且也许有多个在传输中的未确认报文</p></li><li><p>协议的发送方和接收方也许不得不缓存多个分组。发送方的最低限度应当缓存那些<strong>已发送但是还没有进行确认的分组</strong>，<strong>然后接收方也许要缓存那些已经接收成功的分组</strong>。</p></li><li><blockquote><p>所需序号范围和对缓冲的要求<strong>取决于数据传输协议如何处理</strong>丢失、损坏以及延时过大的分组</p><p>解决流水线的差错恢复有两种基本方法：</p><ol><li>回退N步（go-back N）（GBN）</li><li>选择重传（即选择性的重传）（selective repeat） （SR）</li></ol></blockquote></li></ol><p>下面我们就来介绍这两个协议的具体实现方法</p><h4 id="回退N步（GBN）–滑动窗口协议"><a href="#回退N步（GBN）–滑动窗口协议" class="headerlink" title="回退N步（GBN）–滑动窗口协议"></a>回退N步（GBN）–滑动窗口协议</h4><p>在回退N步协议中，我们允许多个分组同时进行传输，不需要确认等待，但是他的发送也受限于在流水线中未确认的分组数不能超过某个最大允许数N</p><blockquote><p>对于发送方</p></blockquote><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20220915152545163.png" alt="image-20220915152545163"></p><p>32 - 45都是已经发送出去的数据了，但是接收端还没有发送ack确认</p><p>如果收到了32号的ack32确认，那么滑动窗口向右移动，52就可以纳入发送窗口内</p><blockquote><p>对于接收方</p></blockquote><p>因为发送发发送了32-45的报文，然后假如32-38的报文都没了，这个时候来了一个39的报文，然后将39报文交给调用端，调用端会判断这个序号和我上次接收的序号是不是挨着的，接收端上次接受了31，他想要32，但是给了39，他就会丢弃这个39号，并且继续发送ack31，让发送端继续给我发送32，这就是回退到最开始。</p><blockquote><p>GBN发送方的响应的三个事件</p></blockquote><ol><li>上层调用–就是开始发送</li><li>收到ack编号，这个是接收方发送过来的，接收方只会发送已经接收成功连续的最大ack编号。</li><li>超时事件： 如果发生超时了，就会重新发送所有已经发送但是没有确定的分组，对于发送成功并确认的删除定时器</li></ol><h4 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传  SR"></a>选择重传  SR</h4><blockquote><p>选择重传就是选择性的传那些超时和丢失的分组，GBN是直接最小的未确认以及之后的的重传，SR不是，SR会在接收方和发送方都有一个窗口用来缓存发送成功和乱序接收的分组</p></blockquote><p>在发送方有一个大小为N的窗口，这个窗口里面包含发送未确认的，发送确认的和，未发送的</p><p>在接收方也有一个大小为N 的缓存窗口，这个窗口用来临时存储乱序到达的分组。</p><blockquote><p>流程</p></blockquote><p>当发送方开始将窗口内的数据进行发送的时候，然后接收方会将乱序到达的分组给放到自己的窗口内，如果这个窗口的rcv_base确认了，那么就会从这下标开始遍历窗口，将已经确认收到的分组交给进程。</p><p>对于接收方比较简单，就是维护一下已经到了的分组，对于发送方来说，什么时候才会发生窗口的滑动呢？</p><p>假如2号分组在发送过程丢失了，然后窗口大小是4，但是ack3和ack4，ack5都收到了，但是没有收到ack2，那么就会就不会发生窗口移动，然后就会触发2号分组的重发机制，将重新发送分组2，这个时候因为窗口满了，所以不会发生其他的数据发送，</p><p>重发之后，接收方接到了2号分组，就会先滑动自己的窗口到6，将2，3，4，5都交付给进程，然后当发送方也收到了ack2，就会移动窗口到6，这个时候就可以发6，7，8，9分组了。</p><blockquote><p>假如上述的2号分组接收方确认了，也发送了ack但是，这个ack丢失了，并且接收方已经滑动了窗口，这个时候2号分组再次重发，<strong>但是再接收方的窗口内没有这个序号了，但是还是会重新发送一次ack2</strong>，这个就是避免这个情况发生的</p></blockquote><h3 id="TCP–面向连接的运输"><a href="#TCP–面向连接的运输" class="headerlink" title="TCP–面向连接的运输"></a>TCP–面向连接的运输</h3><p><strong>上面的协议都是为了tcp准备的，因为udp是单向的，根本就接收不到ack</strong></p><h4 id="Tcp报文段结构"><a href="#Tcp报文段结构" class="headerlink" title="Tcp报文段结构"></a>Tcp报文段结构</h4><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20220915163919069.png" alt="image-20220915163919069" style="zoom:50%;"><blockquote><p>32比特的序号字段sequence number field</p><p>32比特的确认号字段 acknowledgement number field</p></blockquote><p>这个使用给分组标号的，因为我们前面讲了要给分组标号的，并且ack也要编号，才知道是那个分组被正确接受了了</p><blockquote><p>16比特的接收窗口字段（receive window field）</p></blockquote><p>这个字段是用来流量控制的，指示该接收方愿意接受的字节数量</p><blockquote><p>4比特的首部长度字段</p></blockquote><blockquote><p>6比特的标志字段</p></blockquote><h4 id="序号和确认号"><a href="#序号和确认号" class="headerlink" title="序号和确认号"></a>序号和确认号</h4><blockquote><p>序号</p></blockquote><p>这个序号不是报文段的序号，而是第n各报文段的第一个字节的序号</p><p>因为刚开始会给所有的字节进行编号，然后取每个报文段的第一个字节的编号作为序号</p><blockquote><p>确认号</p></blockquote><p>确认号就是我这个主机想要你发送过来的字节的编号</p><p>假如A已经收到了555前面的字节，那么他就会在确认号中添加556</p><blockquote><p>累积确认</p></blockquote><p>假如主机收到了0-567字节编号的报文段，900-1000字节编号的报文段，但是没有收到中间的，那么主机会在确认号中加入568，不是1001，这个叫做累积确认，但是那个失序到达的数据是否留下来，根据TCP编程实现人员来定</p><h4 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h4><h5 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h5><p>当在一定的事件没有收到确认ack就重新发送ack</p><blockquote><p>累积确认可以避免一定的超时重传</p><p>比如两个报文都成功发送了，但是第一个ack没有回来，但是在超时间隔内，第二个ack回来了，因为是累积确认说明都收到了，就不用重传。</p></blockquote><h5 id="快速重传–冗余ack"><a href="#快速重传–冗余ack" class="headerlink" title="快速重传–冗余ack"></a>快速重传–冗余ack</h5><p>因为tcp是累积式的，所以假如几个报文发送出去后，但是第一个报文丢失了，那么接收端就会发送第一个报文的ack1，然后后面几个报文都到了，也返回了ack1，（因为是累积式的），所以发送端会重复收到多个ack1，如果这个时候还没有发生超时，那么就会快速重传</p><h5 id="GBN还是SR？"><a href="#GBN还是SR？" class="headerlink" title="GBN还是SR？"></a>GBN还是SR？</h5><p>TCP使用的可靠传输协议其实更偏向于GBN，但是是改版的GBN，因为在接收方缓存了乱序到达的报文段，但是这种会带来很多的不必要的重传，所以也有GBN和SR混合的，就是选择的重传。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><blockquote><p>udp没有流量控制</p></blockquote><p>所谓的流量控制就是有一个缓冲区，防止发送方发的太快，进程B会将当前未使用的缓存空间（这是什么意思呢？就是进程B读取这个缓冲区比较慢，但是他已经接收到A进程发来的数据，也发送了确认给A进程，但是由于自己读取缓冲区慢，导致自己的缓冲窗口变小了，所以要让A进程下次别发太多数据了）记录在TCP报文中发送给进程A，进程A根据这个调整自己的窗口大小，来防止发送过多数据导致了B服务端的缓冲区溢出</p><h4 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h4><p>三次握手–四次挥手</p><h5 id="建立连接–三次握手"><a href="#建立连接–三次握手" class="headerlink" title="建立连接–三次握手"></a>建立连接–三次握手</h5><blockquote><p>第一步</p></blockquote><p>客户端的TCP首先向服务端TCP发送一个特殊的报文段，这个报文段不包含任何应用层数据，但是</p><p>SYN标志位被置为1，</p><p>并且客户端随机生成选择一个序号seq（client_isn），然后将这个序号放进SYN报文段的序号中，然后发送给服务端</p><p>然后进入syn_sent状态</p><blockquote><p>第二步 –服务端到底有没有用分配资源？（答案是没有–<strong>目的就是防止SYN泛洪攻击</strong>）</p></blockquote><p>服务端接收到这个SYN报文段的时候，开始进行解析</p><p>为TCP连接分配TCP缓存和变量(可能会造成SYN泛洪攻击，所以在第三次握手才分配)</p><p>然后向客户端发送允许连接的报文段</p><p>这个报文段也不包含任何应用层数据，SYN标志位还是1，然后TCP的确认序号（ack）是client_isn+1，</p><p>并带上自己的初始序号（server_isn）,这个报文段称为SYNACK报文段</p><p>然后进入syn_rcvd状态</p><blockquote><p>第三步 双方都建立连接状态</p></blockquote><p>客户端收到SYNACK报文段之后，就开始分配缓存和变量</p><p>然后进入到ESTABLISHED阶段</p><p>并向服务器发送另一个报文段，</p><p>这个报文段是对服务器允许连接的确认，将确认序号置为server_isn+1，并把SYN置为0</p><p>这一次是可以携带应用层的数据的。</p><p>服务端接收到ACK报文后，也进入了ESTABLISHED状态，然后分配资源用来接收数据。</p><blockquote><p>流程图</p></blockquote><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20220916104925813.png" alt="image-20220916104925813"></p><h5 id="为什么要进行三次握手"><a href="#为什么要进行三次握手" class="headerlink" title="为什么要进行三次握手"></a>为什么要进行三次握手</h5><blockquote><p>1.阻止历史连接 </p></blockquote><p>第一种情况：在一次连接中，假如客户端发送一个连接请求后宕机了，然后这个请求到达之后就建立连接状态（两次连接），一旦建立连接状态就会发送数据给客户端，但是客户端宕机了，就不会收到，造成资源浪费。</p><p>第二种情况：客户端发送请求宕机后又恢复了，然后又再次发送了请求，但是SYN字段的client_isn是随机生成的，所以不会和第一次一样。最开始那个连接到达之后，假如直接就建立连接状态，就开始发送数据给客户端，但是客户端的想要的报文段的确认序号是第二次生成的client_isn+1而不是第一次的client_isn+1.但是这个回来的是第一次的，所以客户端就会判断这个连接不是自己的，就会发送一个RST字段断开，但是这个时候两次连接已经发送数据过来了，所以造成资源的浪费。但是三次连接就不会这样，因为只有在服务端第三次的握手成功后才会建立连接并发送数据，不会造成资源的浪费，也不会建立历史连接，当客户端收到的确认字段不匹配的时候，直接发送RST，并且服务端也不会发送数据过来，不会造成浪费。第二次握手的时候会在服务端维持半连接状态，第三次才会全连接状态</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/format,png.png" alt="三次握手避免历史连接"></p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/fe898053d2e93abac950b1637645943f.png" alt="两次握手无法阻止历史连接"></p><blockquote><p>2.两次连接造成资源浪费</p></blockquote><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/format,png-16632985302645.png" alt="两次握手会造成资源浪费"></p><blockquote><p>3.四次握手没必要</p></blockquote><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/format,png-16632985962098.png" alt="四次握手与三次握手"></p><h5 id="为何随机化client-isn"><a href="#为何随机化client-isn" class="headerlink" title="为何随机化client_isn"></a>为何随机化client_isn</h5><blockquote><ul><li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；<ul><li>因为四元组包含源ip端口号和目的IP和端口号，都是会找到指定的socket</li><li>找到了socket就会接收数据</li></ul></li><li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li></ul></blockquote><p>假如，每一个客户端的发送的client_isn都是从0开始，当建立连接之后，客户端开始发送报文数据，假如一个报文段的seq = 101，但是此时这个报文段被阻塞了，然后这个时候服务器宕机了，然后重启之后，客户端和服务端建立连接，然后这个时候那个之前阻塞的报文段到了，并且恰好落入了服务端的接收窗口内，就会接收这个历史数据。</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/isn%E7%9B%B8%E5%90%8C.png" alt="img"></p><blockquote><p>如果采用了随机化client_isn</p></blockquote><p>很大程度就避免了所谓的历史数据被接收的情况</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/isn%E4%B8%8D%E7%9B%B8%E5%90%8C.png" alt="img"></p><h5 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a>断开连接–四次挥手</h5><blockquote><p>第一步</p></blockquote><p>首先客户端发送一个全开连接的请求，发送一个特殊的报文段，这个报文的标志位FIN被置为1</p><blockquote><p>第二步  （第一步到这一步属于FIN-WAIT1阶段）</p></blockquote><p>服务端接收到这个报文段的时候，立即返回一个报文段ack确认</p><blockquote><p>第三步   （第二步到这一步属于FIN-WAIT2阶段）</p></blockquote><p>过了一段时间（这段时间就是为了给服务端处理那些之前的请求数据），服务端就告诉客户端我这边你发我的数据已经全部处理完成了，然后发送一个fin报文段给客户端。</p><blockquote><p>第四步    (第三步到这一步属于Time-Wait阶段)</p></blockquote><p>客户端接收到服务端发送来的ACK和FIN报文段之后，就发送一个ACK报文段告诉服务端你可以断开了。但是客户端不马上断开，等待一定时间断开，因为可能这个ack失败了，服务端会重发FIN，要保证服务端能够顺利断开才结束（就是在Time-wait阶段收不到FIN了，就认为服务端断开了）。</p><p>服务端断开后会将4元组给删除掉。</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/format,png-166330086821815.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>TCP必须使用的是端到端拥塞控制，而不是使用网络辅助的拥塞控制</p><p>TCP采用的方法是让每一个发送方根据自己所能感知的网络拥塞程度来限制自己的发送速率</p><ul><li>如果一个TCP发送方感知自己从他的目的地之间的路径没有拥塞，他就会增加自己的发送速率</li><li>如果感知到了有拥塞，就会降低自己的发送速率</li></ul><blockquote><p>TCP拥塞控制算法</p></blockquote><ol><li>慢启动</li><li>拥塞避免</li><li>快速恢复</li></ol><blockquote><p>感知拥塞</p></blockquote><p>如果发送方超时或者接收到3个重复ACK，发送方就认为在发送方到接收方的路径上出现了拥塞指示。</p><h5 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h5><p>当刚开始建立连接之后，cwnd的值通常初始设置为1MSS。每个Mss当收到确认后就会增加一个Mss，相当于以指数形式增长。</p><blockquote><p>什么时候结束慢启动增长呢</p></blockquote><ol><li>如果存在了一个超时指示的丢包事件（认为产生拥塞），<strong>这个时候会直接把拥塞窗口设置为1</strong>，然后把慢启动阈值（ssthresh）设置为刚才产生拥塞时的拥塞窗口的一半。</li><li>慢启动结束的第二种方式就是直接和慢启动阈值有关，当慢启动拥塞窗口超过了慢启动阈值后就会停止慢启动方式，从而进入拥塞避免阶段，当进入拥塞避免阶段后，TCP会很谨慎的增加拥塞窗口值。</li><li>第三种结束慢启动的方式是，如果检查到了三个冗余的ACK，TCP发送方肯定会快速重传进入快速恢复阶段。</li></ol><h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h5><p>一旦进入拥塞避免阶段，那么拥塞窗口的大小就会变成大概上次遇到拥塞时候的一般，此时将采用一种比较保守的方式进行增加拥塞窗口的大小，每个RTT只增加一个MSS。这个如何实现呢？</p><p>一种通用的方法是对于TCP无论何时到达一个新的确认，就将拥塞窗口增加一个MSS。例如在一个RTT内发送了10个报文段，每个ACK到达后都只增加1/10个MSS大小。</p><blockquote><p>什么时候结束拥塞避免阶段呢？</p></blockquote><ol><li>当出现超时时，<strong>就会直接把拥塞窗口设置为1</strong>，并且把慢启动阈值设置为出现拥塞时的窗口大小变为一半，然后<strong>继续慢启动</strong></li><li>当接收到3个冗余ACK时，<strong>拥塞窗口大小设置为之前的一半</strong>，将慢启动阈值设置为拥塞窗口的一半，然后<strong>进入快速恢复阶段。</strong></li></ol><h5 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h5><p>一般时接收到了3个冗余的ack触发的，这个时候会将拥塞窗口大小设置为一般，<strong>然后对收到的每个冗余ACK，窗口大小都会增加1个MSS</strong>，但是如果收到了非冗余ACK，那么就开始进入拥塞避免阶段了，每个RTT只增加一个MSS。</p><blockquote><p>如何结束快速恢复阶段</p></blockquote><p>超时的时候就会进入慢启动阶段，拥塞窗口变为1，阈值变为一半</p><p>冗余ACK进入快速恢复阶段（这个时候已经进入了拥塞避免阶段）</p><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>首先先进入慢启动过程，接收到一个ack就增加一个MSS，然后如果发送方超时或者接收到3个冗余ACK，那么就会认为发生阻塞，然后将阈值设为发生阻塞的时候的一半，然后拥塞窗口大小设为1，然后继续进入慢启动阶段，如果到达阈值之后，就会进入拥塞避免阶段，一个RTT时间内增加一个MSS，然后如果遇到了超时或者3个冗余ACK就会放生状态变化，超时会进入到慢启动阶段，窗口设为1，然后阈值减半，然后继续重复之前的；如果3个冗余ACK就会进入快速恢复阶段，这个阶段会将阈值减半，然后遇到一个冗余ACK就增加一个MSS，直到接收到非冗余ACK进入拥塞避免阶段，超时就会进入慢启动阶段。</p><h3 id="URL解析过程"><a href="#URL解析过程" class="headerlink" title="URL解析过程"></a>URL解析过程</h3><p>首先将url解析成协议、网络地址、资源路径，然后根据网络地址请求DNS服务器，先请求本机上的DSN有没有缓存过，如果有的话直接返回ip地址，如果没有则向外部DNS服务器解析域名。</p><p>获得IP地址后，我们还需要获得端口号，http协议的默认端口号是80，然后根据这个ip地址和端口号，我们就去建立TCP连接，TCP连接是三次握手方式，首先发送方会发送一个SYN报文给服务端，这个报文的序列号是随机初始化的，syn标志位为1 ，然后服务端接收到之后，就会发送一个synack报文告诉发送方我接收到了，之后客户端接收到这个synack报文段后就会发送一个ack报文段给服务端，服务端接收到ack报文后就分配资源并建立连接，然后就可以发送http报文段了，开始向服务端进行发送http请求了，然后客户端对接收的数据渲染到浏览器，当数据接收完成之后就会断开TCP连接，这个断开连接方式是四次挥手，客户端先发送一个fin字段给服务端，服务端接收到之后，就发送一个ack字段给客户端，然后一段时间后再发送一个fin字段给客户端，客户端接收到fin字段后就发送一个ack字段给服务端，然后进入timewait阶段，然后服务端接收到ack字段后就会断开连接，客户端在结束timewait阶段后也断开了连接。</p><blockquote><p><strong>第一步：</strong>获取URL中的域名，然后根据此域名去DNS域名解析器中查询域名对应的IP地址，首先先去本地DNS中查询是不是有此域名的缓存，如果有直接返回对应的IP，如果没有，那么就在本地DNS中获取根域名服务器地址，然后请求根域名服务器，然后在根域名服务器找到对应的顶级域名服务器，然后再找到对应的权威域名服务器，找到了权威域名服务器后然后就能能够获取到对应域名的IP地址，然后将这个IP地址返回给客户端。</p></blockquote><blockquote><p><strong>第二步</strong>：当我们获取到服务端的IP地址后，我们开始解析URL并构建HTTP请求报文，在http请求报文中，主要包含三个部分，分别是http请求行、http请求头、http请求体。请求行中主要包含http协议版本，URL，请求方法。请求头中包含一些属性信息，请求的主机名，客户端接受的内容类型，cookie字段等。请求体中包含了此次请求的真正内容。GET的请求内容在URL中，POST的请求内容在请求体中。</p></blockquote><blockquote><p><strong>第三步</strong>：构建完成http请求报文后，因为http协议是基于TCP协议实现的，TCP是面向连接的可靠传输协议。所以先建立客户端和服务端的连接，采用的是三次握手方式。具体流程是：客户端先发送一个SYN报文段给服务端，发送序号是随机生成的，TCP头部的SYN标志位置1，然后客户端进入了SYN_SENT状态；当服务端接收到SYN报文之后，然后发送一个SYNACK报文段给客户端，表示自己收到了SYN报文，然后进入SYN_RCVD状态；客户端收到这个SYNACK报文段后，然后再发送一个ACK报文段给服务端，然后进入到ESTABLISHED阶段，服务端收到ACK报文段后也进入到ESTABLISHED阶段。自此，客户端和服务端的连接建立完成。</p><p>将http报文头部加上TCP报文头，如果http数据包很大，超过了MSS，就分割成多个进行发送。</p></blockquote><blockquote><p><strong>第四步</strong>：构建完成TCP报文段之后，然后再加上IP头部，IP头部中包含了源主机IP和目标主机IP</p></blockquote><blockquote><p><strong>第五步</strong>：构建完成IP报文之后，在IP数据包的前面再加上MAC头部，MAC地址头部也是包含了发送方和接受方的MAC地址。MAC地址是固定的，它位于网卡之中的ROM区域中，出厂时就初始化完成了。但是接收方的MAC如何获取呢？采用ARP协议，先查询自己缓存中有没有接收方IP对应的MAC地址，如果没有就广播一下来获取接收方IP对应的MAC地址。</p></blockquote><blockquote><p><strong>第六步</strong>：构建完成报文之后，然后交给网卡驱动程序，然后网卡驱动程序将数据写入到网卡的缓存区，然后将数据转换为电信号通过网线传输出去。</p></blockquote><blockquote><p><strong>第七步</strong>：首先是经过交换机，交换机中维护了MAC地址和端口的对应关系表，将数据发送到交换机后，就可以根据报文中的目的MAC地址选择对应的端口发送出去。</p></blockquote><blockquote><p><strong>第八步</strong>：经过交换机后，数据来到路由器中，路由器的每个端口都是具有IP地址和MAC地址的，而交换机则不具有。当数据来到路由器后，在路由器中有一个路由表，记录了IP地址和端口号的对应关系，以及掩码信息。数据来到路由器后，原先的MAC地址就没用了，然后提取目标IP，然后和子网掩码就行与操作之后，查询路由表选择合适的端口发送出去，当然发送之前要获取下一个接收方的MAC地址，然后再将数据发送到交换机中，重复之前的步骤。</p></blockquote><blockquote><p><strong>第九步</strong>：最后数据到达了目的主机，目的主机将接收到的数据通过一层层的协议解析，最后获得了发送方真正要发送的数据。然后进行数据处理并发送响应报文。</p></blockquote><blockquote><p><strong>第十步</strong>：发送完成之后，客户端接收到数据之后断开连接，采用四次挥手协议：客户端先发送一个FIN报文给服务端，然后进入到FIN_WAIT1阶段；服务端接收到FIN报文段后，进入CLOSED_WAIT阶段，然后发送一个ACK报文段给客户端；客户端接收到ACK报文段后，进入到FIN_WAIT2阶段；服务端经过一段时间后发送一个FIN报文段，然后进入LAST_ACK阶段，客户端接收到FIN字段后发送一个ACK报文段给服务端，客户端进入TIME_WAIT阶段，服务端接收到ACK报文段后进入CLOSED阶段，客户端经过TIME_WAIT后也进入CLOSED阶段。至此一次HTTP请求完成。</p></blockquote><h3 id="交换机、路由器之间的关系"><a href="#交换机、路由器之间的关系" class="headerlink" title="交换机、路由器之间的关系"></a>交换机、路由器之间的关系</h3><p><a href="https://cloud.tencent.com/developer/article/1813700">https://cloud.tencent.com/developer/article/1813700</a></p><h2 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h2><p><a href="https://blog.csdn.net/ShallowGreen/article/details/122753783"><strong>mqtt消息格式</strong></a></p><p><a href="https://blog.csdn.net/weixin_43871650/article/details/111942115"><strong>mqtt协议详解</strong></a></p><p>Mqtt协议是一个基于TCP/IP的订阅发布模式的轻量级通讯协议，它具有低开销、低贷款占用等优点，适用于网络资源不丰富场景。MQTT是一个基于客户端-服务器的消息发布/订阅传输协议，基本模型如下：</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624205744013.png" alt="image-20230624205744013"></p><h3 id="QoS（Quality-of-Service-levels）"><a href="#QoS（Quality-of-Service-levels）" class="headerlink" title="QoS（Quality of Service levels）"></a>QoS（Quality of Service levels）</h3><p>MQTT设计了一套保证消息稳定传输的机制，包括消息应答、存储和重传。在这套机制下，提供了三种不同层次QoS：</p><ul><li>QoS0，发送就不管了，最多一次；</li><li>QoS1，发送之后依赖MQTT规范，是否启动重传消息，所以至少一次；</li><li>QoS2，发送之后依赖MQTT消息机制，确保只有一次。</li></ul><blockquote><p>QoS 是消息的发送方（Sender）和接受方（Receiver）之间达成的一个协议：（MQTT不是端到端的通信）</p></blockquote><ul><li>QoS0 代表，Sender 发送的一条消息，Receiver 最多能收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，也就算了；这是完全依赖TCP重传机制，如果网络不好，TCP的重传也不是100%可靠，加上MQTT是Publisher 发出去的消息是依赖代理服务器完成转发，所以消息最多一次。</li><li>QoS1 代表，Sender 发送的一条消息，Receiver 至少能收到一次，也就是说 Sender 向 Receiver 发送消息，如果发送之后没有收到对应的PUBACK，就会继续重试，直到发送者Sender 接收到 Receiver 发送的 PUBACK 为止，因为重传的原因，Receiver 有可能会收到重复的消息；</li><li>QoS2 代表，Sender 发送的一条消息，Receiver 确保能收到而且只收到一次，也就是说 Sender 尽力向 Receiver 发送消息，如果发送失败，会继续重试，直到 Receiver 收到消息为止，同时保证 Receiver 不会因为消息重传而收到重复的消息。</li></ul><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><ul><li><code>固定头（Fixed header）</code>，存在于所有<code>MQTT</code>数据包中，表示数据包类型及数据包的分组类标识；</li><li><code>可变头（Variable header）</code>，存在于部分<code>MQTT</code>数据包中，数据包类型决定了可变头是否存在及其具体内容；</li><li><code>消息体（Payload）</code>，存在于部分<code>MQTT</code>数据包中，表示客户端收到的具体内容；</li></ul><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624211428355.png" alt="image-20230624211428355"></p><h4 id="固定报头"><a href="#固定报头" class="headerlink" title="固定报头"></a>固定报头</h4><p>固定报头2~5个字节，所有报文都会包含固定报头。 </p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624211716234.png" alt="image-20230624211716234"></p><p>**byte1[7:4]**：MQTT控制报文类型</p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624211853025.png" alt="image-20230624211853025" style="zoom:50%;"><p>**byte1[3:0]**：MQTT报文类型特定的表示</p><ul><li><strong>DUP</strong>:控制报文的重复分发标志</li><li><strong>QoS</strong>:PUBLISH报文的服务质量等级</li><li>**RETAIN **= PUBLISH报文的保留标志</li></ul><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624211946097.png" alt="image-20230624211946097"></p><p><strong>byte2</strong>:剩余长度( Remaining Length)表示当前报文剩余部分的字节数，包括可变报头和负载的数据。剩余长度不包括用于编码剩余长度字段本身的字节数。共1~4个字节，每个字节的低7位用于编码数据，最高位表示是否有更多字节。最大允许发送256M控制报文(0xff,0xff,0xff,0x7f)=256M;</p><h4 id="可变报头"><a href="#可变报头" class="headerlink" title="可变报头"></a>可变报头</h4><p>部分MQTT控制报文包含一个可变报头部分。它在固定报头和负载之间。<strong>可变报头的内容根据报文类型的不同而不同</strong>。可变报头的报文标识符(Packetldentifier)字段存在于在多个类型的报文里。</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624212229945.png" alt="image-20230624212229945"></p><h4 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h4><p>部分MQTT控制报文在报文的最后部分包含一个有效载荷。对于PUBLISH来说有效载荷就是应用消息。下面列出了需要有效载荷的控制报文。</p><p><img src="/2023/03/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/image-20230624212309524.png" alt="image-20230624212309524"></p><ul><li><code>CONNECT</code>，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码</li><li><code>SUBSCRIBE</code>，消息体内容是一系列的要订阅的主题以及<code>QoS</code>。</li><li><code>SUBACK</code>，消息体内容是服务器对于<code>SUBSCRIBE</code>所申请的主题及<code>QoS</code>进行确认和回复。</li><li><code>UNSUBSCRIBE</code>，消息体内容是要订阅的主题。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MIT-6.828操作系统</title>
    <link href="/2022/10/18/mit-6.828/"/>
    <url>/2022/10/18/mit-6.828/</url>
    
    <content type="html"><![CDATA[<h1 id="mit-6-828"><a href="#mit-6-828" class="headerlink" title="mit 6.828"></a>mit 6.828</h1><p>基本 git</p><p>如果完成lab之后，开始执行下面</p><p>git add –all</p><p>git commit -m“”</p><p>git push along-lab labx</p><p>git checkout -b lab(x+1) origin/lab(x+1)</p><p>git merge labx</p><p>git add –all</p><p>git commit -m””</p><p>git push along-lab lab(x+1)</p><h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p><img src="/2022/10/18/mit-6.828/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzAyODkw,size_16,color_FFFFFF,t_70.png" alt="img"></p><h3 id="1-gdb调试"><a href="#1-gdb调试" class="headerlink" title="1. gdb调试"></a>1. gdb调试</h3><blockquote><p>第一步：</p></blockquote><p>在lab文件夹下打开一个终端并执行<code>make qemu-gdb</code></p><blockquote><p>第二步</p></blockquote><p>再在lab文件夹下打开一个终端，执行<code>make gdb</code></p><p>如果出现了“auto-load safe-path’ 这种错误，那我们执行<code>gdb -iex &quot;set auto-load safe-path /&quot;</code>,</p><p>执行完成make gdb 或gdb -iex “set auto-load safe-path /“后，如果出现连接超时现象</p><p>大概率是端口错误</p><p>我们指定端口重新连接，在gdb下执行这个命令：<code>target remote:26000</code> </p><p>然后通过<code>si</code>命令就可以一步步的执行cpu汇编程序了</p><p>一个si命令就会执行一步，一步重复si命令就行</p><h3 id="2-gdb命令"><a href="#2-gdb命令" class="headerlink" title="2. gdb命令"></a>2. gdb命令</h3><p>b *0x10000c 代表的打断点</p><p>si命令是执行下一步</p><p>x/nxb 0x100000   这个命令是显示ox100000存储器后的n个字节内容</p><h3 id="3-虚拟地址和物理地址"><a href="#3-虚拟地址和物理地址" class="headerlink" title="3. 虚拟地址和物理地址"></a>3. 虚拟地址和物理地址</h3><p><a href="https://zhuanlan.zhihu.com/p/421006318">参考博客</a></p><blockquote><p>虚拟地址 ： 就是编译器链接之后的程序地址，但是这个地址和实际的物理地址不相等，他会在加载程序和运行程序的时候转换成（映射）实际物理地址</p></blockquote><blockquote><p>物理地址：就是实际的物理地址，对应的就是内存条上的地址</p></blockquote><blockquote><p>如何通过虚拟地址映射到实际的物理地址</p></blockquote><p>针对于二级目录来讲的</p><ol><li>将虚拟地址的高10为用作页目录表的索引：找到指定的页表   一个页目录就是占用的一个页的大小即1024个页表项</li><li>然后通过指定的页目录项中的内容（指定的页表的起始地址），找到了指定的页表，然后通过高10位后的10位用做页项索引，一个页表也是占用一个页，一个页表可以对应1024个页项</li><li>然后通过指定的页表项中的内容（指定的页的其实位置），找到了指定的页，然后根据后12位作为实际地址的索引，这样就将一个虚拟地址映射到了一个实际物理地址</li></ol><p>【重点】 这个页目录、页表都是在加载程序的时候给确定分配完成的，后面就可以根据这个页目录表和页表就可以根据虚拟地址找到了物理地址，就是存放程序的实际地方。</p><p>【看上面的博客的第四节和第五节，就是如何创建页目录表和页表以及如何根据虚拟地址找到物理地址】</p><h2 id="lab2-memory-management"><a href="#lab2-memory-management" class="headerlink" title="lab2  memory management"></a>lab2  memory management</h2><h3 id="1-va-list-可变参数原理"><a href="#1-va-list-可变参数原理" class="headerlink" title="1. va_list 可变参数原理"></a>1. va_list 可变参数原理</h3><p><a href="https://blog.csdn.net/ZKR_HN/article/details/99558135">可变参数原理</a></p><p>c语言中，函数的参数是从右往左压入栈中的，所以，右边的参数先压入栈，左边的参数后压入栈</p><p>C语言的函数形参是从右向左压入堆栈的，以保证栈顶是第一个参数，而且x86平台内存分配顺序是从高地址到低地址。因此似函数AVEInt(int var1,int<br>var2,…,int varN)内存分配大致上是这样的：(可变参数在中间)</p><p>![img](mit 6.828.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1pLUl9ITg==,size_16,color_FFFFFF,t_70.png)</p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="https://juejin.cn/post/6989917722519797797">https://juejin.cn/post/6989917722519797797</a></p><p>【基本命令】<a href="https://blog.csdn.net/fantasy_wxe/article/details/52198650">https://blog.csdn.net/fantasy_wxe/article/details/52198650</a></p><h3 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h3><p><a href="https://www.cnblogs.com/bakari/p/7858029.html">https://www.cnblogs.com/bakari/p/7858029.html</a></p><p>Qemu 是纯软件实现的虚拟化模拟器，几乎可以模拟任何硬件设备，我们最熟悉的就是能够模拟一台能够独立运行操作系统的虚拟机，虚拟机认为自己和硬件打交道，但其实是和 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p><p>![img](mit 6.828.assets/431521-20171118213522843-322721697.png)</p><p>从本质上看，虚拟出的每个虚拟机对应 host 上的一个 Qemu 进程，而虚拟机的执行线程（如 CPU 线程、I/O 线程等）对应 Qemu 进程的一个线程。</p><p>Qemu 软件虚拟化实现的思路是采用二进制指令翻译技术，主要是提取 guest 代码，然后将其翻译成 TCG 中间代码，最后再将中间代码翻译成 host 指定架构的代码，如 x86 体系就翻译成其支持的代码形式，ARM 架构同理。</p><blockquote><p>基本命令</p></blockquote><p><a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html">https://pdos.csail.mit.edu/6.828/2018/labguide.html</a></p><p><code>Qemu包含一个内置的监视器用来观察和修改机器状态，进入monitor模式后，在终端中按下Ctrl-a c运行Qemu， 再次按下Ctrl-a c切换到串口控制台</code></p><p><code>info registers</code> 输出所有的寄存器</p><p><code>info pg</code> 输出页表关系</p><p><code>info mem</code>输出各个内存段的读写权限</p><h3 id="GDB基本概念"><a href="#GDB基本概念" class="headerlink" title="GDB基本概念"></a>GDB基本概念</h3><p><strong><a href="https://www.cnblogs.com/lvdongjie/p/8994092.html//">https://www.cnblogs.com/lvdongjie/p/8994092.html//</a> 很详细的一篇博客</strong></p><p>GDB是一个强大的命令行调试工具。他是GNU组织发布的一个unix下的程序调试工具。一般来说，GDB主要帮你完成下面四个方面的功能。</p><ol><li>启动你的程序，可以按照你自定义的要求随心所欲的运行程序</li><li>可以让被调试的程序在你所指定的调试的断点处停住（<strong>断点可以是条件表达式</strong>）</li><li>当程序被停止时，可以检查此时你的程序发生的事情。</li><li>动态的改变你程序的执行环境</li></ol><blockquote><p>基本命令：</p></blockquote><p><a href="https://www.cnblogs.com/gaoshaonian/p/10219680.html">https://www.cnblogs.com/gaoshaonian/p/10219680.html</a></p><p><a href="https://www.cnblogs.com/bxf0011/p/14470215.html">https://www.cnblogs.com/bxf0011/p/14470215.html</a></p><p><code>i r addr</code> 可以查看这个地址的内容  i r eip cs 查看eip和cs寄存器内容<br><code>x/Ni addr</code> 表示可以查看addr地址开始的N条指令 ， x/6i $cs*16 + $eip 也可以查看实模式下的地址开始的6条指令<br><code>x/Nx addr</code> 表示将地址addr开始的N个字节以16进制显示出来，可以查看地址空间内容</p><p><code>info all-registers</code> 显示所有的寄存器信息</p><h3 id="elf-命令"><a href="#elf-命令" class="headerlink" title="elf 命令"></a>elf 命令</h3><p><a href="https://blog.csdn.net/yfldyxl/article/details/81566279">https://blog.csdn.net/yfldyxl/article/details/81566279</a></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><blockquote><p>安装qemu–用来仿真x86架构的计算机</p></blockquote><p>这门课就是采用qemu来模拟一个x86架构的计算机来运行你的xv6操作系统，这个软件也可以和gdb一起搭配使用，这样我们就可以在这个qemu上来一条指令一条指令的调试你的xv6操作系统了</p><p>当我们下载完成qemu后，我们需要先编译我们下载的操作系统源码，用来生成能够运行在qemu上的操作系统映像文件，编译完成之后会生成一个obl/kern/kernel.img,这个kernel.img文件就是编译后的操作系统镜像文件，这个文件是操作系统make之后生成的。</p><p>然后我们在lab的目录下输入make qemu，此时qemu就开始加载我们的操作系统内核映像文件了</p><h2 id="lab1-1"><a href="#lab1-1" class="headerlink" title="lab1"></a>lab1</h2><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><h4 id="物理地址布局"><a href="#物理地址布局" class="headerlink" title="物理地址布局"></a>物理地址布局</h4><p>PC的物理地址基本内存布局：</p><p>![image-20230301192502377](mit 6.828.assets/image-20230301192502377-16776699035263.png)</p><p>![img](mit 6.828.assets/6818371c053c41309ca53d732effd757tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)</p><p>第一代PC处理器是16位字长的Intel 8088处理器，这类处理器只能访问1MB的地址空间，即0x00000000-0x000FFFFF。但是这1MB也不是用户都能利用到的，只有低640KB(0x00000000-0x000A0000)的地址空间是用户程序可以使用的（DRAM–动态随机访问内存）。而剩下的384KB的高地址空间则被保留用作其他的目的，比如(0x000A0000-0x000C0000)被用作屏幕显示内容缓冲区，其他的则被非易失性存储器(ROM)所使用，里面会存放一些固件，其中最重要的一部分就是BIOS（存在ROM中），占据了0x000F0000~0x00100000的地址空间。</p><blockquote><p>Bios做了那么些事情，它的主要工作是检测、初始化一些硬件、<strong>构建中断向量表</strong>、<strong>加载boot loader引导加载操纵系统</strong>等功能，BIOS存在F0000-FFFFF这64kb空间，属于ROM，在出厂的时候就有了，一般不能更改。</p><p><strong>当BIOS确定后，操作系统是位于磁盘中的，那么BIOS就会去把第一个磁盘的第一个扇区，这个扇区通常叫做启动区（boot sector）加载到内存中，这个启动区中包括一个非常重要的程序叫做boot loader，它就是专门负责将整个操作系统加载到内存中。</strong></p></blockquote><h4 id="基本启动流程"><a href="#基本启动流程" class="headerlink" title="基本启动流程"></a>基本启动流程</h4><blockquote><p>下面我们使用qemu和gdb探索PC机的启动过程。</p><p>**先说一下大概流程：BIOS  –&gt; BootLoader –&gt; 操作系统内核 **</p></blockquote><ul><li>首先我们在lab目录下指行<code>make qemu-gdb</code>，运行qemu（以调试模式启动了机器）</li><li>然后在lab下指向<code>gdb</code>指令，然后就可以一步步的控制qemu的内置的指针一步一步的执行指令（gdb是对机器pc而言的，不是对操作系统而言的，操作系统说白了也是一个程序）</li></ul><p>我们就会得到 <code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code>,这个就是整个PC启动后执行的第一条指令，然后就停在了这里，然后可以通过gdb进行一步一步的执行进行跟踪这个pc如何运行的。</p><p>上面这个<code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code>，表示现在PC执行的第一个指令的地址是f000:fff0，代表cs:ip的值，所以真实地址就是cs*16 + ip = ffff0 ,这个就是BIOS程序的入口地址，也就是那1m空间的最高的64b空间，然后执行的指令是<code>ljmp  $0xf000, $0xe05b</code>表示跳转到<code>fe05b</code>,这个地址就是BIOS程序的第一条指令。</p><p>为什么第一条指令的地址在ffff0,这是cpu在上电的一瞬间，强制将cs：ip这两个寄存器设置成了<code>f000</code>和<code>fff0</code></p><p>因为开机处于实模式，所以要cs*16 + ip才是真正的地址，至于什么是实模式下面再介绍。</p><h4 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h4><p>实模式是早期CPU，比如8088处理器的工作模式，这类处理器由于有20根地址线，所以它们能访问1MB的内存空间。但是呢，cpu的寄存器只有16位，如果只用一个寄存器来存储地址，那么只能寻址到0000-FFFF这么多，所以用两个寄存器（段基址寄存器cs 和段内偏移寄存器 ip）来存储地址，然后地址的计算公式是cs*16 + ip</p><p>但是CPU也在不断的发展，之后的80286/80386已经具备32位地址总线，能够访问4GB内存空间，为了能够很好的管理这么大的内存空间，保护模式被研发出来。在保护模式下，虽然段值仍然由原来的16位cs寄存器指定，但此时这些寄存器中存放的不再是段基址，而是一个索引。从这个索引，可以找到一个表项，里面存放了段基址等很多属性，这个表项称为段描述符，这个表就称为GDT。</p><p>现代处理器都是工作在保护模式下的。但是为了实现向后兼容性，即原来运行在8088处理器上的软件仍旧能在现代处理器上运行，现代的CPU都是在启动时运行于实模式，启动完成后运行于保护模式</p><p>BIOS就是PC刚启动时运行的软件，所以它必然工作在实模式下。</p><h4 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h4><p>因为现在地址线的个数从20根变成了32根，寻址范围变成了4GB，然后寄存器的位数也变成了32位（寄存器是在cpu中的）。所以通过32位就能够实现4GB的寻址了，为了能够更好的管理这么大的内存空间，就引入了保护模式。</p><p>我们先介绍以下几个概念：逻辑地址、虚拟地址、线性地址、物理地址</p><ul><li>虚拟地址：我们都知道，我们程序员在编写程序的时候，根本不知道以后我们的程序会运行在什么机器上，也不知道这个机器的内存占用情况，所以我们要让程序运行在虚拟地址空间小，也就是说，我们在编写程序时指令出现的地址不一定就是机器上的物理内存地址。这样操作是为了让程序员在编程的时候不用直接操作实际物理地址，因为我们也不知道内存地址的占用情况。所以以后这个程序指令存在哪个物理地址空间由操作系统决定，程序中的地址要访问哪个物理地址由操作系统来确定。这个就是从虚拟地址到物理地址之间的转换</li><li>逻辑地址：程序员编写时看到的是虚拟地址，但是并不是直接把虚拟地址直接写入到这个指令中的，基本都是偏移量，逻辑地址由两部分组成，一个是段选择子，一个是段内偏移量，分别存在cs/ds/ss/es和ip中，采用哪个段选择子一般都是在指令中隐含的，程序员只需要指明段内偏移量，然后分段管理机构将这个逻辑地址转换成<strong>线性地址</strong>（其实就是虚拟地址），。如果机器没有开启分页机制，那么这个线性地址就是实际的物理地址。但是如果开启了分页机制，那么就会将这个线性地址转换成物理地址。</li></ul><p>![img](mit 6.828.assets/809277-20160109142207371-383459687.png)</p><blockquote><p>那么在保护模式下，我们怎么进行寻址的呢？</p></blockquote><p><strong>GTD</strong></p><p>首先在计算机中存在两个表一个是GDT和LDT。分别就全局段描述符表，和本地段描述符表。GDT是全局可见的，他维护了很多段描述符（程序段、数据段、栈段），每个描述符包含了某个段的起始地址，占用多大空间等信息</p><p>![img](mit 6.828.assets/809277-20160109143519184-1430449279.png)</p><p>我们从图中可以看到，无论是GDT，还是LDT。每一个表项都包括三个字段：（这三个元素的空间分配总共64字节但是分配的很细碎）</p><p>![img](mit 6.828.assets/8560837bbb6e40659359df8b88acbac6tplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)</p><p>　　Base : 32位，代表这个程序的这个段的基地址。</p><p>　　Limit : 20位，代表这个程序的这个段的大小。</p><p>　　Flags ：12位，代表这个程序的这个段的访问权限。</p><p>每一个GDT Entry结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gdt_entry</span> &#123;<br>  uint16 limit_low;<br>  uint16 base_low;<br>  uint8  base_middle;<br>  uint8  access;<br>  uint8  attributes;<br>  uint8  base_high;<br>&#125; __attribute__((packed));<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gdt_entry</span> <span class="hljs-type">gdt_entry_t</span>;<br><br></code></pre></td></tr></table></figure><p>当程序中给出逻辑地址 segment:offset时，他并不是像实模式那样，用segment的值作为段基址。而是把这个segment的值作为一个selector，代表这个段的段表项在GDT/LDT表的索引。比如你当前要访问的地址是segment:offset = 0x01:0x0000ffff，此时由于每个段表项的长度为8，所以此时应该取出地址8处的段表项。然后首先根据Flags字段来判断是否可以访问这个段的内容，这样做是为了能够实现进程间地址的保护。如果能访问，则把Base字段的内容取出，直接与offset相加，就得到线性地址(linear address)了。之后就是要根据是否有分页机构来进行地址转换了。</p><p>保护模式还是要比实模式的工作方式灵活许多，可以在以下几个方面看出来：</p><ol><li>实模式下段基地址必须是16的整数倍，保护模式下段基地址可以是4GB空间内的任意一个地址。</li><li>实模式下段的长度是65536B，但是保护模式下段的长度也是可以达到4GB的。</li><li> 保护模式下可以对内存的访问多加一层保护，但是实模式没有</li></ol><blockquote><p><strong>GDT表的地址存在GDTR寄存器中，由lgdt指令进行加载</strong>，这个寄存器共48位，前十六位表示GDT界限，后32位存储GDT地址，GDT只能容纳65536/8 = 8192个段描述符</p><p>段选择子是存在各个CS\DS\SS\ES等寄存器中，表示在GDT中的索引，其中寄存器的后13位才是真正的索引值，前3位表示TI字段和RPL字段。</p></blockquote><blockquote><p>总结：</p></blockquote><p>![image-20210730181710510](mit 6.828.assets/50ab3e5466814b8ba07d7bccc580430etplv-k3u1fbpfcp-zoom-in-crop-mark4536000.webp)</p><h4 id="cpu模型"><a href="#cpu模型" class="headerlink" title="cpu模型"></a>cpu模型</h4><p>![image-20230305215350922](mit 6.828.assets/image-20230305215350922.png)</p><h3 id="逐步分析启动流程"><a href="#逐步分析启动流程" class="headerlink" title="逐步分析启动流程"></a>逐步分析启动流程</h3><p><a href="https://blog.csdn.net/weixin_41761478/article/details/101102354">https://blog.csdn.net/weixin_41761478/article/details/101102354</a></p><p>![img](mit 6.828.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NzAyODkw,size_16,color_FFFFFF,t_70-167791316370135.png)</p><h4 id="首先进入BIOS程序"><a href="#首先进入BIOS程序" class="headerlink" title="首先进入BIOS程序"></a>首先进入BIOS程序</h4><p>当上电之后，cs：ip被强制设成f000：fff0 这个就是BIOS的入口程序地址，在这里会指向跳转命令，跳转到真正的BIOS程序中。</p><p>先简单介绍以下BIOS会做哪些事情：</p><ul><li><p>BIOS的操作就是在控制，初始化，检测各种底层的设备，比如时钟，GDTR寄存器。（开启保护模式又关闭了）</p></li><li><p>以及设置中断向量表。</p></li><li><p>但是作为PC启动后运行的第一段程序，<strong>它最重要的功能是把操作系统从磁盘中导入内存，然后再把控制权转交给操作系统。</strong></p></li><li><p>所以BIOS在运行的最后会去检测可以从当前系统的哪个设备中找到操作系统，通常来说是我们的磁盘。也有可能是U盘等等。当BIOS确定了，操作系统位于磁盘中，那么它就会把这个磁盘的第一个扇区，通常把它叫做启动区（boot sector）先加载到内存中，这个启动区中包括一个非常重要的程序–<strong>boot loader，</strong>它会负责完成整个操作系统从磁盘导入内存的工作，以及一些其他的非常重要的配置工作。最后操作系统才会开始运行。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-number">1.</span> <span class="hljs-number">0xffff0</span>:  ljmp $<span class="hljs-number">0xf000</span>, $<span class="hljs-number">0xe05b</span>    跳转到 <span class="hljs-number">0xf000</span>*<span class="hljs-number">16</span> + <span class="hljs-number">0xe05b</span>地方去<br>   <span class="hljs-number">2.</span> <span class="hljs-number">0xfe05b</span>: cmpl $<span class="hljs-number">0x0</span>, $cs:<span class="hljs-number">0x6ac8</span><br>   <span class="hljs-number">3.</span> <span class="hljs-number">0xfe062</span>:  jne  <span class="hljs-number">0xfd2e1</span><br>    <span class="hljs-number">4.</span> <span class="hljs-number">0xfe066</span>:  xor  %dx, %dx <span class="hljs-comment">//将寄存器清零</span><br>    <span class="hljs-number">5.</span> <span class="hljs-number">0xfe068</span>:  mov  %dx %ss<br>    <span class="hljs-number">6.</span> <span class="hljs-number">0xfe06a</span>:  mov  $<span class="hljs-number">0x7000</span>, %esp<br>    <span class="hljs-number">7.</span> <span class="hljs-number">0xfe070</span>:  mov  $<span class="hljs-number">0xf34d2</span>, %edx<br>    <span class="hljs-number">8.</span> <span class="hljs-number">0xfe076</span>:  jmp  <span class="hljs-number">0xfd15c</span>  <span class="hljs-comment">// 绝对跳转至下一条指令</span><br>    <span class="hljs-number">9.</span> <span class="hljs-number">0xfd15c</span>:  mov  %eax, %ecx<br>        <br>    <span class="hljs-number">10.</span> <span class="hljs-number">0xfd15f</span>:  cli  <span class="hljs-comment">//关闭中断指令。这个比较好理解，启动时的操作是比较关键的，所以肯定是不能被中断的。这个关中断指令用于关闭那些可以屏蔽的中断。比如大部分硬件中断。cli表示clear Interrupt，作用是将EFLAGS标志寄存器的IF置为0。EFLAGS标志寄存器有32位，不同位代表不同标志，</span><br>       <span class="hljs-comment">// 其中IF表示中断使能标志。关于中断：中断对于CPU来说，分为外部中断和内部中断。将 IF标志设置为0，屏蔽的是来自硬件的可屏蔽中断请求。在 IF为0期间，只有CPU外部不可屏蔽中断（NMI）引脚上发来的硬件中断请求能得到响应，其它可屏蔽请求不被响应。启动时的操作是比较关键的，所以肯定是不能被中断的，因此需要这个关中断指令用于关闭那些可以屏蔽的中断</span><br>  <span class="hljs-comment">// 通过 i r eflags 可以查看寄存器值</span><br>    <br>    <span class="hljs-number">11.</span> <span class="hljs-number">0xfd160</span>:  cld <span class="hljs-comment">//设置方向标识位为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为0代表从低地址值变为高地址。</span><br>     <span class="hljs-number">12.</span> <span class="hljs-number">0xfd161</span>:  mov  $<span class="hljs-number">0x8f</span>, %eax  <span class="hljs-comment">// 这三条指令是用来关闭NMI中断的。</span><br>    <span class="hljs-number">13.</span> <span class="hljs-number">0xfd167</span>:  out  %al, $<span class="hljs-number">0x70</span><br>    <span class="hljs-number">14.</span> <span class="hljs-number">0xfd169</span>:  in  $<span class="hljs-number">0x71</span>, %al <br>       <span class="hljs-comment">// 这三个操作中涉及到两个新的指令out, in。这两个操作是用于操作IO端口的</span><br>         <span class="hljs-comment">//in %al, PortAddress    向端口地址为PortAddress的端口写入值，值为al寄存器中的值</span><br>　　 <span class="hljs-comment">//out PortAddres,%al    把端口地址为PortAddress的端口中的值读入寄存器al中</span><br>        <span class="hljs-comment">//CPU与外部设备通讯时，通常是通过访问，修改设备控制器中的寄存器来实现的。那么这些位于设备控制器当中的寄存器也叫做IO端口。为了方便管理，80x86CPU采用IO端口单独编址的方式，即所有设备的端口都被命名到一个IO端口地址空间中。这个空间是独立于内存地址空间的。所以必须采用和访问内存的指令不一样的指令来访问端口。</span><br>        <br><span class="hljs-number">15.</span> <span class="hljs-number">0xfd16b</span>:  in  $<span class="hljs-number">0x92</span>, %al <span class="hljs-comment">// 这三个指令是使能第21根地址线，进入保护模式，但是进入bootloader会重回实模式</span><br><span class="hljs-number">16.</span> <span class="hljs-number">0xfd16d</span>:  or  $<span class="hljs-number">0x2</span>, %al<br><span class="hljs-number">17.</span> <span class="hljs-number">0xfd16f</span>:  out  %al, $<span class="hljs-number">0x92</span><br>    <br>   <span class="hljs-number">18.</span> <span class="hljs-number">0xfd171</span>:  lidtw  %cs:<span class="hljs-number">0x6ab8</span> <span class="hljs-comment">// lidt指令：加载中断向量表寄存器(IDTR)。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器(IDTR)中。</span><br>   <span class="hljs-number">19.</span> <span class="hljs-number">0xfd177</span>:  lgdtw  %cs:<span class="hljs-number">0x6a74</span> <span class="hljs-comment">//把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器中GDTR中。</span><br>       <br><span class="hljs-number">20.</span> <span class="hljs-number">0xfd17d</span>:  mov  %cr0, %eax<br><span class="hljs-number">21.</span> <span class="hljs-number">0xfd180</span>:  or  $<span class="hljs-number">0x1</span>, %eax<br><span class="hljs-number">22.</span> <span class="hljs-number">0xfd184</span>:  mov  %eax, %cr0<br>    <span class="hljs-comment">//计算机中包含CR0~CR3四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位(0bit)置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式之下，后面的boot loader开始的时候也是工作在实模式下，所以这里把它切换为保护模式，显然是自相矛盾。所以只能推测它在检测是否机器能工作在保护模式下。</span><br>    .......<br></code></pre></td></tr></table></figure><p>以上我们分析了BIOS程序，知道了他做了哪些事情，关闭中断、加载GDTR\IDTR寄存器、开启保护模式（进入bootloader是实模式）等等操作。</p><p><strong>但是BIOS最重要的操作还是将bootloader程序加载到内存（一般是0x7c00处，然后bios执行跳转指令就跳转到了boot loader中），然后跳转到它，并执行它去加载真正的操作系统程序</strong></p><blockquote><p> <strong>我们在反汇编文件中看的地址都是编译器链接的地址，并不是实际的物理地址，等到后面我们开启分页之后，就是虚拟地址了</strong></p><p>可以看<a href="https://www.cnblogs.com/fatsheep9146/p/5220004.html">https://www.cnblogs.com/fatsheep9146/p/5220004.html</a></p></blockquote><h4 id="进入bootloader程序"><a href="#进入bootloader程序" class="headerlink" title="进入bootloader程序"></a>进入bootloader程序</h4><p>于PC来说，软盘，硬盘都可以被划分为一个个大小为512字节的区域，叫做扇区。一个扇区是一次磁盘操作的最小粒度。每一次读取或者写入操作都必须是一个或多个扇区。</p><p><strong>如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区</strong>。</p><p>这一部分介绍的boot loader程序就位于这个启动扇区之中。</p><p><strong>当BIOS找到一个可以启动的软盘或硬盘后，它就会把这512字节的启动扇区加载到内存地址<code>0x7c00~0x7dff</code>这个区域内。</strong> </p><blockquote><p><strong>那BIOS是怎么找到这个启动程序的呢？</strong>— BIOS会去加载0盘0扇道1扇区的扇区内容，但是它会先判断这个扇区末尾的两个字是不是魔数0x55和0xaa</p></blockquote><p>在这个实验中bootloader由两个文件组成，<strong>一个是boot.S汇编文件，一个是main.c C文件</strong>，最终他们都被编译成了一个boot.asm文件</p><p>那么bootloader做了哪些事情呢？</p><blockquote><p>我们下面使用gdb进行一步步的跟踪：我们把断点设置在<code>0x7c00处</code>，这个是BIOS将</p></blockquote><p>boot.s文件如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;inc/mmu.h&gt;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">The BIOS loads this code from the first sector of the hard disk into</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">memory at physical address 0x7c00 and starts executing <span class="hljs-keyword">in</span> real mode</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">with %cs=0 %ip=7c00.</span><br><br>.set PROT_MODE_CSEG, 0x8         # kernel code segment selector<br>.set PROT_MODE_DSEG, 0x10        # kernel data segment selector<br>.set CR0_PE_ON,      0x1         # protected mode enable flag<br><br>.globl start<br>start:<br>  .code16                     # Assemble for 16-bit mode<br>  cli                         # Disable interrupts                                              // 关闭所有中断<br>  cld                         # String operations increment<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Set up the important data segment registers (DS, ES, SS).          //将各种段寄存器清零</span><br>  xorw    %ax,%ax             # Segment number zero<br>  movw    %ax,%ds             # -&gt; Data Segment<br>  movw    %ax,%es             # -&gt; Extra Segment<br>  movw    %ax,%ss             # -&gt; Stack Segment<br><br>下面做的事情就是：<br>1. 打开A20地址线<br>2. 在gdtr寄存器中加载GTD的地址和界限<br>3. 设置cr0寄存器的PE位置为1<br>就进入了保护模式<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Enable A20:</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">  For backwards compatibility with the earliest PCs, physical</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">  address line 20 is tied low, so that addresses higher than</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">  1MB wrap around to zero by default.  This code undoes this.</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash">我们可以看到其中的指令包括inb，outb这样的IO端口命令。</span><br><span class="hljs-meta prompt_"> # </span><span class="language-bash"> 所以这些指令都是在对外部设备进行操作</span><br>seta20.1:<br>  inb     $0x64,%al               # Wait for not busy<br>  testb   $0x2,%al<br>  jnz     seta20.1<br><br>  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64<br>  outb    %al,$0x64<br><br>seta20.2:<br>  inb     $0x64,%al               # Wait for not busy<br>  testb   $0x2,%al<br>  jnz     seta20.2<br><br>  movb    $0xdf,%al               # 0xdf -&gt; port 0x60         <br>  outb    %al,$0x60<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Switch from real to protected mode, using a bootstrap GDT</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">and segment translation that makes virtual addresses</span> <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">identical to their physical addresses, so that the</span> <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">effective memory map does not change during the switch.</span><br>  lgdt    gdtdesc                                                   # 这个gdtdesc在最下面，占6个字节，正好填充GPTR寄存器<br>  movl    %cr0, %eax                                           #cr0 是控制寄存器，可以用来打开保护模式<br>  orl     $CR0_PE_ON, %eax                                # 这里完成对PE位置1，打开保护模式<br>  movl    %eax, %cr0<br>  <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Jump to next instruction, but <span class="hljs-keyword">in</span> 32-bit code segment.</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Switches processor into 32-bit mode.</span><br>  ljmp    $PROT_MODE_CSEG, $protcseg <br><br>  .code32                     # Assemble for 32-bit mode<br>protcseg:<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Set up the protected-mode data segment registers</span><br>  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector<br>  movw    %ax, %ds                # -&gt; DS: Data Segment<br>  movw    %ax, %es                # -&gt; ES: Extra Segment<br>  movw    %ax, %fs                # -&gt; FS<br>  movw    %ax, %gs                # -&gt; GS<br>  movw    %ax, %ss                # -&gt; SS: Stack Segment<br>  <br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Set up the stack pointer and call into C.   //设置栈的栈顶指针，就是0x7c00 ，因为栈是向下拓展的，所以选这个作为栈顶</span><br>  movl    $start, %esp<br>  call bootmain<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">If bootmain returns (it shouldn<span class="hljs-string">&#x27;t), loop.</span></span><br>spin:<br>  jmp spin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Bootstrap GDT</span></span><br>.p2align 2                                # force 4 byte alignment<br>gdt:<br>  SEG_NULL# null seg                      这个是第0个段描述符，不设置任何东西<br>  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg   在这个位置设置代码段，每个段描述符是8个字节<br>  SEG(STA_W, 0x0, 0xffffffff)        # data seg  在这个位置设置数据段<br><br>gdtdesc:  // 这个就是GDTR的描述符，共6个字节，2个字节表示gdt界限，4个字节表示gdt表的地址<br>  .word   0x17                            # sizeof(gdt) - 1   在这里放一个字(2字节)，就是gdt大小<br>  .long   gdt                             # address gdt       在这里放一个long字(4字节)，就是gdt的地址  总共占据6字节，<br>                                                               #后面把这个放到了gdtr寄存器中<br><br><br></code></pre></td></tr></table></figure><p>在上面<code> lgdt    gdtdesc</code>   经过反汇编是 <code>lgdtw 0x7c64</code></p><p>![image-20230302200537118](mit 6.828.assets/image-20230302200537118-167775873800015.png)</p><p>![image-20230302200603428](mit 6.828.assets/image-20230302200603428.png)</p><p>所以我们可以得到GDT表在哪里？在<code>0x7c4c</code>处,现在一共有3个段描述符，第一个是空的，第二个是code段，第三个是data段，就是上面boot.s文件里的最后面，后面两个段，我们根据段描述符分析，可以看出段基址都是0，段界限呢？</p><p><strong>首先我们要清楚，在<em>80386</em>保护模式下，段界限用<em>20</em>位表示，而且段界限可以是以字节为单位或以<em>4K</em>字节为单位。段属性中有一位对此进行定义，把该位成为粒度位，用符号<em>G</em>标记。<em>G=0</em>表示段界限以字节位位单位，于是<em>20</em>位的界限可表示的范围是<em>1</em>字节至<em>1M</em>字节，增量为<em>1</em>字节；<em>G=1</em>表示段界限以<em>4K</em>字节为单位，于是<em>20</em>位的界限可表示的范围是<em>4K</em>字节至<em>4G</em>字节，增量为<em>4K</em>字节。</strong></p><p>因为x86没有分段，所以段基址都是0，寻址范围都是4G</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"># Bootstrap GDT<br>.p2align <span class="hljs-number">2</span>                                <span class="hljs-meta"># force 4 byte alignment</span><br>gdt:<br>  SEG_NULL<span class="hljs-meta"># null seg                      这个是第0个段描述符，不设置任何东西</span><br>  SEG(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)<span class="hljs-meta"># code seg   在这个位置设置代码段，每个段描述符是8个字节</span><br>  SEG(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)        <span class="hljs-meta"># data seg  在这个位置设置数据段</span><br><br>gdtdesc:  <span class="hljs-comment">// 这个就是GDTR的描述符，共6个字节，2个字节表示gdt界限，4个字节表示gdt表的地址</span><br>  .word   <span class="hljs-number">0x17</span>                            <span class="hljs-meta"># sizeof(gdt) - 1   在这里放一个字(2字节)，就是gdt大小</span><br>  .<span class="hljs-type">long</span>   gdt                             <span class="hljs-meta"># address gdt       在这里放一个long字(4字节)，就是gdt的地址  总共占据6字节，</span><br>                                                               #后面把这个放到了gdtr寄存器中<br></code></pre></td></tr></table></figure><p><strong>然后执行完段描述符设置后，对PE的bit0位置设1，打开保护模式，然后执行ljmp命令，更新cs寄存器的值，跳转程序。</strong>也就是下面这个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"># Jump to next instruction, but in <span class="hljs-number">32</span>-bit code segment.<br># Switches processor into <span class="hljs-number">32</span>-bit mode.<br>ljmp    $PROT_MODE_CSEG, $protcseg <br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么要使用ljmp指令呢？可以看《操作系统真相还原》p172的4.5节</strong></p></blockquote><p>下面继续执行指令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">protcseg:<br>  # Set up the protected-mode data segment registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector<br>  movw    %ax, %ds                # -&gt; DS: Data Segment<br>  movw    %ax, %es                # -&gt; ES: Extra Segment<br>  movw    %ax, %fs                # -&gt; FS<br>  movw    %ax, %gs                # -&gt; GS<br>  movw    %ax, %ss                # -&gt; SS: Stack Segment<br>  <br>  # Set up the <span class="hljs-built_in">stack</span> pointer and call into C.   <span class="hljs-comment">//设置栈的栈顶指针，就是0x7c00 ，因为栈是向下拓展的，所以选这个作为栈顶</span><br>  movl    $start, %esp<br>  call bootmain<br><br>  # If bootmain <span class="hljs-title function_">returns</span> <span class="hljs-params">(it shouldn<span class="hljs-string">&#x27;t), loop.</span></span><br><span class="hljs-string"><span class="hljs-params">spin:</span></span><br><span class="hljs-string"><span class="hljs-params">  jmp spin</span></span><br></code></pre></td></tr></table></figure><p><code>  movl    $start, %esp   call bootmain</code></p><p>这两句发生了什么事情：</p><p><strong>首先我们要知道esp指针就是指向当前栈的顶端的指针，这个指令就是</strong>设置esp指向0x7c00处<strong>，也就是boot loader程序下面，因为栈是向下扩展的，所以选择这里</strong>，</p><p><strong>然后调用main函数，也就是main.c文件中的main函数，至此进入main.c文件</strong>，上面按个栈就是main函数的栈，用来存储一些变量</p><blockquote><p>接下来我们开始分析main.c函数</p></blockquote><p>在这之前我们先介绍以下elf文件，这个是文件编译链接之后的文件</p><p>elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。</p><p>![img](mit 6.828.assets/resize,m_lfit,w_268,limit_1.png)</p><p><a href="https://blog.csdn.net/nirendao/article/details/123883856">https://blog.csdn.net/nirendao/article/details/123883856</a> （elf文件图解）</p><ul><li>一个 ELF 文件格式的可执行程序的加载运行过程是这样的：<br>通过读取 ELF 头表中的信息了解该可执行程序是否可以运行（版本号，适用的计算机架构等等）<br>通过 ELF 头表中的信息找到程序头表<br>通过读取 ELF 文件中程序头表的信息了解可执行文件中各个段的位置以及加载方式</li></ul><blockquote><p>下面开始分析程序</p></blockquote><p><strong>内核就是一个elf文件</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELFHDR((struct Elf *) 0x10000) <span class="hljs-comment">// scratch space</span></span><br><span class="hljs-comment">// read 1st page off disk</span><br><span class="hljs-number">1</span> readseg((<span class="hljs-type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<span class="hljs-comment">// read 1st page off disk</span><br><span class="hljs-comment">// 512b * 8 = 4kb = 1 page</span><br><span class="hljs-comment">//这个完成了将内核文件（ELF格式的文件）的前 4096（1 page）个字节读进到0x10000处</span><br><span class="hljs-comment">// 其实就是将elf header读进了内存，位置是0x10000处</span><br><span class="hljs-comment">// 然后接下来对这个elf header进行分析，获取每个program header</span><br><span class="hljs-comment">// 每个程序头可以知道每个程序的位置和加载方式</span><br><span class="hljs-comment">// 然后把每个program header对应的段加载进来</span><br></code></pre></td></tr></table></figure><p><strong>上面这个就是读取了4080字节的磁盘内容到内存中，位置就是0x10000处，这个内容包含了elf header 和program header table</strong></p><p>我们用<code>readelf -l kernel</code> 命令可以查看内核elf文件</p><p>![image-20230302220553389](mit 6.828.assets/image-20230302220553389-167776595437619.png)</p><p>先检查是不是elf文件</p><p>然后将<strong>每个program header对应的内核程序</strong>读进来，**==内核程序放在了0x100000上==**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// is this a valid ELF?                                      先检查是不是elf文件</span><br><span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)<br><span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">// load each program segment (ignores ph flags)</span><br><span class="hljs-comment">//ELFHDR-&gt;e_phoff这个代表的是第一个程序头在elf文件内的偏移量</span><br><span class="hljs-comment">//ph此时就代表指向了第一个程序头在内存中的位置</span><br>ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);<br><span class="hljs-comment">//ELFHDR-&gt;e_phnum表示有几个程序头，eph指向最后一个程序头；</span><br>eph = ph + ELFHDR-&gt;e_phnum;<br><span class="hljs-keyword">for</span> (; ph &lt; eph; ph++) &#123;<br><span class="hljs-comment">//开始加载每个程序段      也就是内核程序段和数据段等内容</span><br><span class="hljs-comment">// p_pa is the load address of this segment (as well</span><br><span class="hljs-comment">// as the physical address)</span><br><span class="hljs-comment">//ph-&gt;p_offset表示在文件内的偏移字节数，ph-&gt;p_memsz表示在内存中的大小，ph-&gt;p_pa表示在内存中的地址</span><br><span class="hljs-comment">// 第一个段 p_pa == 0x100000      p_memsz = 0x7c96 p_offset = 0x1000 正好对应的4096开始，和刚才elf header读进来后面的保持一致 </span><br>readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ph-&gt;p_memsz - ph-&gt;p_filesz; i++) &#123;<br>*((<span class="hljs-type">char</span> *) ph-&gt;p_pa + ph-&gt;p_filesz + i) = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面将内核程序都读进来了，下面开始进入真正的内核程序了。</strong></p><p><strong>接下来就很重要了</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// call the entry point from the ELF header</span><br><span class="hljs-comment">// note: does not return!</span><br><span class="hljs-comment">//ELFHDR-&gt;e_entry表示程序（内核程序）的入口地址，段的加载地址是0x100000 ,程序的起始地址在0x10000c</span><br><span class="hljs-comment">//以上的都是bootloader程序，还没有开启虚拟地址，等下会进入内核程序，进入之后，指令的寻址方式都是采用的虚拟地址，</span><br><span class="hljs-comment">//内核程序在编址的时候设置的起始地址是0xf0100000  也就是4G内存下的256M空间</span><br>((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) (ELFHDR-&gt;e_entry))(); <span class="hljs-comment">// 汇编指令是 call   *0x10018   // *代表取出0x10018中的内容（0x10000c）， call然后跳转</span><br>  <span class="hljs-number">0x10018</span>是在elf header中，这个位置对应的就是第一个程序的入口地址（ELFHDR-&gt;e_entry）<br></code></pre></td></tr></table></figure><p><strong>e_entry字段指向的是这个文件的执行入口地址，也就是真正的内核程序，call指令就是跳转过去执行。 自此就把控制权从boot loader转交给了操作系统的内核。</strong></p><h4 id="进入真正的内核程序"><a href="#进入真正的内核程序" class="headerlink" title="进入真正的内核程序"></a>进入真正的内核程序</h4><p>我们先看看这个内核程序在哪（上面我们说了在0x100000）,执行下面的指令，发现确实正确，但是我们注意一下，VMA（链接地址）是f0100000这个其实就是编译器链接的地址，<strong>其实可以理解成虚拟地址</strong>，后面的LMA才是真正的物理地址</p><p>![image-20230303171954183](mit 6.828.assets/image-20230303171954183.png)</p><p><strong>objdump -x obj/kern/kernel</strong>可以查看Program header table</p><p>![img](mit 6.828.assets/809277-20160225131553240-877979384.png)</p><p>其中Program Header中列出的是所有被加载到内存中的段的信息，这也是Program Headers Table的表项。每一个表项图中都把这个表项中涉及到的所有字段都列出来了。可见有一些段最后没有被加入到内存之中。在上图中，那些需要被加载到内存的段被标记为LOAD。</p><p>我们之前知道了bootloader程序的链接地址和物理地址都是在0x7c00.</p><blockquote><p>下面我们开始分析真正的内核程序，在entry.S文件中</p></blockquote><blockquote><p><strong>但是我们先了解一下什么是虚拟地址和物理地址以及分页分段概念</strong></p></blockquote><h5 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h5><p><strong>操作系统内核程序在虚拟地址空间通常会被链接到一个非常高的虚拟地址空间处，比如0xf0100000，目的就是能够让处理器的虚拟地址空间的低地址部分能够被用户利用来进行编程。</strong></p><p>但是许多的机器其实并没有能够支持0xf0100000这种地址那么大的物理内存，所以我们不能把内核的0xf0100000虚拟地址映射到物理地址0xf0100000的存储单元处。</p><p>　　这就造成了一个问题，在我们编程时，我们应该把操作系统放在高地址处，但是在实际的计算机内存中却没有那么高的地址，这该怎么办？</p><p>　　解决方案就是在虚拟地址空间中，我们还是把操作系统放在高地址处0xf0100000，但是在实际的内存中我们把操作系统存放在一个低的物理地址空间处，如0x00100000。那么当用户程序想访问一个操作系统内核的指令时，首先给出的是一个高的虚拟地址，然后计算机中通过某个机构把这个虚拟地址映射为真实的物理地址，这样就解决了上述的问题。那么这种机构通常是通过分段管理，分页管理来实现的。</p><blockquote><p>分段模式</p></blockquote><p>分段模式下没有虚拟地址一说，就是每个程序的段基本上都是放在一起的，然后此时进程A和进程B记忆进程C正在内存中运行，这个时候进程C关掉了，就会释放占用的内存，假如在A和B之间，此时D想要进来，但是D的大小比C大就无法利用刚才的内存，只能等待更多的空间，这就造成了浪费。</p><p>![image-20230303211137237](mit 6.828.assets/image-20230303211137237-167784909884623.png)</p><p>分段模式下如何访问地址的：</p><p>首先是先通过段选择子找到段描述符（在GDT中），在段的描述符中存着段基址，然后段基址加上段内偏移地址就能够找到物理地址了</p><img src="/2022/10/18/mit-6.828/image-20230303212017076-167784961861625.png" alt="image-20230303212017076" style="zoom:50%;"><blockquote><p>分页模式</p></blockquote><p>通过将内存空间分成一个个的page，每个page是一个4096字节的空间，然后如果加载一个进程，就将这个进程放在不同的分散的各个页当中，然后通过一个页表记录虚拟地址和物理地址的映射关系。</p><p>![image-20230303215129867](mit 6.828.assets/image-20230303215129867-167785149089327.png)</p><p><strong>在页表中，每个地址大小都是占4个字节，32为，因为每一个页大小是4092字节，所以地址的后12位都是0，这个12位用来作为这个页的访问权限，比如页读写的权限等。</strong></p><p>![image-20230307133653843](mit 6.828.assets/image-20230307133653843.png)</p><p>那个页表寄存器是CR3寄存器，存着页目录表的地址（物理地址）。</p><p>页表是存储在内存里的，<strong>内存管理单元</strong> （<em>MMU</em>）就做将虚拟内存地址转换成物理地址的工作。</p><p>开启分页模式步骤：</p><ul><li>先准备好页目录表和页表</li><li>将页目录表的地址写入到控制寄存器cr3寄存器中</li><li>寄存器cr0的PG位置1</li></ul><blockquote><p>每个进程都有自己的页目录表和页表，操作系统也有自己的页目录表和页表</p></blockquote><h5 id="分析程序"><a href="#分析程序" class="headerlink" title="分析程序"></a>分析程序</h5><p>位于entry.s文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 取出页目录表的地址，并放进cr3寄存器中 这个时候我们就设定好了页目录表</span><br>movl$(RELOC(entry_pgdir)), %eax      <span class="hljs-comment">#  entry_pgdir在0xf0111000</span><br>movl%eax, %cr3<br><span class="hljs-comment"># Turn on paging. </span><br><span class="hljs-comment"># 开启分页模式，这个时候指令的地址都是虚拟地址了，需要进行映射，映射的过程交给MMU来完成，</span><br><span class="hljs-comment"># 因为我们已经设置好了页目录表和页表，并把页目录表的地址给了cr03，MMU会自动将寻址时的地址转化为对应的物理地址，然后交给总线去寻址</span><br>movl%cr0, %eax  <br>orl$(CR0_PE|CR0_PG|CR0_WP), %eax <span class="hljs-comment"># 给寄存器cr0的PG位置置1</span><br>movl%eax, %cr0<br><br><span class="hljs-comment"># Now paging is enabled, but we&#x27;re still running at a low EIP</span><br><span class="hljs-comment"># (why is this okay?).  Jump up above KERNBASE before entering</span><br><span class="hljs-comment"># C code.</span><br>mov<span class="hljs-variable">$relocated</span>, %eax<br>jmp*%eax<br></code></pre></td></tr></table></figure><p>页目录表和页表我们已经设置好了，以两个数组设置完成的</p><p>获取页目录表的地址，并存入到cr3寄存器中，然后给cr0 PG位置1</p><p>这样就开启了正在页表，进入分页模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">relocated:<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从这里开始我们就正式进入了分页模式</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Clear the frame pointer register (EBP)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">so that once we get into debugging C code,</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">stack backtraces will be terminated properly.</span><br>movl$0x0,%ebp# nuke frame pointer  为什么将栈基址设置位0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Set the stack pointer</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过反汇编我们知道 0xf0110000 是栈顶</span><br>movl$(bootstacktop),%esp    # 栈顶地址设置完成<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从这里我们就进入了C语言代码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">now to C code</span><br>calli386_init<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Should never get here, but <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span> we <span class="hljs-keyword">do</span>, just spin.</span><br>spin:jmpspin<br><br><br>.data<br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################################################################</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">boot stack</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment">##################################################################</span></span><br>.p2alignPGSHIFT# force page alignment<br>.globlbootstack<br>bootstack:<br>.spaceKSTKSIZE  # 分配4096字节<br>.globlbootstacktop   <br>bootstacktop:<br></code></pre></td></tr></table></figure><p>上面是对内核栈的初始化：</p><p><strong>内核在哪里初始化它的栈，栈在内存的什么地方？内核是怎样给栈保存空间的？栈初始指针是指向保留区域的哪一端？</strong></p><p>在entry.s 的数据段中.space size表示生成size个字节，说明内核给栈保存了KSTKSIZE的空间，由宏定义#define KSTKSIZE (8*PGSIZE)和#define PGSIZE 4096可知该空间大小为32k</p><p>由于栈由高地址向低地址生长，所以指针指向高地址0xf0110000那一端</p><h5 id="entry-s做了哪些事情"><a href="#entry-s做了哪些事情" class="headerlink" title="entry.s做了哪些事情"></a>entry.s做了哪些事情</h5><ul><li><p><strong>开启了分页模式</strong>    #  entry_pgdir在0xf0111000（物理地址0x111000），页表不知道在哪</p></li><li><p><strong>初始化了内核的栈</strong> # 栈顶的位置在0xf0110000）（物理地址0x110000）</p></li></ul><h4 id="进入init-c"><a href="#进入init-c" class="headerlink" title="进入init.c"></a>进入init.c</h4><blockquote><p>首先是初始化一些设备，用来实现printf函数</p></blockquote><p>![img](mit 6.828.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc2MTQ3OA==,size_16,color_FFFFFF,t_70.png)</p><p>基本流程：</p><p>kern/monitor.c的作用是实现内核与用户的交互。阅读monitor.c，发现它是直接调用printf.c中的cprintf（）来在屏幕上输出，接下来的调用顺序是：cprintf()-&gt;vcprintf（）-&gt;printfmt.c中的vprintfmt（）-&gt;printf.c中的putch()-&gt;console.c中的cputchar()-&gt;cons_putc（）。由注释知最后这个cons_putc()函数的作用是输出一个字符到控制台。</p><h5 id="分析方法调用的时候入栈和出栈的流程"><a href="#分析方法调用的时候入栈和出栈的流程" class="headerlink" title="分析方法调用的时候入栈和出栈的流程"></a><strong>分析方法调用的时候入栈和出栈的流程</strong></h5><blockquote><p>首先先介绍两个寄存器 esp 和 ebp</p></blockquote><p><strong>X86堆栈指针寄存器（%esp）</strong>指向的是整个堆栈中正在被使用的部分的最低地址。在这个地址之下的更低的地址空间都是还没有被利用的堆栈空间。当计算机要完成把一个值压入堆栈的动作时，通常它需要先把堆栈指针寄存器中的值减1（有时候是减4，由机器字长决定），然后把需要压入的值存放到当前堆栈指针寄存器所指向的新的内存单元。而从堆栈中弹出一个值的操作，则需要计算机首先从堆栈寄存器所指向的内存单元读取一个数据，然后把堆栈寄存器的值加1（有时候是加4）。在32bit模式下，每一次对堆栈的操作都是以32bit为单位的，所以%esp中的值永远都是可以被4整除的。</p><p><strong>而ebp寄存器</strong>则是记录每一个程序的栈帧的相关信息的一个非常重要的寄存器。他可以理解为每一个栈帧的边界，ebp到esp之间的空间就是代表着当前栈帧（这个函数）的占用的空间，用来存放一些临时变量、调用其他函数的参数、以及其他函数执行完后的返回地址等。假如我们想调用一个函数（<strong>会执行call等指令</strong>），那么先做的事情就是将被调用函数的参数从右往左以此压入栈中，然后再压入被调用函数指向完后的返回地址，然后再把自己这个栈帧的ebp内容存放到栈中，然后更新ebp值为esp的值，这样就进入了下一个栈帧，就可以存放被调用函数运行时的局部变量等。</p><p>当函数执行完成之后（<strong>会调用ret等指令</strong>），他会将ebp的值传入到esp中（相当于指向ebp指向的地址了，这个ebp指向的地址内容是上一个栈帧的ebp旧值），这样就相当于释放了栈帧，然后再把ebp恢复为原来的</p><p>值，这样就恢复了原来函数的栈帧（ebp恢复了），然后再获取返回的地址，让eip寄存器指向原来调用函数的地方继续执行。</p><p>![img](mit 6.828.assets/809277-20160229215738095-1864590140.jpg)</p><p>![img](mit 6.828.assets/lab1_5_gcc过程调用2.png)</p><p><strong>以下是函数执行的细节</strong>：</p><blockquote><ol><li>执行call指令前，<strong>函数调用者</strong>将参数入栈，按照<strong>函数列表从右到左</strong>的顺序入栈</li><li>call指令会自动将当前eip入栈，ret指令将自动从栈中弹出该值到eip寄存器</li><li><strong>被调用函数</strong>负责：将ebp入栈，esp的值赋给ebp（进入函数时）。所以反汇编一个函数会发现开头两个指令都是<code>push %ebp, mov %esp,%ebp</code>。 将ebp的值赋值给esp，将ebp赋值为原来的值（出函数时）。就是上面那两个青色图，都是由被调用函数负责。</li></ol></blockquote><h5 id="最终内存"><a href="#最终内存" class="headerlink" title="最终内存"></a>最终内存</h5><blockquote><p>0xffffffff|4GB<br>———-|32-bit memory mapped devices<br>0xf0110000|bootstacktop<br>0xf0100c04|debuginfo_eip<br>0xf0100b00|cprintf                      ==&gt; 内核代码<br>0xf0100ac9|vcprintf<br>0xf0100883|mon_backtrace<br>0xf01000a6|i386_init<br>0xf0100040|test_backtrace<br>0xf010000c|entry kernel<br>0x00100000|<strong>开始加载内核</strong><br>———-|<br>0x000F0000|BIOS ROM<br>———-|16-bit expansion ROMs<br>0x000C0000|<br>0x000A0000|VGA Display<br>———-|<br>0x00007d6b|<strong>准备将控制权交给内核</strong><br>0x00007c45|调用bootmain                 ==&gt; Low Memory  这里是boot loader引导程序<br>0x00007c2d|处理器切换为32-bit模式<br>0x00007c00|boot开始的位置<br>———-|<br>0x00000000|0</p></blockquote><p>lab1到这里就基本结束了。</p><h2 id="lab2"><a href="#lab2" class="headerlink" title="lab2"></a>lab2</h2><p>经历过lab1之后我们的物理内存分配大概是怎么样的？</p><p>![img](mit 6.828.assets/20160519183449981.png)</p><p>![image-20230304163216000](mit 6.828.assets/image-20230304163216000-167791873698139.png)</p><blockquote><p>本实验要讲述的内容：</p></blockquote><p>第一个是物理内存管理，就是我们现在找到这个物理内存有多大，然后哪些物理内存是使用过的，哪些内存没有被使用。</p><p>第二是实现虚拟内存和物理内存的映射（也就是建立页表映射关系），实现一些函数操作页目录表和页表实现虚拟内存和物理内存之间的映射</p><p>第三部分讲的是内核的地址空间，将内核的虚拟地址映射到指定的物理地址上</p><h3 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h3><blockquote><p>空闲的物理内存如何管理的</p></blockquote><p>本文通过的是一个PageInfo[]数组来记录整个内存空间，（每一个代表一个page，按照顺序逐一对应）每个PageInfo相当于一个链表的节点，通过将代表的空闲的PageInfo给连接到一起构造一个链表，然后链表的头记录在一个特殊的节点上page_free_list，每次想要分配页，就从这个链表上取走一个节点，如果使用完毕，将那个页对应的pageInfo节点插入到这个链表中。</p><p>每一个pageInfo的内容是一个指向下一个节点的指针和一个引用该对应页面的个数。这个数组存放在哪里呢？<strong>在内核程序结束后再隔一个页目录表大小的地方</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">pages = (<span class="hljs-keyword">struct</span> PageInfo*)boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages);<span class="hljs-comment">//分配足够大的空间(PGSIZE的倍数)保存pages数组</span><br></code></pre></td></tr></table></figure><p>然后我们初始化这个链表使用page_init()函数：</p><ul><li><strong>就是将basemem空间和extmem空间的空闲的page给构建一个链表</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">size_t</span> io_hole_start_page = (<span class="hljs-type">size_t</span>)IOPHYSMEM / PGSIZE;<br><span class="hljs-type">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt;= io_hole_start_page &amp;&amp; i &lt; kernel_end_page) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == MPENTRY_PADDR / PGSIZE) &#123;<br><span class="hljs-comment">//之所以在这判断一下，是因为后面多处理器的APs启动时的程序要放在这里，所以要把这里标志使用，防止后面被分配走</span><br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list;<br>page_free_list = &amp;pages[i];<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="页目录表和页表设置"><a href="#页目录表和页表设置" class="headerlink" title="页目录表和页表设置"></a>页目录表和页表设置</h3><p>我们在前面已经知道了，我们设置了页目录表entry_pgdir和页表，但是这个页表我们只是映射了从KERNBASE之上的4M空间到物理地址的0-4M空间，这明显是不够的，我们需要重新进行映射。</p><p>我们重新申请一个页作为页目录表，<strong>如下,它紧跟在内核程序存放位置之后。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">kern_pgdir = (<span class="hljs-type">pde_t</span> *) boot_alloc(PGSIZE); <span class="hljs-comment">// 这个紧跟着操作系统内核之后，但是返回的是虚拟地址</span><br></code></pre></td></tr></table></figure><h4 id="如何完成虚拟地址到内存地址的映射"><a href="#如何完成虚拟地址到内存地址的映射" class="headerlink" title="如何完成虚拟地址到内存地址的映射"></a>如何完成虚拟地址到内存地址的映射</h4><blockquote><p><code>struct PageInfo * page_alloc(int alloc_flags)</code></p></blockquote><p>这个函数主要是从空闲链表中分配一个空闲页</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//从空闲链表中拿出一个页并初始化页内容都是&#x27;\0&#x27;</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-keyword">if</span>(page_free_list == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">temp</span>;</span><br>temp = page_free_list;<br>page_free_list = page_free_list-&gt;pp_link;<br>temp-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;<br><span class="hljs-comment">//获取虚拟地址?</span><br><span class="hljs-type">void</span> *va = page2kva(temp);<br><span class="hljs-built_in">memset</span>(va,<span class="hljs-string">&#x27;\0&#x27;</span>,PGSIZE);<br>&#125;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>void page_free(struct PageInfo *pp)</code></p></blockquote><p><strong>这个方法就是释放某一个页，把这个页对应的pageInfo放入到空闲链表中</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//设置这个页为空闲页</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br><span class="hljs-keyword">if</span>(pp-&gt;pp_link !=<span class="hljs-literal">NULL</span> || pp-&gt;pp_ref !=<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;page_free() : pp-pp_ref is nonzone or pp-&gt;_link is not NULL&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>pp-&gt;pp_link = page_free_list;<br>page_free_list = pp;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>pte_t * pgdir_walk(pde_t *pgdir, const void *va, int create)</code></p></blockquote><p>先介绍以下pgdir_walk函数，<strong>这个函数会查找这个va虚拟地址对应的页表（没有页表会创建一个页表），然后返回这个虚拟地址对应的页表项。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 这个函数返回的是一个页表项的地址</span><br><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">uint32_t</span> pdx = PDX(va); <span class="hljs-comment">//获取页目录项的索引</span><br><span class="hljs-type">uint32_t</span> ptx = PTX(va); <span class="hljs-comment">//获取也表项的索引</span><br><br><span class="hljs-type">pde_t</span> *pde;<span class="hljs-comment">//页目录项指针</span><br><span class="hljs-type">pte_t</span> *pte; <span class="hljs-comment">//页表指针</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span> <span class="hljs-comment">//空闲页面指针，如果不存在页表，会申请一个page</span><br><br><span class="hljs-comment">//获取页目录项</span><br>pde = &amp;pgdir[pdx];<br><span class="hljs-comment">//每个页表项或者页目录项的低12位是用来做标志位的，PTE_P表示这个项是否存在</span><br><span class="hljs-keyword">if</span>((*pde) &amp; PTE_P)&#123;<br><span class="hljs-comment">//二级页表存在</span><br><span class="hljs-comment">//因为页目录项和页表项中的存的地址都是物理地址，所以需要进行转换成虚拟地址</span><br><span class="hljs-comment">//获取页表的地址</span><br>pte = (KADDR(PTE_ADDR(*pde)));<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//二级页表不存在</span><br><span class="hljs-keyword">if</span>(create ==<span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//我们需要申请一个空闲页作为二级页表，并把这个页的地址放进页目录项中</span><br>pp = page_alloc(ALLOC_ZERO);<br><span class="hljs-keyword">if</span>(pp ==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//pte 表示指向的新申请的页的虚拟地址，并将这个页作为页表，把地址放进页目录表中</span><br>pte = (<span class="hljs-type">pte_t</span> *)page2kva(pp);<br>pp-&gt;pp_ref++;<br>*pde = (PADDR(pte) | PTE_P | PTE_W | PTE_U);  <span class="hljs-comment">// 设置页目录项</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;pte[ptx];<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><code>page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)</code></p></blockquote><p>然后我们就介绍一下这个page_insert函数，这个函数就是将一个物理page映射到一个虚拟页，并将映射关系放在页表中。</p><p>主要步骤：</p><ul><li>先获取这个虚拟地址va对应的页表项，如果这个页表项中没有指定的物理页，那么就把这个物理页的地址插入到这个页表项中</li><li>如果有之前对应的物理页地址，那么解除之前的物理页对应关系（<strong>并把那个页面个释放了–先判断页的引用是不是0了，这个和智能指针那一块比较像</strong>），这里调用了page_remove（pgdir，va）<ul><li><strong>找到这个虚拟地址对应的之前的页，然后把这页的内容清空</strong></li><li><strong>然后把这个页放入到空闲链表中去</strong></li></ul></li><li>然后把要插入的页的地址放进去</li><li>权限都别忘记修改了</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个函数就是将一个页指定映射到指定的虚拟地址（或者说找到一个页，这个页用来映射指定的虚拟地址）</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">//先获取这个页表项，看看页表项中是否存在PTE_P</span><br><span class="hljs-type">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">if</span>(pte ==<span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><br><span class="hljs-keyword">if</span>((*pte) &amp; PTE_P)&#123;<br><span class="hljs-comment">//说明这个页存在,先看看是不是和pp表示的同一个页面。如果不是就清除，是的就不清除,改改权限就行</span><br><br><span class="hljs-comment">//如果恰好pp这个页面就是此时pte指向的，那么修改一下权限就行了</span><br><span class="hljs-keyword">if</span>(PTE_ADDR(*pte) == page2pa(pp))&#123;<br>pp-&gt;pp_ref--;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>page_remove(pgdir,va);<br>&#125;<br><span class="hljs-comment">// page_remove(pgdir,va);</span><br>&#125;<br><span class="hljs-comment">//说明还没有分配，就将pp代表的页给他</span><br>*pte = (page2pa(pp) | perm |PTE_P);<br>pp-&gt;pp_ref++;<br>pgdir[PDX(va)] |= perm; <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>static void  boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)</code></p></blockquote><p>这个方法主要是在页表中物理地址pa和虚拟地址va之间的映射关系，大小是size字节的空间</p><p>主要在内核启动的时候，映射了几块地址：</p><ol><li><p><code>boot_map_region(kern_pgdir,UPAGES,PTSIZE,PADDR(pages),PTE_U);</code>将PADDR(pages)起始的物理内存映射到UPAGES虚拟地址处，<strong>方便内核程序能够直接通过UPAGES虚拟地址就获取到了pages地址内存了，也就是说编写程序的时候我们直接操作UPAGES就相当于操作pages了</strong></p></li><li><p><code>boot_map_region(kern_pgdir,UENVS,PTSIZE,PADDR(envs),PTE_U);</code></p></li><li><p><code>boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W);</code></p><p>将物理地址PADDR(bootstack)处的物理地址映射到KSTACKTOP-KSTKSIZE虚拟地址处，这个内核栈在物理地址处的位置在entry.s文件中就确定了，然后为了后面能够方便操作这个栈，我们就将虚拟地址KSTACKTOP-KSTKSIZE映射到这个地方，然后直接在程序中使用这个虚拟地址就可以操作栈了</p><p><strong>之前我们在entry.s中有一个页表，这个页表将内核栈虚拟地址（0xf0110000）映射到了物理地址（0x110000）处，也就是esp的值就是0xf0110000（经过entry.s的页表转换后就变成了0x110000）了，现在我们重新有了一个页表kern_pgdir，然后为了规定虚拟地址0xf0000000下的虚拟地址空间作为内核栈，但是物理地址还是之前的那个栈，所以就重新设定了虚拟地址和物理地址的关系（因为可能在接下来的编程中对栈的操作（编译后的地址）都是采用的新的虚拟地址，而不是之前的0xf0110000了）</strong></p></li><li><p><strong><code>boot_map_region(kern_pgdir,KERNBASE,0xffffffff - KERNBASE,0,PTE_W);</code></strong></p><p>这个是完成对内核空间的映射，虚拟地址KERNBASE以上的地址都是给内核程序用的，就是编译器会将内核的程序地址都链接到这个地址以上，然后这个地址对应的物理地址是0-0xffffffff - KERNBASE（0-256M）空间。</p><blockquote><p>【注意】：我们通过npages知道了这个qemu总共的物理内存是128MB，而这个内核程序虚拟地址就占用了256MB，这个为什么，那岂不是连内核用的程序都不够了？</p><p>我们要注意，下面这函数虽然是将KERNBASE以上的256MB映射到了物理地址上，但是这个映射关系只是存在了页表中，并没有将对应的pageinfo的ref字段给增加（并没有将空闲链表上的pageinfo都给取下来了），所以这个只是映射了静态的地址关系，主要目的就是方便通过虚拟地址找到一些物理空间，之前使用过的空间，比如kernbase程序，pages等占用 pageinfo都给拿掉了，这个才是维护真正的物理空间（也只有page_insert才会从pageinfo中拿空闲的，然后把物理地址和内存地址的关系放在页表中）。</p></blockquote></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个方法是将UTOP上面的区域都映射到了指定的区域，直接定死了</span><br><span class="hljs-comment">// 完成虚拟地址到物理地址的映射（也就是把虚拟地址和物理地址的映射关系存在页表中）</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">//获取页表项的地址</span><br><span class="hljs-type">pte_t</span> *pte =<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i= i + PGSIZE)&#123;<br><span class="hljs-comment">//根据这个虚拟地址，获取页表项地址，如果不存在或者超过了一个页表的大小，会重新创建</span><br>pte = pgdir_walk(pgdir,(<span class="hljs-type">void</span> *)va,<span class="hljs-literal">true</span>);<br><span class="hljs-comment">//给页表项赋映射的地址</span><br>*pte = (pa|perm|PTE_P); <span class="hljs-comment">//PTE_P表示存在，perm表示访问页面的权限，因为低12位是用来作为标志位的，高20位用来做地址</span><br>pa += PGSIZE;<br>va += PGSIZE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内存布局与映射关系"><a href="#内存布局与映射关系" class="headerlink" title="内存布局与映射关系"></a>内存布局与映射关系</h4><p>JOS将线性地址空间分为两部分，由定义在inc/memlayout.h中的ULIM分割。ULIM以上的部分用户没有权限访问，内核有读写权限。</p><p>![内核虚拟地址空间到物理地址空间映射](mit 6.828.assets/lab2_5_lab2后虚拟地址空间到物理地址空间映射.png)</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.提供管理物理内存的函数和数据结构：</p><p>![JOS物理内存管理](mit 6.828.assets/lab2_7_总结_物理内存管理.png)</p><p>2.提供一个页表完成对虚拟地址和物理地址之间的映射</p><p>![JOS页表管理](mit 6.828.assets/lab2_8_总结_页表管理函数.png)</p><p>3.映射内核的线性地址空间到物理地址空间</p><p>![JOS内核线性地址空间按](mit 6.828.assets/lab2_5_lab2后虚拟地址空间到物理地址空间映射-167801655399147.png)</p><blockquote><p><strong>最终：现在我们可以直接使用UPAGES这个虚拟地址直接访问pages数组，使用UVPT访问内核页目录表，使用KSTACKTOP访问内核栈。</strong></p></blockquote><h3 id="linux的内存管理是怎么实现的？"><a href="#linux的内存管理是怎么实现的？" class="headerlink" title="linux的内存管理是怎么实现的？"></a>linux的内存管理是怎么实现的？</h3><p>如何实现空闲页的管理（申请和释放的）；也是通过链表吗？</p><h2 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h2><h3 id="User-Environments"><a href="#User-Environments" class="headerlink" title="User Environments"></a>User Environments</h3><p>这里的environment相当于unix中的进程的概念。</p><p>Jos使用ENV数据结构记录用户环境，这个lab3先支持一个用户环境，接下来会实现多用户环境，以及用户环境之间的。</p><p>内核维护了三个全局变量：</p><ol><li>struct Env *envs = NULL;  这个表示所有的用户进程</li><li>struct Env * curenv = NULL; 指向当前的用户进程</li><li>static struct Env *env_free_list  指向空闲的用户环境（和pages数组一样）</li></ol><p>和lab2管理物理页的思路一样，envs指向一个ENV结构的数组，curenv指向当前正在运行的环境， env_free_list指向一个ENV结构的链表，保存未在运行的环境。</p><blockquote><p>envs数组空间的分配和pages数组空间的分配在一起的，紧跟在pages数组的后面，然后将内核虚拟地址的UENVS映射到envs，方便后面操作。</p><p><code>envs = (struct Env*)boot_alloc(sizeof(struct Env) * NENV); </code></p><p><code>memset(envs, 0, sizeof(struct Env) * NENV);</code></p><p><code>boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</code></p></blockquote><p>ENV结构定义在inc/env.h中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">env_tf</span>;</span><span class="hljs-comment">// Saved registers // 用来保存当进程切换时进程的状态信息，方便后面恢复</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env_link</span>;</span><span class="hljs-comment">// Next free Env</span><br><span class="hljs-type">envid_t</span> env_id;<span class="hljs-comment">// Unique environment identifier</span><br><span class="hljs-type">envid_t</span> env_parent_id;<span class="hljs-comment">// env_id of this env&#x27;s parent</span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnvType</span> <span class="hljs-title">env_type</span>;</span><span class="hljs-comment">// Indicates special system environments</span><br><span class="hljs-type">unsigned</span> env_status;<span class="hljs-comment">// Status of the environment  </span><br><span class="hljs-type">uint32_t</span> env_runs;<span class="hljs-comment">// Number of times environment has run</span><br><span class="hljs-type">int</span> env_cpunum;<span class="hljs-comment">// The CPU that the env is running on</span><br><br><span class="hljs-comment">// Address space</span><br><span class="hljs-type">pde_t</span> *env_pgdir;<span class="hljs-comment">// Kernel virtual address of page dir</span><br><br><span class="hljs-comment">// Exception handling</span><br><span class="hljs-type">void</span> *env_pgfault_upcall;<span class="hljs-comment">// Page fault upcall entry point</span><br><br><span class="hljs-comment">// Lab 4 IPC</span><br><span class="hljs-comment">//当进程使用env_ipc_recv函数等待信息时，会将这个成员设置为1，然后堵塞等待；当一个进程向它发消息解除堵塞后，发送进程将此成员修改为0。</span><br><span class="hljs-type">bool</span> env_ipc_recving;<span class="hljs-comment">// Env is blocked receiving  </span><br><span class="hljs-comment">//如果进程要接受消息并且是传送页，保存页映射的地址，且该地址&lt;=UTOP</span><br><span class="hljs-type">void</span> *env_ipc_dstva;<span class="hljs-comment">// VA at which to map received page</span><br><span class="hljs-comment">//若等待消息的进程接收到消息，发送方将接收方此成员设置为消息值。</span><br><span class="hljs-type">uint32_t</span> env_ipc_value;<span class="hljs-comment">// Data value sent to us</span><br><br><span class="hljs-type">envid_t</span> env_ipc_from;<span class="hljs-comment">// envid of the sender</span><br><span class="hljs-comment">//如果进程要接收消息并且传送页，那么发送方发送页之后将传送的页权限赋给这个成员。</span><br><span class="hljs-type">int</span> env_ipc_perm;<span class="hljs-comment">// Perm of page mapping received</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="内存空间映射"><a href="#内存空间映射" class="headerlink" title="内存空间映射"></a>内存空间映射</h3><p>![image-20230306113621738](mit 6.828.assets/image-20230306113621738.png)</p><h3 id="进程创建和释放过程"><a href="#进程创建和释放过程" class="headerlink" title="进程创建和释放过程"></a>进程创建和释放过程</h3><blockquote><p>env_init():这个方法用来初始化这个envs链表，并初始化GDT描述符表段选择子</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Set up envs array</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br>env_free_list = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<span class="hljs-comment">//前插法构建链表</span><br>envs[i].env_id = <span class="hljs-number">0</span>;<br>envs[i].env_link = env_free_list;<br>env_free_list = &amp;envs[i];<br>&#125;<br><span class="hljs-comment">// Per-CPU part of the initialization</span><br>env_init_percpu();<br>&#125;<br><br><span class="hljs-comment">// Load GDT and segment descriptors.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>lgdt(&amp;gdt_pd);<br><span class="hljs-comment">// The kernel never uses GS or FS, so we leave those set to</span><br><span class="hljs-comment">// the user data segment.</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%gs&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_UD|<span class="hljs-number">3</span>))</span>;<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%fs&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_UD|<span class="hljs-number">3</span>))</span>;<br><span class="hljs-comment">// The kernel does use ES, DS, and SS.  We&#x27;ll change between</span><br><span class="hljs-comment">// the kernel and user data segments as needed.</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%es&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_KD))</span>;<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%ds&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_KD))</span>;<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movw %%ax,%%ss&quot;</span> : : <span class="hljs-string">&quot;a&quot;</span> (GD_KD))</span>;<br><span class="hljs-comment">// Load the kernel text segment into CS.</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;ljmp %0,$1f\n 1:\n&quot;</span> : : <span class="hljs-string">&quot;i&quot;</span> (GD_KT))</span>;<br><span class="hljs-comment">// For good measure, clear the local descriptor table (LDT),</span><br><span class="hljs-comment">// since we don&#x27;t use it.</span><br>lldt(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>初始化和创建env_free_list很简单，我们来分析一下env_init_percpu这个函数。</li><li>内核运行到这里，还没有加载过GDT。在内核还未加载到内存之前，boot.S于进入保护模式前加载过一次GDT，那个表中只安装了代码段和数据段两个段描述符。</li><li>boot.S中通过ljmp跳转指令使cs的索引值指向代码段描述符，并将选择子ds、es、fs、gs和ss的索引值均设置为指向数据段描述符，至此这些段选择子均不曾被更改过。</li><li>现在我们要创建进程，而原先的GDT中并没有<strong>特权级为3</strong>的数据段和代码段描述符，所以我们必须加载一个新的GDT。</li><li>env_init_percpu使用内联汇编语句，我们可以回头参考一下课程网站上的相关资料。简而言之，env_init_percpu重新加载了GDT，并设置了各个段选择子。注意，这里做的指示初始化的工作，并没有真正进入用户环境。</li><li>因此函数只将fs、gs指向了用户的数据段描述符（？），其余寄存器仍然指向内核的段描述符，等到准备进入用户环境时才会更改其余段选择子。另外，JOS不使用局部描述符表LDT。</li></ul><blockquote><p>关于特权级问题，我们待会再来补充</p></blockquote><blockquote><p>env_setuo_vm(): <strong>这个是为了给这个进程申请一个页目录表，然后将内核的页目录表的内容复制过来，然后再把UVPT虚拟地址对应的物理地址设置为当前进程的页目录表地址</strong></p><ul><li>为什么直接把UVPT对应的页目录项设置为页目录表的物理地址，因为UVPT = 0xef400000</li><li>中间10位和后12位都是0，页目录表又充当了页表，并且获取了页表的第0项，就是页目录表的地址。</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Initialize the kernel virtual memory layout for environment e.</span><br><span class="hljs-comment">// Allocate a page directory, set e-&gt;env_pgdir accordingly,</span><br><span class="hljs-comment">// and initialize the kernel portion of the new environment&#x27;s address space.</span><br><span class="hljs-comment">// Do NOT (yet) map anything into the user portion</span><br><span class="hljs-comment">// of the environment&#x27;s virtual address space.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Returns 0 on success, &lt; 0 on error.  Errors include:</span><br><span class="hljs-comment">//-E_NO_MEM if page directory or table could not be allocated.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// Allocate a page for the page directory</span><br><span class="hljs-comment">//申请一个页表当作用户进程的页目录表</span><br><span class="hljs-keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br><br><span class="hljs-comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//    - The VA space of all envs is identical above UTOP</span><br><span class="hljs-comment">//(except at UVPT, which we&#x27;ve set below).</span><br><span class="hljs-comment">//See inc/memlayout.h for permissions and layout.</span><br><span class="hljs-comment">//Can you use kern_pgdir as a template?  Hint: Yes.</span><br><span class="hljs-comment">//(Make sure you got the permissions right in Lab 2.)</span><br><span class="hljs-comment">//    - The initial VA below UTOP is empty.</span><br><span class="hljs-comment">//    - You do not need to make any more calls to page_alloc.</span><br><span class="hljs-comment">//    - Note: In general, pp_ref is not maintained for</span><br><span class="hljs-comment">//physical pages mapped only above UTOP, but env_pgdir</span><br><span class="hljs-comment">//is an exception -- you need to increment env_pgdir&#x27;s</span><br><span class="hljs-comment">//pp_ref for env_free to work correctly.</span><br><span class="hljs-comment">//    - The functions in kern/pmap.h are handy.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-comment">//确定用户页目录表的虚拟地址</span><br>e-&gt;env_pgdir = (<span class="hljs-type">pde_t</span> *)page2kva(p);<br><br><br><span class="hljs-comment">//将UTOP以下的虚拟地址对应的页目录项都赋值0</span><br><span class="hljs-comment">// for(int i=0;i&lt;PDX(UTOP);i++)&#123;</span><br><span class="hljs-comment">// e-&gt;env_pgdir[i] = 0;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-comment">//所有进程的内核虚拟空间，都会被映射到之前操作系统程序的内核虚拟空间映射到的地方，</span><br><span class="hljs-comment">//其实就是将内核的页目录表的UTOP对应的页目录项复制到各个用户进程的页目录表的相同的位置，这样，当用户进程访问自己的内核虚拟地址的时候</span><br><span class="hljs-comment">//就会被映射到实际的内核程序的存储的物理地址</span><br><br><span class="hljs-comment">//将UTOP之上的虚拟地址的页目录项设置为内核页目录表相同的页目录项的值</span><br><span class="hljs-built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);<br>p-&gt;pp_ref++;<br><span class="hljs-comment">// UVPT maps the env&#x27;s own page table read-only.</span><br><span class="hljs-comment">// Permissions: kernel R, user R</span><br>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>region_alloc(): 内存申请，为进程e申请len长度的内存，并将虚拟地址va和物理地址pa的对应关系放在e的页表中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Allocate len bytes of physical memory for environment env,</span><br><span class="hljs-comment">// and map it at virtual address va in the environment&#x27;s address space.</span><br><span class="hljs-comment">// Does not zero or otherwise initialize the mapped pages in any way.</span><br><span class="hljs-comment">// Pages should be writable by user and kernel.</span><br><span class="hljs-comment">// Panic if any allocation attempt fails.</span><br><span class="hljs-comment">// 完成用户程序的虚拟地址和物理地址的映射，也就是设置好了env_pgdir</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">region_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-comment">// (But only if you need it for load_icode.)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hint: It is easier to use region_alloc if the caller can pass</span><br><span class="hljs-comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span><br><span class="hljs-comment">//   You should round va down, and round (va + len) up.</span><br><span class="hljs-comment">//   (Watch out for corner-cases!)</span><br><span class="hljs-comment">//向下取整，找到va所在的页的起始虚拟地址</span><br><span class="hljs-type">void</span> *start = (<span class="hljs-type">void</span> *)ROUNDDOWN((<span class="hljs-type">uint32_t</span>)va,PGSIZE);<br><span class="hljs-type">void</span> *end = (<span class="hljs-type">void</span> *)ROUNDUP((<span class="hljs-type">uint32_t</span>)(va) + len,PGSIZE);<br><br><span class="hljs-comment">//开始找空闲页进行映射</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br><span class="hljs-type">void</span> *i;<br><span class="hljs-type">int</span> r = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(i = start;i&lt;end;i += PGSIZE)&#123;<br><span class="hljs-comment">//从空闲链表中拿出一个页出来</span><br>pp = page_alloc(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span>(pp ==<span class="hljs-literal">NULL</span>)&#123;<br>panic(<span class="hljs-string">&quot;PageInfo allocation is failed&quot;</span>);<br>&#125;<br><span class="hljs-comment">//将指定的虚拟地址 i 和指定的物理地址进行映射</span><br>r = page_insert(e-&gt;env_pgdir,pp,i,PTE_W | PTE_U);<br><span class="hljs-keyword">if</span>(r!=<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;region alloc failed&quot;</span>);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>load_icode() :  将env的elf文件加载到内存中，</p><p>通过读取elf文件的elf header 和 program header table 将各个段读进来（先分配物理内存空间，然后将内容加载到指定的物理空间，这个时候使用的是memset和memove函数，因为在申请内存空间的时候，就将e的页表设置完成了，所以当我们操作mem这种函数时，要将内核的页表切换成e的页表，这样才能正确找到虚拟地址对应的物理地址）</p><p>最后加载完成之后，要为这个e分配一个栈物理内存（在物理空间选择对应的大小）然后映射到虚拟地址USTACKTOP -PGSIZE，供给这个进程使用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Set up the initial program binary, stack, and processor flags</span><br><span class="hljs-comment">// for a user process.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function loads all loadable segments from the ELF binary image</span><br><span class="hljs-comment">// into the environment&#x27;s user memory, starting at the appropriate</span><br><span class="hljs-comment">// virtual addresses indicated in the ELF program header.</span><br><span class="hljs-comment">// At the same time it clears to zero any portions of these segments</span><br><span class="hljs-comment">// that are marked in the program header as being mapped</span><br><span class="hljs-comment">// but not actually present in the ELF file - i.e., the program&#x27;s bss section.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// All this is very similar to what our boot loader does, except the boot</span><br><span class="hljs-comment">// loader also needs to read the code from disk.  Take a look at</span><br><span class="hljs-comment">// boot/main.c to get ideas.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Finally, this function maps one page for the program&#x27;s initial stack.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// load_icode panics if it encounters problems.</span><br><span class="hljs-comment">//  - How might load_icode fail?  What might be wrong with the given input?</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">uint8_t</span> *binary)</span><br>&#123;<br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//  Load each program segment into virtual memory</span><br><span class="hljs-comment">//  at the address specified in the ELF segment header.</span><br><span class="hljs-comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span><br><span class="hljs-comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span><br><span class="hljs-comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span><br><span class="hljs-comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span><br><span class="hljs-comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span><br><span class="hljs-comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span><br><span class="hljs-comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span><br><span class="hljs-comment">//  Use functions from the previous lab to allocate and map pages.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  All page protection bits should be user read/write for now.</span><br><span class="hljs-comment">//  ELF segments are not necessarily page-aligned, but you can</span><br><span class="hljs-comment">//  assume for this function that no two segments will touch</span><br><span class="hljs-comment">//  the same virtual page.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  You may find a function like region_alloc useful.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Loading the segments is much simpler if you can move data</span><br><span class="hljs-comment">//  directly into the virtual addresses stored in the ELF binary.</span><br><span class="hljs-comment">//  So which page directory should be in force during</span><br><span class="hljs-comment">//  this function?</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  You must also do something with the program&#x27;s entry point,</span><br><span class="hljs-comment">//  to make sure that the environment starts executing there.</span><br><span class="hljs-comment">//  What?  (See env_run() and env_pop_tf() below.)</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>,*<span class="hljs-title">eph</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> *<span class="hljs-title">header</span> =</span> (<span class="hljs-keyword">struct</span> Elf *)binary; <br><br><br><span class="hljs-keyword">if</span>(header-&gt;e_magic !=ELF_MAGIC)&#123;<br>panic(<span class="hljs-string">&quot;load_icode faild: the binary is not elf&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(header-&gt;e_entry == <span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;load_icode failed : the elf can&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//第一个程序头的地址</span><br>ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) (header) + header-&gt;e_phoff); <br><span class="hljs-comment">//最后一个程序头的截至地址</span><br>eph = ph + header-&gt;e_phnum;<br><br>lcr3(PADDR(e-&gt;env_pgdir));   <span class="hljs-comment">//load user pgdir，这句话很关键，因为memmove和memset方法必须使用这个页表来转换地址，</span><br><span class="hljs-comment">//但是现在所有运行的代码都是内核代码，位于0x100000上面</span><br><br><span class="hljs-comment">//完成代码段虚拟地址和物理地址的分配映射，以及将代码加载到指定的物理地址去</span><br><span class="hljs-keyword">for</span>(; ph &lt; eph; ph++)&#123;<br><span class="hljs-keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;<br><br><span class="hljs-keyword">if</span>(ph-&gt;p_filesz &gt; ph-&gt;p_memsz)&#123;<br>panic(<span class="hljs-string">&quot;load_icode failed : p_memsz &lt; p_filesz&quot;</span>);<br>&#125;<br><span class="hljs-comment">//ph-&gt;p_va表示本段在内存中的起始虚拟地址地址</span><br><span class="hljs-comment">//将这个代码段给映射到指定的物理地址空间，并填充对应的页表</span><br>region_alloc(e,(<span class="hljs-type">void</span> *)ph-&gt;p_va,ph-&gt;p_memsz);<br><span class="hljs-comment">//将binary内存中的代码段加载到空闲页面的物理地址中</span><br><span class="hljs-comment">//因为上面将代码段的起始虚拟地址映射到了指定的物理地址，所以要将代码段复制到指定的物理地址去，这样在后面运行代码的时候，才能保证一致</span><br>memmove((<span class="hljs-type">void</span> *)ph-&gt;p_va,binary + ph-&gt;p_offset,ph-&gt;p_filesz);<br><span class="hljs-comment">//因为一般内存中的代码段大小大于在文件中的大小，所以多余的地方补0</span><br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class="hljs-number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);<br>&#125;<br>&#125;<br>lcr3(PADDR(kern_pgdir)); <span class="hljs-comment">//将进程的程序加载到指定的位置后，要改回来内核的页表，因为现在运行的还是内核的程序</span><br><span class="hljs-comment">//设置这个程序入口地址</span><br>e-&gt;env_tf.tf_eip = header-&gt;e_entry;<br><span class="hljs-comment">// Now map one page for the program&#x27;s initial stack</span><br><span class="hljs-comment">// at virtual address USTACKTOP - PGSIZE.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-comment">//为用户进程分配栈空间（也就是完成用户栈虚拟地址到物理地址的分配和映射）不知道分配到哪了</span><br>region_alloc(e,(<span class="hljs-type">void</span> *)(USTACKTOP -PGSIZE),PGSIZE);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>env_creat() : 创建进程</p><p>先从env_free_list中获取一个env记录当前进程，然后加载elf文件，调用前面的函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocates a new env with env_alloc, loads the named elf</span><br><span class="hljs-comment">// binary into it with load_icode, and sets its env_type.</span><br><span class="hljs-comment">// This function is ONLY called during kernel initialization,</span><br><span class="hljs-comment">// before running the first user-mode environment.</span><br><span class="hljs-comment">// The new env&#x27;s parent ID is set to 0.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *binary, <span class="hljs-keyword">enum</span> EnvType type)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br><span class="hljs-type">int</span> r;<br><span class="hljs-keyword">if</span> ((r = env_alloc(&amp;e, <span class="hljs-number">0</span>) != <span class="hljs-number">0</span>)) &#123;<br>panic(<span class="hljs-string">&quot;create env failed\n&quot;</span>);<br>&#125;<br><br>load_icode(e, binary);<br>e-&gt;env_type = type;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>env_run() 这个函数就是启动一个进程，怎么才算启动一个进程呢？</p><ul><li><p>将curenv指针指向这个进程e</p></li><li><p>设置这个进程的状态为ENV_RUNNING</p></li><li><p>然后加载这个进程的有页目录表到cr3寄存器中</p></li><li><p><strong>然后恢复之前保存的env进程环境</strong>（保存在env的Trapframe属性中）</p><p>我们看看Trapframe结构：都是保存的寄存器的值，和运行上下文环境信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">tf_regs</span>;</span><br><span class="hljs-type">uint16_t</span> tf_es;<br><span class="hljs-type">uint16_t</span> tf_padding1;<br><span class="hljs-type">uint16_t</span> tf_ds;<br><span class="hljs-type">uint16_t</span> tf_padding2;<br><span class="hljs-type">uint32_t</span> tf_trapno;<br><span class="hljs-comment">//下面这些是由硬件cpu压入到栈中的，上面的那些我们需要自己去压入，也就是要保护的环境</span><br><span class="hljs-comment">/* below here defined by x86 hardware */</span><br><span class="hljs-type">uint32_t</span> tf_err;<br><span class="hljs-type">uintptr_t</span> tf_eip;<br><span class="hljs-type">uint16_t</span> tf_cs;<br><span class="hljs-type">uint16_t</span> tf_padding3;<br><span class="hljs-type">uint32_t</span> tf_eflags;<br><span class="hljs-comment">/* below here only when crossing rings, such as from user to kernel */</span><br><span class="hljs-type">uintptr_t</span> tf_esp;<br><span class="hljs-type">uint16_t</span> tf_ss;<br><span class="hljs-type">uint16_t</span> tf_padding4;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br><span class="hljs-comment">//   1. Set the current environment (if any) back to</span><br><span class="hljs-comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="hljs-comment">//      what other states it can be in),</span><br><span class="hljs-comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span><br><span class="hljs-comment">//   3. Set its status to ENV_RUNNING,</span><br><span class="hljs-comment">//   4. Update its &#x27;env_runs&#x27; counter,</span><br><span class="hljs-comment">//   5. Use lcr3() to switch to its address space.</span><br><span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">//   registers and drop into user mode in the</span><br><span class="hljs-comment">//   environment.</span><br><br><span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br><span class="hljs-comment">//e-&gt;env_tf.  Go back through the code you wrote above</span><br><span class="hljs-comment">//and make sure you have set the relevant parts of</span><br><span class="hljs-comment">//e-&gt;env_tf to sensible values.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span>(curenv !=<span class="hljs-literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<br>curenv-&gt;env_status = ENV_RUNNABLE;<br>&#125;<br>curenv = e;<br>curenv-&gt;env_status = ENV_RUNNING;<br>curenv-&gt;env_runs++;<br><span class="hljs-comment">//将这进程的页目录表加载到cr3寄存器中</span><br>lcr3(PADDR(curenv-&gt;env_pgdir));<br><span class="hljs-comment">//进入用户环境后，将内核锁释放掉</span><br>unlock_kernel();<br><span class="hljs-comment">//进入用户环境</span><br><span class="hljs-comment">//这个函数将之前设置的e-&gt;env_tf-&gt;tf_eip弹出到eip寄存器中，这样就完成了程序的转换了。</span><br>env_pop_tf(&amp;(e-&gt;env_tf));<br><span class="hljs-comment">// panic(&quot;env_run not yet implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>对于这个env_pop_tf(&amp;(e-&gt;env_tf));这个函数十分重要，要想理解这个函数，我们必须弄清楚在切换线程的时候，cpu为我们做了什么，应保存哪些寄存器的值，保存的顺序是什么？</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Restores the register values in the Trapframe with the &#x27;iret&#x27; instruction.</span><br><span class="hljs-comment">// This exits the kernel and starts executing some environment&#x27;s code.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// This function does not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_pop_tf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-string">&quot;\tmovl %0,%%esp\n&quot;</span><span class="hljs-comment">//将%esp指向tf地址处</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;\tpopal\n&quot;</span><span class="hljs-comment">//弹出Trapframe结构中的tf_regs值到通用寄存器</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;\tpopl %%es\n&quot;</span><span class="hljs-comment">//弹出Trapframe结构中的tf_es值到%es寄存器</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;\tpopl %%ds\n&quot;</span><span class="hljs-comment">//弹出Trapframe结构中的tf_ds值到%ds寄存器</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;\taddl $0x8,%%esp\n&quot;</span> <span class="hljs-comment">/* skip tf_trapno and tf_errcode */</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;\tiret\n&quot;</span><span class="hljs-comment">//中断返回指令，具体动作如下：从Trapframe结构中依次弹出tf_eip,tf_cs,tf_eflags,tf_esp,tf_ss到相应寄存器</span></span><br><span class="hljs-params">: : <span class="hljs-string">&quot;g&quot;</span> (tf) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>panic(<span class="hljs-string">&quot;iret failed&quot;</span>);  <span class="hljs-comment">/* mostly to placate the compiler */</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>上述就是基本的进程管理和创建过程：</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">env_create() <span class="hljs-comment">// 创建进程</span><br>    --&gt;env_alloc()  <span class="hljs-comment">// 申请空间为进程创建一个页表，并维护一个env</span><br>        --&gt;env_setup_vm()<br>    --&gt;load_icode() <span class="hljs-comment">// 加载elf文件,申请空间，加载elf段</span><br>        --&gt;region_alloc()<br>env_run()  <span class="hljs-comment">// 运行进程</span><br></code></pre></td></tr></table></figure><h3 id="进程的通信和创建子进程"><a href="#进程的通信和创建子进程" class="headerlink" title="进程的通信和创建子进程"></a>进程的通信和创建子进程</h3><h3 id="linux-的进程如何管理的"><a href="#linux-的进程如何管理的" class="headerlink" title="linux 的进程如何管理的"></a>linux 的进程如何管理的</h3><h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><p>总共分为了4（0，1，2，3）个特权级 ，0级特权最高，<strong>特权级的检查都是依靠CPU来完成的</strong></p><p>CPL表示当前cpu所处的特权级别</p><p>DPL一般是在描述符中，用来表示被访问的段的特权级</p><p>RPL表示请求特权级别，一般在<strong>选择子的低两位表示</strong></p><p>当发生call ，jmp，int等指令的时候，cpu会自动的进行特权级的检查，来判断这些指令有没有权利去访问目标指令。call指令可以实现是低特权级向高特权级访问，jmp只能平级访问。</p><p>我们主要还是在意中断时候的特权级别转换。也就是从用户态转换到内核态。</p><ul><li><strong>如果是int指令触发的中断，cpu需要进行特权级检查，这个检查分为两个，一个是CPL特权必须大于中断描述符中的DPL（作为一个跳板），另一个是CPL必须小于要访问的目标段描述符中的DPL。只有这样才能继续往下运行。所以我们在设置中断描述符表的时候，一定要把系统调用的中断描述符和断点的中断描述符DPL位设置为3，因为这两个中断是可以通过int来实现的。而其他的中断描述符的DPL设置为0，防止用户通过int指令来访问。</strong></li><li>如果是外界产生的中断，那么不需要检查中断描述符的DPL，只需要检查CPL特权级小于目标段描述符的DPL。</li></ul><h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p>TSS这个是用来表示每个任务的状态的，但是一般都只是采用了它的SS0和ESP0这两个字段，这个是配合CPU来使用的，用来保存内核的栈地址，当进入内核态的时候，会将esp和ss寄存器赋值为TSS的SS0和ESP0寄存器的值，表示内核的栈。我们来举个进入中断时的步骤：</p><p>假如我们执行了int的系统调用中断，</p><ul><li>cpu首先进行特权级检查，检查中断门描述符的DPL特权级是不是小于CPL，检查目标代码段的DPL代表的特权级是不是大于CPL特权级，如果这两个检查通过，就继续往下，如果不通过会触发general protection exception </li><li><strong>然后cpu将TSS中的内核的栈地址SS0和ESP0放入到cpu的ss和esp寄存器中，然后将用户态的旧的ss和esp值要保存到内核栈中（会产生临时空间进行转换），然后再压入eflags寄存器值，以及调用中断时的cs和eip寄存器的值，然后还有可能压入错误码。</strong>这些都是cpu完成的。用来恢复中断返回时的用户态的环境</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">+--------------------+ KSTACKTOP             <br>| <span class="hljs-number">0x00000</span> | old SS   |     <span class="hljs-string">&quot; - 4</span><br><span class="hljs-string">|      old ESP       |     &quot;</span> - <span class="hljs-number">8</span><br>|     old EFLAGS     |     <span class="hljs-string">&quot; - 12</span><br><span class="hljs-string">| 0x00000 | old CS   |     &quot;</span> - <span class="hljs-number">16</span><br>|      old EIP       |     <span class="hljs-string">&quot; - 20</span><br><span class="hljs-string">|     error code     |     &quot;</span> - <span class="hljs-number">24</span> &lt;---- ESP<br>+--------------------+   <br><br></code></pre></td></tr></table></figure><p>![CPU模型](mit 6.828.assets/lab3_5_cpu模型-16781098671175.png)</p><h3 id="中断描述符表"><a href="#中断描述符表" class="headerlink" title="中断描述符表"></a>中断描述符表</h3><p>中断和异常都是保护控制转换。在Intel体系语义下，中断是一种由处理器之外的异步事件引起的保护控制转换，比如外部设备的通知。异常是由正在执行的代码引起的同步的保护控制转换，比如访问无效内存，或者除以0。<br>为了防止中断发生时，当前运行的代码不会跳转到内核的任意位置执行，x86提供了两种机制：</p><ol><li><p>中断描述符表：处理器确保异常或中断发生时，只会跳转到由内核定义的代码点处执行。x86允许256种不同的中断或异常进入点，每一个都有一个向量号，从0到255。CPU使用向量号作为IDT的索引，取出一个IDT描述符，根据IDT描述符可以获取中断处理函数cs和eip的值，从而进入中断处理函数执行。</p></li><li><p>任务状态段(TSS)：当x86异常发生，并且发生了从用户模式到内核模式的转换时，处理器也会进行栈切换。一个叫做task state segment (TSS)的结构指定了栈的位置。TSS是一个很大的数据结构，由于JOS中内核模式就是指权限0，所以处理器只使用TSS结构的ESP0和SS0两个字段来定义内核栈，其它字段不使用。那么内核如何找到这个TSS结构的呢？JOS内核维护了一个<code>static struct Taskstate ts;</code>的变量，然后在trap_init_percpu()函数中，设置TSS选择子（使用ltr指令）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init_percpu</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// The example code here sets up the Task State Segment (TSS) and</span><br><span class="hljs-comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span><br><span class="hljs-comment">// running on other CPUs because each CPU has its own kernel stack.</span><br><span class="hljs-comment">// Fix the code so that it works for all CPUs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span><br><span class="hljs-comment">//     struct CpuInfo;</span><br><span class="hljs-comment">//   - The ID of the current CPU is given by cpunum() or</span><br><span class="hljs-comment">//     thiscpu-&gt;cpu_id;</span><br><span class="hljs-comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span><br><span class="hljs-comment">//     rather than the global &quot;ts&quot; variable;</span><br><span class="hljs-comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span><br><span class="hljs-comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span><br><span class="hljs-comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span><br><span class="hljs-comment">//     from doing IO (0 is not the correct value!)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span><br><span class="hljs-comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span><br><span class="hljs-comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span><br><span class="hljs-comment">// wrong, you may not get a fault until you try to return from</span><br><span class="hljs-comment">// user space on that CPU.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 4: Your code here:</span><br>thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE); <span class="hljs-comment">// 设置内核栈位置在这TSS结构中，后面要把这个TSS地址放到CPU的寄存器(TR寄存器)中</span><br>    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;<br>thiscpu-&gt;cpu_ts.ts_iomb = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate);<br>    <span class="hljs-comment">// Initialize the TSS slot of the gdt.</span><br>    <span class="hljs-comment">// TSS Task State Segment</span><br>    gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class="hljs-type">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Taskstate) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    gdt[(GD_TSS0 &gt;&gt; <span class="hljs-number">3</span>) + cpunum()].sd_s = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// Load the TSS selector (like other segment selectors, the</span><br>    <span class="hljs-comment">// bottom three bits are special; we leave them 0)</span><br>    ltr(GD_TSS0 + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Segdesc) * cpunum());<br><br>    <span class="hljs-comment">// Load the IDT</span><br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure><p>![CPU模型](mit 6.828.assets/lab3_5_cpu模型.png)</p></li></ol><h4 id="初始化中断描述符表"><a href="#初始化中断描述符表" class="headerlink" title="初始化中断描述符表"></a>初始化中断描述符表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">/* Interrupt descriptor table.  (Must be built at run time because</span><br><span class="hljs-comment"> * shifted function addresses can&#x27;t be represented in relocation records.)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Gatedesc</span> <span class="hljs-title">idt</span>[256] =</span> &#123; &#123; <span class="hljs-number">0</span> &#125; &#125;; <span class="hljs-comment">// 运行时分配内存.bss中</span><br><br><span class="hljs-comment">/*初始化IDT中断描述符表*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">//全局描述表</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Segdesc</span> <span class="hljs-title">gdt</span>[];</span>        <br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-comment">//这些函数都是在trapentry.S中定义的，也就是所谓的trapHandler</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">th0</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th1</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th3</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th4</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th5</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th6</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th7</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th8</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th9</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th10</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th11</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th12</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th13</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th14</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th16</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">th_syscall</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">timer_handler</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">kbd_handler</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">serial_handler</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">spurious_handler</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">ide_handler</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">error_handler</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">//下面就是初始化idt表，段选择子都是内核代码段，因为这些函数都是定在内核态的，这里dpl哦有些设置为0，是因为就是在</span><br>SETGATE(idt[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, GD_KT, th0, <span class="hljs-number">0</span>);<span class="hljs-comment">//格式如下：SETGATE(gate, istrap, sel, off, dpl)，定义在inc/mmu.h中</span><br>SETGATE(idt[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, GD_KT, th1, <span class="hljs-number">0</span>);  <span class="hljs-comment">//设置idt[1]，段选择子为内核代码段，段内偏移为th1</span><br>SETGATE(idt[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>, GD_KT, th3, <span class="hljs-number">3</span>);<br>SETGATE(idt[<span class="hljs-number">4</span>], <span class="hljs-number">0</span>, GD_KT, th4, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">5</span>], <span class="hljs-number">0</span>, GD_KT, th5, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">6</span>], <span class="hljs-number">0</span>, GD_KT, th6, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">7</span>], <span class="hljs-number">0</span>, GD_KT, th7, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">8</span>], <span class="hljs-number">0</span>, GD_KT, th8, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">9</span>], <span class="hljs-number">0</span>, GD_KT, th9, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">10</span>], <span class="hljs-number">0</span>, GD_KT, th10, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">11</span>], <span class="hljs-number">0</span>, GD_KT, th11, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">12</span>], <span class="hljs-number">0</span>, GD_KT, th12, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">13</span>], <span class="hljs-number">0</span>, GD_KT, th13, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">14</span>], <span class="hljs-number">0</span>, GD_KT, th14, <span class="hljs-number">0</span>);<br>SETGATE(idt[<span class="hljs-number">16</span>], <span class="hljs-number">0</span>, GD_KT, th16, <span class="hljs-number">0</span>);<br><br>SETGATE(idt[T_SYSCALL], <span class="hljs-number">0</span>, GD_KT, th_syscall, <span class="hljs-number">3</span>);<span class="hljs-comment">//为什么门的DPL要定义为3</span><br><span class="hljs-comment">//因为门相当于跳板，用户使用系统调用的时候，肯定要门的特权级低于用户级，只能为3    </span><br><span class="hljs-comment">// IRQ</span><br>SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],    <span class="hljs-number">0</span>, GD_KT, timer_handler, <span class="hljs-number">0</span>);<br>SETGATE(idt[IRQ_OFFSET + IRQ_KBD],      <span class="hljs-number">0</span>, GD_KT, kbd_handler,     <span class="hljs-number">0</span>);<br>SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],   <span class="hljs-number">0</span>, GD_KT, serial_handler,  <span class="hljs-number">0</span>);<br>SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS], <span class="hljs-number">0</span>, GD_KT, spurious_handler, <span class="hljs-number">0</span>);<br>SETGATE(idt[IRQ_OFFSET + IRQ_IDE],      <span class="hljs-number">0</span>, GD_KT, ide_handler,     <span class="hljs-number">0</span>);<br>SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],    <span class="hljs-number">0</span>, GD_KT, error_handler,   <span class="hljs-number">0</span>);<br><span class="hljs-comment">// Per-CPU setup </span><br>trap_init_percpu();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数加载了中断描述符表，记录了中断号对应的函数地址，并设置了系统调用和断点的中断门特权级为3，供给int指令使用。</p><blockquote><p>trapentry.s文件定义了一些所有的中断处理函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* See COPYRIGHT for copyright information. */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/mmu.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/memlayout.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/trap.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;kern/picirq.h&gt;</span></span><br><br><br>###################################################################<br><span class="hljs-meta"># exceptions/interrupts</span><br>###################################################################<br><br><span class="hljs-comment">/* TRAPHANDLER defines a globally-visible function for handling a trap.</span><br><span class="hljs-comment"> * It pushes a trap number onto the stack, then jumps to _alltraps.</span><br><span class="hljs-comment"> * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * You shouldn&#x27;t call a TRAPHANDLER function from C, but you may</span><br><span class="hljs-comment"> * need to _declare_ one in C (for instance, to get a function pointer</span><br><span class="hljs-comment"> * during IDT setup).  You can declare the function with</span><br><span class="hljs-comment"> *   void NAME();</span><br><span class="hljs-comment"> * where NAME is the argument passed to TRAPHANDLER.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER(name, num)\</span><br><span class="hljs-meta">.globl name;<span class="hljs-comment">/* define global symbol for &#x27;name&#x27; */</span>\</span><br><span class="hljs-meta">.type name, @function;<span class="hljs-comment">/* symbol type is function */</span>\</span><br><span class="hljs-meta">.align 2;<span class="hljs-comment">/* align function definition */</span>\</span><br><span class="hljs-meta">name:<span class="hljs-comment">/* function starts here */</span>\</span><br><span class="hljs-meta">pushl $(num);<span class="hljs-comment">/* 压入中断号*/</span>\</span><br><span class="hljs-meta">jmp _alltraps</span><br><br><span class="hljs-comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn&#x27;t push an error code.</span><br><span class="hljs-comment"> * It pushes a 0 in place of the error code, so the trap frame has the same</span><br><span class="hljs-comment"> * format in either case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPHANDLER_NOEC(name, num)\</span><br><span class="hljs-meta">.globl name;\</span><br><span class="hljs-meta">.type name, @function;\</span><br><span class="hljs-meta">.align 2;\</span><br><span class="hljs-meta">name:\</span><br><span class="hljs-meta">pushl $0;\</span><br><span class="hljs-meta">pushl $(num);\</span><br><span class="hljs-meta">jmp _alltraps</span><br><br>.text<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for generating entry points for the different traps.</span><br><span class="hljs-comment"> * 这里我们相当于定义了一堆异常或中断处理函数，可以根据名字来进行调用</span><br><span class="hljs-comment"> */</span><br> <br>TRAPHANDLER_NOEC(th0, <span class="hljs-number">0</span>)<br>TRAPHANDLER_NOEC(th1, <span class="hljs-number">1</span>)<br>TRAPHANDLER_NOEC(th3, <span class="hljs-number">3</span>)<br>TRAPHANDLER_NOEC(th4, <span class="hljs-number">4</span>)<br>TRAPHANDLER_NOEC(th5, <span class="hljs-number">5</span>)<br>TRAPHANDLER_NOEC(th6, <span class="hljs-number">6</span>)<br>TRAPHANDLER_NOEC(th7, <span class="hljs-number">7</span>)<br>TRAPHANDLER(th8, <span class="hljs-number">8</span>)<br>TRAPHANDLER_NOEC(th9, <span class="hljs-number">9</span>)<br>TRAPHANDLER(th10, <span class="hljs-number">10</span>)<br>TRAPHANDLER(th11, <span class="hljs-number">11</span>)<br>TRAPHANDLER(th12, <span class="hljs-number">12</span>)<br>TRAPHANDLER(th13, <span class="hljs-number">13</span>)<br>TRAPHANDLER(th14, <span class="hljs-number">14</span>)<br>TRAPHANDLER_NOEC(th16, <span class="hljs-number">16</span>)<br><span class="hljs-comment">//将系统调用的对应的程序名和中断号配置好</span><br>TRAPHANDLER_NOEC(th_syscall, T_SYSCALL)<br><br><span class="hljs-comment">//外部中断处理函数  IRQS</span><br>TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);<br>TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);<br>TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);<br>TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);<br>TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);<br>TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Lab 3: Your code here for _alltraps</span><br><span class="hljs-comment"> * 这里是上面中断处理函数调用的实际处理函数，调用的时候，都在栈中压入了参数num，也就是中断号</span><br><span class="hljs-comment"> * ds和es的压入都是根据Trapframe结构顺序压入的</span><br><span class="hljs-comment"> * pushal就是将8个通用寄存器压入到栈中</span><br><span class="hljs-comment"> */</span><br>.globl _alltraps<br>_alltraps:<br>pushl %ds;<br>pushl %es;<br>pushal;<br>movw $GD_KD, %ax;<br>movw %ax, %ds;<br>movw %ax, %es;<br>pushl %esp;       <span class="hljs-comment">//压入trap()的参数tf,%esp指向Trapframe结构的起始地址（这里是将栈中的这段连续的内存当成了Trapframe）</span><br>call trap;  <span class="hljs-comment">// 调用trap函数</span><br><br></code></pre></td></tr></table></figure><p>在中断处理函数中，我们可以看到，它首先在内核栈中压入了中断号，然后压入ds和es寄存器值，然后压入了8个基本寄存器,然后又将es和ds都设置成内核的段的值。<strong>tf_ss，tf_esp，tf_eflags，tf_cs，tf_eip，tf_err在中断发生时由处理器压入，所以现在只需要压入剩下寄存器（%ds,%es,通用寄存器）</strong>这个就是Trapframe数据结构，因为下面要调用<code>trap(struct Trapframe *tf)</code>,所以上面最后一把pushl %esp;就是压入了这个tf的指针。<strong>值得关注的时这个trap函数没有返回，那么是怎么退出中断和恢复env环境的呢？他是通过调用env_run(curenv)来实现的进程的恢复。</strong></p><blockquote><p>trap(struct Trapframe *tf)函数： 这个函数就是来处理中断事件的。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在_alltraps中我们调用了这个trap函数，处理异常或中断事件</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// The environment may have set DF and some versions</span><br><span class="hljs-comment">// of GCC rely on DF being clear</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cld&quot;</span> ::: <span class="hljs-string">&quot;cc&quot;</span>)</span>; <span class="hljs-comment">//cld指令功能: 将标志寄存器flag的方向标志位df清零</span><br><br><span class="hljs-comment">// Halt the CPU if some other CPU has called panic()</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> *panicstr;<br><span class="hljs-keyword">if</span> (panicstr)<br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;hlt&quot;</span>)</span>;<br><br><span class="hljs-comment">// Re-acqurie the big kernel lock if we were halted in</span><br><span class="hljs-comment">// sched_yield()</span><br><span class="hljs-keyword">if</span> (xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED) == CPU_HALTED)<br>lock_kernel();<br><span class="hljs-comment">// Check that interrupts are disabled.  If this assertion</span><br><span class="hljs-comment">// fails, DO NOT be tempted to fix it by inserting a &quot;cli&quot; in</span><br><span class="hljs-comment">// the interrupt path.</span><br>assert(!(read_eflags() &amp; FL_IF));<br><span class="hljs-comment">// cprintf(&quot;this trap num ========%x&quot;,tf-&gt;tf_trapno);</span><br><span class="hljs-comment">// cprintf(&quot; this tf-&gt;tf_cs = %x&quot;,tf-&gt;tf_cs);</span><br><span class="hljs-comment">// cprintf(&quot;Incoming TRAP frame at %p\n&quot;, tf);</span><br><span class="hljs-comment">//查看产生中断或异常的程序的特权级</span><br><br><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">3</span>) &#123;<br><span class="hljs-comment">// Trapped from user mode.</span><br><span class="hljs-comment">// Acquire the big kernel lock before doing any</span><br><span class="hljs-comment">// serious kernel work.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>lock_kernel();<br>assert(curenv);<br><br><span class="hljs-comment">// Garbage collect if current enviroment is a zombie</span><br><span class="hljs-keyword">if</span> (curenv-&gt;env_status == ENV_DYING) &#123;<br>env_free(curenv);<br>curenv = <span class="hljs-literal">NULL</span>;<br>sched_yield();<br>&#125;<br><br><span class="hljs-comment">// Copy trap frame (which is currently on the stack)</span><br><span class="hljs-comment">// into &#x27;curenv-&gt;env_tf&#x27;, so that running the environment</span><br><span class="hljs-comment">// will restart at the trap point.</span><br>curenv-&gt;env_tf = *tf;<span class="hljs-comment">// 这一步是将刚才压入到栈的Trapframe复制到正在运行的env上，也就是那个env的运行环境。</span><br><span class="hljs-comment">// The trapframe on the stack should be ignored from here on.</span><br>tf = &amp;curenv-&gt;env_tf;<br>&#125;<br><br><span class="hljs-comment">// Record that tf is the last real trapframe so</span><br><span class="hljs-comment">// print_trapframe can print some additional information.</span><br>last_tf = tf;<br><br><span class="hljs-comment">// Dispatch based on what type of trap occurred</span><br>trap_dispatch(tf);<br><br><span class="hljs-comment">// If we made it to this point, then no other environment was</span><br><span class="hljs-comment">// scheduled, so we should return to the current environment</span><br><span class="hljs-comment">// if doing so makes sense.</span><br><span class="hljs-comment">// 这一步很关键</span><br><span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)<br>env_run(curenv);<br><span class="hljs-keyword">else</span><br>sched_yield();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个函数，会先判断这个中断是不是来自用户态的，然后将那个进程的env中的tf赋值为刚才压入到内核栈的tf结构，这是为了后续恢复env的重要步骤</strong></p><p>然后使用dispatch（tf）函数来执行具体的动作，主要是根据tf中的中断号来进行判断。</p><blockquote><p><strong>我比较疑惑的是异常是如何进来的？或者其他的中断是怎么进来的除了断点和系统调用？</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据中断号来执行相应的中断处理程序</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">trap_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Handle processor exceptions.</span><br><span class="hljs-comment">//通过他的中断向量号，来确定中断处理函数</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><br><br><span class="hljs-comment">// Handle spurious interrupts</span><br><span class="hljs-comment">// The hardware sometimes raises these because of noise on the</span><br><span class="hljs-comment">// IRQ line or other reasons. We don&#x27;t care.</span><br><span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) &#123;<br>cprintf(<span class="hljs-string">&quot;Spurious interrupt on irq 7\n&quot;</span>);<br>print_trapframe(tf);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span><br><span class="hljs-comment">// interrupt using lapic_eoi() before calling the scheduler!</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><br><span class="hljs-comment">// Handle keyboard and serial interrupts.</span><br><span class="hljs-comment">// LAB 5: Your code here.</span><br><br><span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br><br><br><span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD) &#123;<br>                lapic_eoi();<br>    kbd_intr();<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><span class="hljs-keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL) &#123;<br>lapic_eoi();<br>    serial_intr();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">switch</span>(tf-&gt;tf_trapno)&#123;<br><span class="hljs-keyword">case</span> T_PGFLT:<br>page_fault_handler(tf);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> T_BRKPT:<br>monitor(tf);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> T_SYSCALL:<br>tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <span class="hljs-comment">//这个是系统调用号，下面的都是参数</span><br>tf-&gt;tf_regs.reg_edx,<br>tf-&gt;tf_regs.reg_ecx,<br>tf-&gt;tf_regs.reg_ebx,<br>tf-&gt;tf_regs.reg_edi,<br>tf-&gt;tf_regs.reg_esi);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:<br>lapic_eoi();  <span class="hljs-comment">//设置中断响应</span><br>sched_yield(); <span class="hljs-comment">//进程调度</span><br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// Unexpected trap: The user process or the kernel has a bug.</span><br>print_trapframe(tf);<br><span class="hljs-keyword">if</span> (tf-&gt;tf_cs == GD_KT)<br>panic(<span class="hljs-string">&quot;unhandled trap in kernel&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br>env_destroy(curenv);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>在trap（）函数最后的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)<br>env_run(curenv);<br><span class="hljs-keyword">else</span><br>sched_yield();<br></code></pre></td></tr></table></figure><p>就是用来恢复env进程的。让我们看看env_run()函数做了什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br><span class="hljs-comment">//   1. Set the current environment (if any) back to</span><br><span class="hljs-comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="hljs-comment">//      what other states it can be in),</span><br><span class="hljs-comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span><br><span class="hljs-comment">//   3. Set its status to ENV_RUNNING,</span><br><span class="hljs-comment">//   4. Update its &#x27;env_runs&#x27; counter,</span><br><span class="hljs-comment">//   5. Use lcr3() to switch to its address space.</span><br><span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">//   registers and drop into user mode in the</span><br><span class="hljs-comment">//   environment.</span><br><br><span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br><span class="hljs-comment">//e-&gt;env_tf.  Go back through the code you wrote above</span><br><span class="hljs-comment">//and make sure you have set the relevant parts of</span><br><span class="hljs-comment">//e-&gt;env_tf to sensible values.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span>(curenv !=<span class="hljs-literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<br>curenv-&gt;env_status = ENV_RUNNABLE;<br>&#125;<br>curenv = e;<br>curenv-&gt;env_status = ENV_RUNNING;<br>curenv-&gt;env_runs++;<br><span class="hljs-comment">//将这进程的页目录表加载到cr3寄存器中</span><br>lcr3(PADDR(curenv-&gt;env_pgdir));<br><span class="hljs-comment">//进入用户环境后，将内核锁释放掉</span><br>unlock_kernel();<br><span class="hljs-comment">//进入用户环境</span><br><span class="hljs-comment">//这个函数将之前设置的e-&gt;env_tf-&gt;tf_eip弹出到eip寄存器中，这样就完成了程序的转换了。</span><br>env_pop_tf(&amp;(e-&gt;env_tf));<br><span class="hljs-comment">// panic(&quot;env_run not yet implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>最后的env_pop_tf(&amp;(e-&gt;env_tf));十分的关键，这个就是实现从中断中返回，然后恢复用户态环境。</strong></p><p><strong>将存储在内核栈的tf结构依次的pop出来，其中iret指令就是中断返回，他就是int指令的逆过程，都是由cpu来完成。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个是退出内核状态，恢复在Trapframe中存储的值到各个寄存器中</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_pop_tf</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Record the CPU we are running on for user-space debugging</span><br>curenv-&gt;env_cpunum = cpunum();<br><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params"> <span class="hljs-string">&quot;\t movl %0, %%esp\n&quot;</span>       <span class="hljs-comment">/* %0对应后面的tf，这里是将tf这个地址值赋给%esp */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t popal\n&quot;</span>                <span class="hljs-comment">/* 按*/</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t popl %%es\n&quot;</span>            <span class="hljs-comment">/* 弹出值到%es */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t popl %%ds\n&quot;</span>            <span class="hljs-comment">/* 弹出值到%ds */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t addl $0x8, %%esp\n&quot;</span>     <span class="hljs-comment">/* 跳过tf_trapno 和 tf_errcode */</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;\t iret\n&quot;</span>                 <span class="hljs-comment">/* 从中断返回，将栈中存储数据弹出到eip, cs, eflags寄存器中 */</span></span><br><span class="hljs-params">        : : <span class="hljs-string">&quot;g&quot;</span>(tf) : <span class="hljs-string">&quot;memory&quot;</span>)</span>;    <span class="hljs-comment">/* “g”表示将输入变量tf放入eax，ebx，ecx，edx之一,或作为内存变量 */</span><br>                                    <span class="hljs-comment">/* 告诉编译器在执行期间会发生内存变动，以防止错误的代码优化 */</span><br>panic(<span class="hljs-string">&quot;iret failed&quot;</span>);  <span class="hljs-comment">/* mostly to placate the compiler */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="系统调用system-call"><a href="#系统调用system-call" class="headerlink" title="系统调用system call"></a>系统调用system call</h3><p><strong>这是trapdispatch函数中的关于系统调用的入口</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_SYSCALL:<br>tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, <span class="hljs-comment">//这个是系统调用号，下面的都是参数</span><br>tf-&gt;tf_regs.reg_edx,<br>tf-&gt;tf_regs.reg_ecx,<br>tf-&gt;tf_regs.reg_ebx,<br>tf-&gt;tf_regs.reg_edi,<br>tf-&gt;tf_regs.reg_esi);<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><strong>这几个寄存器存储的是系统调用号和系统调用的参数。</strong></p><blockquote><p>如何实现系统调用</p></blockquote><p>JOS使用int指令实现系统调用，使用0x30作为中断号。应用使用寄存器传递系统调用号和参数。系统调用号保存在%eax，五个参数依次保存在%edx, %ecx, %ebx, %edi, %esi中。返回值保存在%eax中。</p><p>我们前面都设置完成了IDT表，并且在trapdispatch()函数中也设置了。最后跳转到这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个syscall是内核的方法</span><br><span class="hljs-type">int32_t</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> syscallno, <span class="hljs-type">uint32_t</span> a1, <span class="hljs-type">uint32_t</span> a2, <span class="hljs-type">uint32_t</span> a3, <span class="hljs-type">uint32_t</span> a4, <span class="hljs-type">uint32_t</span> a5)</span><br>&#123;<br><span class="hljs-comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span><br><span class="hljs-comment">// Return any appropriate return value.</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-type">int32_t</span> ret;<br><span class="hljs-comment">// panic(&quot;syscall not implemented&quot;);</span><br><br><span class="hljs-keyword">switch</span> (syscallno) &#123;<br><span class="hljs-keyword">case</span> SYS_cputs:<br>sys_cputs((<span class="hljs-type">char</span> *)a1,(<span class="hljs-type">size_t</span>)a2);<br>ret =<span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_cgetc:<br>ret = sys_cgetc();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_env_destroy:<br>ret = sys_env_destroy((<span class="hljs-type">envid_t</span>)a1);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_getenvid:<br>ret = sys_getenvid();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_yield:  <span class="hljs-comment">//进程唤醒</span><br>ret =<span class="hljs-number">0</span>;<br>sys_yield();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_exofork:  <span class="hljs-comment">//创建进程</span><br>ret = sys_exofork();<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_env_set_status:<br>ret = sys_env_set_status((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">int</span>)a2);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_page_alloc:<br>ret = sys_page_alloc((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">void</span> *)a2, (<span class="hljs-type">int</span>)a3);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_page_map:<br>ret = sys_page_map((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">void</span> *)a2,<br>     (<span class="hljs-type">envid_t</span>)a3, (<span class="hljs-type">void</span> *)a4, (<span class="hljs-type">int</span>)a5);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SYS_page_unmap:<br>ret = sys_page_unmap((<span class="hljs-type">envid_t</span>)a1, (<span class="hljs-type">void</span> *)a2);<br><span class="hljs-keyword">break</span>; <br><span class="hljs-keyword">case</span> SYS_env_set_pgfault_upcall:<br><span class="hljs-keyword">return</span> sys_env_set_pgfault_upcall((<span class="hljs-type">envid_t</span>) a1, (<span class="hljs-type">void</span> *) a2);<br><span class="hljs-keyword">case</span> SYS_ipc_recv:<br><span class="hljs-keyword">return</span> sys_ipc_recv((<span class="hljs-type">void</span> *)a1);<br><span class="hljs-keyword">case</span> SYS_ipc_try_send:<br><span class="hljs-keyword">return</span> sys_ipc_try_send((<span class="hljs-type">envid_t</span>)a1,(<span class="hljs-type">uint32_t</span>)a2,(<span class="hljs-type">void</span> *)a3,(<span class="hljs-type">int</span>)a4);<br><span class="hljs-keyword">case</span> SYS_env_set_trapframe:<br><span class="hljs-keyword">return</span> sys_env_set_trapframe((<span class="hljs-type">envid_t</span>)a1,(<span class="hljs-keyword">struct</span> Trapframe *)a2);<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>现在回顾一下系统调用的完成流程：以user/hello.c为例，其中调用了cprintf()，注意这是lib/print.c中的cprintf，该cprintf()最终会调用lib/syscall.c中的sys_cputs()，sys_cputs()又会调用lib/syscall.c中的syscall()，该函数将系统调用号放入%eax寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令int 0x30，发生中断后，去IDT中查找中断处理函数，最终会走到kern/trap.c的trap_dispatch()中，我们根据中断号0x30，又会调用kern/syscall.c中的syscall()函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用kern/print.c中的cprintf()函数，该函数最终调用kern/console.c中的cputchar()将字符串打印到控制台。当trap_dispatch()返回后，trap()会调用<code>env_run(curenv);</code>，该函数前面讲过，会将curenv-&gt;env_tf结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。</p><h3 id="如何开启用户进程的？"><a href="#如何开启用户进程的？" class="headerlink" title="如何开启用户进程的？"></a>如何开启用户进程的？</h3><p>用户程序真正开始运行的地方是在lib/entry.S文件中。该文件中，首先会进行一些设置，然后就会调用lib/libmain.c 文件中的 libmain() 函数。你首先要修改一下 libmain() 函数，使它能够初始化全局指针 thisenv ，让它指向当前用户环境的 Env 结构体。</p><p>　　　　然后 libmain() 函数就会调用 umain，这个 umain 程序恰好是 user/hello.c 中被调用的函数。在之前的实验中我们发现，hello.c程序只会打印 “hello, world” 这句话，然后就会报出 page fault 异常，原因就是 thisenv-&gt;env_id 这条语句。现在你已经正确初始化了这个 thisenv的值，再次运行就应该不会报错了。</p><blockquote><p><strong>我们要清楚的一点是这个libmain函数是操作系统提供的库函数，应该是直接给用户进程使用的，也就是这个libmain.c函数以及entry.s文件的代码最终在用户的elf文件中体现的，我们只需要设置tf中的cs和eip就行（这个对应的就是==_start==）</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">libmain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-comment">// set thisenv to point at our Env structure in envs[].</span><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-type">envid_t</span> envid = sys_getenvid();<br>thisenv = envs + ENVX(envid);      <span class="hljs-comment">//获取Env结构指针</span><br><br><span class="hljs-comment">// save the name of the program so that panic() can use it</span><br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">0</span>)<br>binaryname = argv[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// call user main routine</span><br>umain(argc, argv);<br><br><span class="hljs-comment">// exit gracefully</span><br><span class="hljs-built_in">exit</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>user/hello.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">umain</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>cprintf(<span class="hljs-string">&quot;hello, world\n&quot;</span>);<br>cprintf(<span class="hljs-string">&quot;i am environment %08x\n&quot;</span>, thisenv-&gt;env_id);  <span class="hljs-comment">//现在我们已经初始化了thisenv变量了，所以可以打印处来了O(∩_∩)O</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>我们看一下这个hello.asm文件,截取了一部分</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs asm">obj/user/hello.debug：     文件格式 elf32-i386<br><br><br>Disassembly of section .text:<br><br>00800020 &lt;_start&gt;:<br>// starts us running when we are initially loaded into a new environment.<br>.text<br>.globl _start<br>_start:<br>// See if we were started with arguments on the stack<br>cmpl $USTACKTOP, %esp<br>  800020:81 fc 00 e0 bf ee    cmp    $0xeebfe000,%esp<br>jne args_exist<br>  800026:75 04                jne    80002c &lt;args_exist&gt;<br><br>// If not, push dummy argc/argv arguments.<br>// This happens when we are loaded by the kernel,<br>// because the kernel does not know about passing arguments.<br>pushl $0<br>  800028:6a 00                push   $0x0<br>pushl $0<br>  80002a:6a 00                push   $0x0<br><br>0080002c &lt;args_exist&gt;:<br><br>args_exist:<br>call libmain<br>  80002c:e8 2d 00 00 00       call   80005e &lt;libmain&gt;<br>1:jmp 1b<br>  800031:eb fe                jmp    800031 &lt;args_exist+0x5&gt;<br><br>00800033 &lt;umain&gt;:<br>// hello, world<br>#include &lt;inc/lib.h&gt;<br><br>void<br>umain(int argc, char **argv)<br>&#123;<br>  800033:55                   push   %ebp<br>  800034:89 e5                mov    %esp,%ebp<br>  800036:83 ec 14             sub    $0x14,%esp<br>cprintf(&quot;hello, world\n&quot;);<br>  800039:68 80 1d 80 00       push   $0x801d80<br>  80003e:e8 10 01 00 00       call   800153 &lt;cprintf&gt;<br>cprintf(&quot;i am environment %08x\n&quot;, thisenv-&gt;env_id);<br>  800043:a1 00 40 80 00       mov    0x804000,%eax<br>  800048:8b 40 48             mov    0x48(%eax),%eax<br>  80004b:83 c4 08             add    $0x8,%esp<br>  80004e:50                   push   %eax<br>  80004f:68 8e 1d 80 00       push   $0x801d8e<br>  800054:e8 fa 00 00 00       call   800153 &lt;cprintf&gt;<br>&#125;<br>  800059:83 c4 10             add    $0x10,%esp<br>  80005c:c9                   leave  <br>  80005d:c3                   ret    <br><br>0080005e &lt;libmain&gt;:<br>const volatile struct Env *thisenv;<br>const char *binaryname = &quot;&lt;unknown&gt;&quot;;<br><br>void<br>libmain(int argc, char **argv)<br>&#123;<br>  80005e:55                   push   %ebp<br>  80005f:89 e5                mov    %esp,%ebp<br>  800061:56                   push   %esi<br>  800062:53                   push   %ebx<br>  800063:8b 5d 08             mov    0x8(%ebp),%ebx<br>  800066:8b 75 0c             mov    0xc(%ebp),%esi<br>// set thisenv to point at our Env structure in envs[].<br>// LAB 3: Your code here.<br>thisenv = &amp;envs[ENVX(sys_getenvid())]; //获取这个Env的结构指针<br>  800069:e8 7d 0a 00 00       call<br></code></pre></td></tr></table></figure><p>*<strong>我们可以看到就是先进入<code>_start</code>处（对应的就是elf中的入口地址也就是tf中设置的eip值，在创建进程的时候，会将tf的eip属性给设置为elf的入口地址，也就是 <code>_start</code>）</strong></p><blockquote><p>如何进入进程的？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><span class="hljs-comment">// Step 1: If this is a context switch (a new environment is running):</span><br><span class="hljs-comment">//   1. Set the current environment (if any) back to</span><br><span class="hljs-comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span><br><span class="hljs-comment">//      what other states it can be in),</span><br><span class="hljs-comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span><br><span class="hljs-comment">//   3. Set its status to ENV_RUNNING,</span><br><span class="hljs-comment">//   4. Update its &#x27;env_runs&#x27; counter,</span><br><span class="hljs-comment">//   5. Use lcr3() to switch to its address space.</span><br><span class="hljs-comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span><br><span class="hljs-comment">//   registers and drop into user mode in the</span><br><span class="hljs-comment">//   environment.</span><br><br><span class="hljs-comment">// Hint: This function loads the new environment&#x27;s state from</span><br><span class="hljs-comment">//e-&gt;env_tf.  Go back through the code you wrote above</span><br><span class="hljs-comment">//and make sure you have set the relevant parts of</span><br><span class="hljs-comment">//e-&gt;env_tf to sensible values.</span><br><br><span class="hljs-comment">// LAB 3: Your code here.</span><br><span class="hljs-keyword">if</span>(curenv !=<span class="hljs-literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;<br>curenv-&gt;env_status = ENV_RUNNABLE;<br>&#125;<br>curenv = e;<br>curenv-&gt;env_status = ENV_RUNNING;<br>curenv-&gt;env_runs++;<br><span class="hljs-comment">//将这进程的页目录表加载到cr3寄存器中</span><br>lcr3(PADDR(curenv-&gt;env_pgdir));<br><span class="hljs-comment">//进入用户环境后，将内核锁释放掉</span><br>unlock_kernel();<br><span class="hljs-comment">//进入用户环境</span><br><span class="hljs-comment">//这个函数将之前设置的e-&gt;env_tf-&gt;tf_eip弹出到eip寄存器中，这样就完成了程序的转换了。</span><br><span class="hljs-comment">//这个也是开始运行这个env的入口</span><br>env_pop_tf(&amp;(e-&gt;env_tf)); <span class="hljs-comment">//这个是env中的tf地址，不是内核栈的那个tf，这个很重要</span><br><span class="hljs-comment">// panic(&quot;env_run not yet implemented&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p><strong>先页表转换，将eip地址设置为之前设置的tf中的eip，也就是程序入口地址（_start处）。</strong></p></blockquote><h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><blockquote><p><strong>在页表的每一个项的低12位为标志位，这个就是标志着对应内存的一些权限</strong></p></blockquote><p>![image-20230307133719177](mit 6.828.assets/image-20230307133719177.png)</p><p>内存保护是操作系统的非常重要的一项功能，它可以防止由于用户程序崩溃对操作系统带来的破坏与影响。</p><p>操作系统依赖处理器的来实现内存保护。当程序试图访问无效地址或没有访问权限时，处理器在当前指令停住，引发中断进入内核。如果内核能够修复，则在刚才的指令处继续执行，否则程序将无法接着运行。系统调用也为内存保护带来了问题。大部分系统调用接口让用户程序传递一个指针参数给内核。这些指针指向的是用户缓冲区。通过这种方式，系统调用在执行时就可以解引用这些指针。但是这里有两个问题：</p><ol><li>在内核中的page fault要比在用户程序中的page fault更严重。如果内核在操作自己的数据结构时出现 page faults，这是一个内核的bug，而且异常处理程序会中断整个内核。但是当内核在解引用由用户程序传递来的指针时，它需要一种方法去记录此时出现的任何page faults都是由用户程序带来的。</li><li>内核通常比用户程序有着更高的内存访问权限。用户程序很有可能要传递一个指针给系统调用，这个指针指向的内存区域是内核可以进行读写的，但是用户程序不能。此时内核必须小心的去解析这个指针，否则的话内核的重要信息很有可能被泄露。</li></ol><blockquote><p>所以对于pageFault，我们主要分两种情况</p><ul><li><p>在内核模式发生的pagefault，直接panic</p></li><li><p>在用户模式下的pagefault，我们看看这个用户模式是否有权限访问这个这个虚拟地址空间</p><ul><li><strong>如果没有权限，那么直接给这个env给终止了。使用user_mem_check()函数来判断</strong></li><li><strong>如果有权限，那么我们接下来处理这个异常：这个在lab3中没有实现</strong></li></ul></li></ul></blockquote><p>首先是判断是内核情况下的pagefault</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((tf-&gt;tf_cs &amp; <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>) <span class="hljs-comment">//内核态发生缺页中断直接panic</span><br>panic(<span class="hljs-string">&quot;page_fault_handler():page fault in kernel mode!\n&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>再判断用户是不是有访问权限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">user_mem_check</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// LAB 3: Your code here.</span><br>cprintf(<span class="hljs-string">&quot;user_mem_check va: %x, len: %x\n&quot;</span>, va, len);<br><span class="hljs-type">uint32_t</span> begin = (<span class="hljs-type">uint32_t</span>) ROUNDDOWN(va, PGSIZE); <br><span class="hljs-type">uint32_t</span> end = (<span class="hljs-type">uint32_t</span>) ROUNDUP(va+len, PGSIZE);<br><span class="hljs-type">uint32_t</span> i;<br><span class="hljs-keyword">for</span> (i = (<span class="hljs-type">uint32_t</span>)begin; i &lt; end; i += PGSIZE) &#123;<br><span class="hljs-type">pte_t</span> *pte = pgdir_walk(env-&gt;env_pgdir, (<span class="hljs-type">void</span>*)i, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> ((i &gt;= ULIM) || !pte || !(*pte &amp; PTE_P) || ((*pte &amp; perm) != perm)) &#123;        <span class="hljs-comment">//具体检测规则</span><br>user_mem_check_addr = (i &lt; (<span class="hljs-type">uint32_t</span>)va ? (<span class="hljs-type">uint32_t</span>)va : i);                <span class="hljs-comment">//记录无效的那个线性地址</span><br><span class="hljs-keyword">return</span> -E_FAULT;<br>&#125;<br>&#125;<br>cprintf(<span class="hljs-string">&quot;user_mem_check success va: %x, len: %x\n&quot;</span>, va, len);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Checks that environment &#x27;env&#x27; is allowed to access the range</span><br><span class="hljs-comment">// of memory [va, va+len) with permissions &#x27;perm | PTE_U | PTE_P&#x27;.</span><br><span class="hljs-comment">// If it can, then the function simply returns.</span><br><span class="hljs-comment">// If it cannot, &#x27;env&#x27; is destroyed and, if env is the current</span><br><span class="hljs-comment">// environment, this function will not return.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">user_mem_assert</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *env, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-keyword">if</span> (user_mem_check(env, va, len, perm | PTE_U) &lt; <span class="hljs-number">0</span>) &#123;<br>cprintf(<span class="hljs-string">&quot;[%08x] user_mem_check assertion failure for &quot;</span><br><span class="hljs-string">&quot;va %08x\n&quot;</span>, env-&gt;env_id, user_mem_check_addr);<br>env_destroy(env);<span class="hljs-comment">// may not return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>![image-20230307151155518](mit 6.828.assets/image-20230307151155518.png)</p><p>![image-20230307151246298](mit 6.828.assets/image-20230307151246298.png)</p><p>![image-20230307151307331](mit 6.828.assets/image-20230307151307331.png)</p><h2 id="lab4"><a href="#lab4" class="headerlink" title="lab4"></a>lab4</h2><p>这个实验内容比较多，但是也是围绕进程来说的，主要有以下内容：</p><ol><li>采取多处理器模式，因为现在处理器一般都是多核的，这样每个cpu能够同时运行不同的进程，提升系统的并发性。但是采取多个cpu，就会导致可能会出现多个cpu使用内核程序的可能，所以为了解决这个cpu同时访问内核程序，这里也介绍了锁机制，本实验实现的是spinlock。</li><li>实现了进程调度算法</li><li>实现了写时拷贝fork（进程的创建）</li><li>实现了进程间的通信（IPC）</li></ol><h3 id="实现多处理器和协同式多任务"><a href="#实现多处理器和协同式多任务" class="headerlink" title="实现多处理器和协同式多任务"></a>实现多处理器和协同式多任务</h3><p>主要是实现jos支持多个cpu，以及实现系统调用允许普通的进程创建新的进程，实现协作式进程调度</p><h4 id="支持多处理器"><a href="#支持多处理器" class="headerlink" title="支持多处理器"></a>支持多处理器</h4><p>jos将支持”symmetric multiprocessing” (SMP)，这是一种所有CPU共享系统资源的多处理器模式。在启动阶段这些cpu将会被分为两类：</p><ol><li>BSP（bootstrap processor）:这个cpu服务初始化系统和启动操作系统</li><li>AP（application processor）： 操作系统启动后将由BSP来引导激活。</li></ol><p>在SMP模式中，每个cpu都有一个对应的local APIC单元，用来传递中断信号等，LAPIC是在CPU中的，但是LAPIC的寄存器被硬链接到内存空间的物理地址0xFE000000上，也就是通过操作这个物理地址就相当于操作了LAPIC寄存器了。cpu访问都是通过虚拟地址的，所以我们将这个物理地址映射到MMIOBASE虚拟地址处，编码时操作这个虚拟地址就相当于操作0xFE000000物理地址，就相当于操作LAPIC单元了。</p><p>因此下面我们首先将mmiobase映射到物理地址FE000000处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br><span class="hljs-title function_">mmio_map_region</span><span class="hljs-params">(<span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">size_t</span> size)</span><br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">uintptr_t</span> base = MMIOBASE;<br><br>size = ROUNDUP(pa+size, PGSIZE);<br>pa = ROUNDDOWN(pa, PGSIZE);<br>size -= pa;<br><span class="hljs-keyword">if</span> (base+size &gt;= MMIOLIM) panic(<span class="hljs-string">&quot;not enough memory&quot;</span>);<br>boot_map_region(kern_pgdir, base, size, pa, PTE_PCD|PTE_PWT|PTE_W);<br>base += size;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*) (base - size);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="每个cpu包含哪些东西"><a href="#每个cpu包含哪些东西" class="headerlink" title="每个cpu包含哪些东西"></a>每个cpu包含哪些东西</h4><p>![image-20230307213810307](mit 6.828.assets/image-20230307213810307.png)</p><ol><li>各种寄存器，cs，esp，eip，gdtr，idtr，cr3（内核页目录表）等等</li><li>TSS选择器寄存器，在jos中每个cpu还有一个TSS，用来存储对应的内核栈空间地址。</li><li>每个cpu都有自己独立的内核栈空间，jos分配了<code>percpu_kstacks[NCPU][KSTKSIZE]</code>一个数组8*32768大小的空间作为内核栈（<strong>这个地方应该是在内核的.data中或者.bss中，不再是之前的那个单个cpu的内核栈了，所以我们需要在内核的页表中重新映射这块申请的物理空间和虚拟地址KSTACKTOP以下的PTSIZE大小</strong>）。对应的虚拟地址是KSTCKTOP下的空间，CPU 1的内核栈将从CPU 0栈后面KSTKGAP字节处开始，以此类推。</li><li>进程结构指针：每个CPU都会独立运行一个进程的代码，所以需要Env指针。</li></ol><h4 id="启动其他的cpu（AP）"><a href="#启动其他的cpu（AP）" class="headerlink" title="启动其他的cpu（AP）"></a>启动其他的cpu（AP）</h4><h5 id="先收集AP信息"><a href="#先收集AP信息" class="headerlink" title="先收集AP信息"></a>先收集AP信息</h5><p>在启动其他的AP之前，BSP需要收集多处理器的信息，比如有多少个cpu，每个cpu对应的LAPIC的物理地址和LAPIC ID。我们可以在inti.c文件中的i386_init()中的mp_init()函数，这个函数就是用来收集所有的ap信息。这些信息都是保存在BIOS中的mp configuration table中，读取每个cpu的信息，然后初始化cpu[]数组，ncpu个数，bootcpu（指向BSP对应的cpuinfo结构）</p><blockquote><p>cpuinfo结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-CPU state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> &#123;</span><br><span class="hljs-type">uint8_t</span> cpu_id;                 <span class="hljs-comment">// Local APIC ID; index into cpus[] below</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">unsigned</span> cpu_status;   <span class="hljs-comment">// The status of the CPU</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">cpu_env</span>;</span>            <span class="hljs-comment">// The currently-running environment.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Taskstate</span> <span class="hljs-title">cpu_ts</span>;</span>        <span class="hljs-comment">// Used by x86 to find stack for interrupt</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>以及其他的信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialized in mpconfig.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> <span class="hljs-title">cpus</span>[<span class="hljs-title">NCPU</span>];</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> ncpu;                    <span class="hljs-comment">// Total number of CPUs in the system</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> *<span class="hljs-title">bootcpu</span>;</span>     <span class="hljs-comment">// The boot-strap processor (BSP)</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">physaddr_t</span> lapicaddr;        <span class="hljs-comment">// Physical MMIO address of the local APIC </span><br><br><span class="hljs-comment">// Per-CPU kernel stacks</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> percpu_kstacks[NCPU][KSTKSIZE];<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*这个函数就是用来获取处理器信息的，有多少个cpu，每个cpu对应的LAPIC ID 和每个cpu对应的LAPIC的MMIO地址</span><br><span class="hljs-comment">* 这些信息从bios中的mp configuration table 中读取的，</span><br><span class="hljs-comment">* 然后将信息存在cpus数组中，每一个元素类型就是CpuInfo类型的结构</span><br><span class="hljs-comment">* bootcpu 就是指向的保存BSP处理器信息的CpuInfo结构</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">* 所以这个函数就是读取bios中的处理器信息，并初始化cpus信息。后面BSP根据这个cpus数组挨个启动每个APs(在boot_abs()函数启动)</span><br><span class="hljs-comment">* </span><br><span class="hljs-comment">* 每个AP启动完成之后，就会执行kern/mpentry.S中的代码，然后再跳转到mp_main()函数，为当前处理器AP设置GDT,TSS等</span><br><span class="hljs-comment">* 最后将cpus[]数组中对应CpuInfo结构类型元素的cpu_status属性设置为CPU_STARTED(代表已经启动了)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mp</span> *<span class="hljs-title">mp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mpconf</span> *<span class="hljs-title">conf</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mpproc</span> *<span class="hljs-title">proc</span>;</span><br><span class="hljs-type">uint8_t</span> *p;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br><br>bootcpu = &amp;cpus[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> ((conf = mpconfig(&amp;mp)) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span>;<br>ismp = <span class="hljs-number">1</span>;<br>lapicaddr = conf-&gt;lapicaddr;<br><br><span class="hljs-keyword">for</span> (p = conf-&gt;entries, i = <span class="hljs-number">0</span>; i &lt; conf-&gt;entry; i++) &#123;<br><span class="hljs-keyword">switch</span> (*p) &#123;<br><span class="hljs-keyword">case</span> MPPROC:<br>proc = (<span class="hljs-keyword">struct</span> mpproc *)p;<br><span class="hljs-keyword">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)<br>bootcpu = &amp;cpus[ncpu];<br><span class="hljs-keyword">if</span> (ncpu &lt; NCPU) &#123;<br>cpus[ncpu].cpu_id = ncpu;<br>ncpu++;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cprintf(<span class="hljs-string">&quot;SMP: too many CPUs, CPU %d disabled\n&quot;</span>,<br>proc-&gt;apicid);<br>&#125;<br>p += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mpproc);<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">case</span> MPBUS:<br><span class="hljs-keyword">case</span> MPIOAPIC:<br><span class="hljs-keyword">case</span> MPIOINTR:<br><span class="hljs-keyword">case</span> MPLINTR:<br>p += <span class="hljs-number">8</span>;<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">default</span>:<br>cprintf(<span class="hljs-string">&quot;mpinit: unknown config type %x\n&quot;</span>, *p);<br>ismp = <span class="hljs-number">0</span>;<br>i = conf-&gt;entry;<br>&#125;<br>&#125;<br><br>bootcpu-&gt;cpu_status = CPU_STARTED;<br><span class="hljs-keyword">if</span> (!ismp) &#123;<br><span class="hljs-comment">// Didn&#x27;t like what we found; fall back to no MP.</span><br>ncpu = <span class="hljs-number">1</span>;<br>lapicaddr = <span class="hljs-number">0</span>;<br>cprintf(<span class="hljs-string">&quot;SMP: configuration not found, SMP disabled\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cprintf(<span class="hljs-string">&quot;SMP: CPU %d found %d CPU(s)\n&quot;</span>, bootcpu-&gt;cpu_id,  ncpu);<br><br><span class="hljs-keyword">if</span> (mp-&gt;imcrp) &#123;<br><span class="hljs-comment">// [MP 3.2.6.1] If the hardware implements PIC mode,</span><br><span class="hljs-comment">// switch to getting interrupts from the LAPIC.</span><br>cprintf(<span class="hljs-string">&quot;SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n&quot;</span>);<br>outb(<span class="hljs-number">0x22</span>, <span class="hljs-number">0x70</span>);   <span class="hljs-comment">// Select IMCR</span><br>outb(<span class="hljs-number">0x23</span>, inb(<span class="hljs-number">0x23</span>) | <span class="hljs-number">1</span>);  <span class="hljs-comment">// Mask external interrupts.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="启动各个AP"><a href="#启动各个AP" class="headerlink" title="启动各个AP"></a>启动各个AP</h5><blockquote><p>每个cpu都有自己独立的内核栈空间，jos分配了<code>percpu_kstacks[NCPU][KSTKSIZE]</code>一个数组8*32768大小的空间作为内核栈（<strong>这个地方应该是在内核的.data中或者.bss中，不再是之前的那个单个cpu的内核栈了，所以我们需要在内核的页表中重新映射这块申请的物理空间和虚拟地址KSTACKTOP以下的PTSIZE大小</strong>）。对应的虚拟地址是KSTCKTOP下的空间，CPU 1的内核栈将从CPU 0栈后面KSTKGAP字节处开始，以此类推。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">mem_init_mp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span><br><span class="hljs-comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span><br><span class="hljs-comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span><br><span class="hljs-comment">// divided into two pieces, just like the single stack you set up in</span><br><span class="hljs-comment">// mem_init:</span><br><span class="hljs-comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span><br><span class="hljs-comment">//          -- backed by physical memory</span><br><span class="hljs-comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span><br><span class="hljs-comment">//          -- not backed; so if the kernel overflows its stack,</span><br><span class="hljs-comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span><br><span class="hljs-comment">//             Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// LAB 4: Your code here:</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NCPU; i++) &#123;<br>boot_map_region(kern_pgdir, <br>KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP), <br>KSTKSIZE, <br>PADDR(percpu_kstacks[i]), <br>PTE_W);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>处理器启动：</p><p>调用的是boot_aps();我们可以看到，在这段程序中，我们会将位于mpentry.s文件程序地址给复制到0x7000处，然后再设置cpu的cs和ip的地址为0x7000处（被启动的cpu此时处于实模式）然后cpu就开始从0x7000处执行程序了，这个程序包括mpentry.s以及位于init.c文件中的mp_main()函数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Start the non-boot (AP) processors.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_aps</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mpentry_start[], mpentry_end[];<br><span class="hljs-type">void</span> *code;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CpuInfo</span> *<span class="hljs-title">c</span>;</span><br><br><span class="hljs-comment">// Write entry code to unused memory at MPENTRY_PADDR</span><br>code = KADDR(MPENTRY_PADDR);<br><span class="hljs-comment">//mpentry_start和mpentry_end是编译器导出符号，代表这段代码在内存（虚拟地址）中的起止位置</span><br><span class="hljs-comment">//接着把代码复制到MPENTRY_PADDR处,这个代码就是mpentry.S文件</span><br>memmove(code, mpentry_start, mpentry_end - mpentry_start);<br><br><span class="hljs-comment">// Boot each AP one at a time</span><br><span class="hljs-keyword">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;<br><span class="hljs-keyword">if</span> (c == cpus + cpunum())  <span class="hljs-comment">// We&#x27;ve started already.</span><br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// Tell mpentry.S what stack to use </span><br>mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;<br><span class="hljs-comment">// Start the CPU at mpentry_start</span><br>lapic_startap(c-&gt;cpu_id, PADDR(code));<br><span class="hljs-comment">// Wait for the CPU to finish some basic setup in mp_main()</span><br><span class="hljs-keyword">while</span>(c-&gt;cpu_status != CPU_STARTED)<br>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>mpentry.s文件：这个文件的动作，</p><ul><li>我们可以看到它开启了分页模式，将kern_pgdir设置到cr3中，进入保护模式了，因此后面也是采用页表进行地址装换。</li><li>设置了这个cpu的内核栈esp</li><li>跳转到mp_main()函数</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* See COPYRIGHT for copyright information. */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/mmu.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/memlayout.h&gt;</span></span><br>###################################################################<br><span class="hljs-meta"># entry point for APs</span><br>###################################################################<br># Each non-boot <span class="hljs-title function_">CPU</span> <span class="hljs-params">(<span class="hljs-string">&quot;AP&quot;</span>)</span> is started up in response to a STARTUP<br># IPI from the boot CPU.  Section B.4.2 of the Multi-Processor<br># Specification says that the AP will start in real mode with CS:IP<br><span class="hljs-meta"># set to XY00:0000, where XY is an 8-bit value sent with the</span><br># STARTUP. Thus this code must start at a 4096-byte boundary.<br>#<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RELOC(x) ((x) - KERNBASE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)</span><br><br>.<span class="hljs-built_in">set</span> PROT_MODE_CSEG, 0x8<span class="hljs-meta"># kernel code segment selector</span><br>.<span class="hljs-built_in">set</span> PROT_MODE_DSEG, 0x10<span class="hljs-meta"># kernel data segment selector</span><br><br># 这里我们就是启动每一个cpu时候对cpu的初始化动作，设置cpu的一些寄存器，比如<span class="hljs-title function_">cr3</span><span class="hljs-params">(kern_pgdir)</span>/<span class="hljs-title function_">gdtr</span><span class="hljs-params">(GDT)</span>/<span class="hljs-title function_">tr</span><span class="hljs-params">(TSS)</span>/等，以及开启分页模式等等<br>.code16           <br>.globl mpentry_start     <br>mpentry_start:<br>cli            <br>xorw    %ax, %ax<br>movw    %ax, %ds<br>movw    %ax, %es<br>movw    %ax, %ss<br><br>lgdt    <span class="hljs-title function_">MPBOOTPHYS</span><span class="hljs-params">(gdtdesc)</span><br>movl    %cr0, %eax<br>orl     $CR0_PE, %eax<br>movl    %eax, %cr0<br><br>ljmpl   $<span class="hljs-params">(PROT_MODE_CSEG)</span>, $<span class="hljs-params">(MPBOOTPHYS(start32))</span><br><br>.code32<br>start32:<br>movw    $<span class="hljs-params">(PROT_MODE_DSEG)</span>, %ax<br>movw    %ax, %ds<br>movw    %ax, %es<br>movw    %ax, %ss<br>movw    $0, %ax<br>movw    %ax, %fs<br>movw    %ax, %gs<br><br># Set up initial page table. We cannot use kern_pgdir yet because<br><span class="hljs-meta"># we are still running at a low EIP.</span><br>movl    $<span class="hljs-params">(RELOC(entry_pgdir))</span>, %eax<br>movl    %eax, %cr3<br># Turn on paging.<br>movl    %cr0, %eax<br>orl     $<span class="hljs-params">(CR0_PE|CR0_PG|CR0_WP)</span>, %eax<br>movl    %eax, %cr0<br><br># Switch to the per-cpu <span class="hljs-built_in">stack</span> allocated in <span class="hljs-title function_">boot_aps</span><span class="hljs-params">()</span><br># 设置每个cpu的栈空间，位于KSTACKTOP下面，每个cpu的栈空间中间隔着一定的空间作为栈保护空间，因此我们还需要在页表中完成这个映射关系<br>movl    mpentry_kstack, %esp  <br>movl    $0x0, %ebp       <span class="hljs-meta"># nuke frame pointer</span><br><br># Call <span class="hljs-title function_">mp_main</span><span class="hljs-params">()</span>.  <span class="hljs-params">(Exercise <span class="hljs-keyword">for</span> the reader: why the indirect call?)</span><br>movl    $mp_main, %eax<br>call    *%eax<br><br># If mp_main <span class="hljs-title function_">returns</span> <span class="hljs-params">(it shouldn<span class="hljs-string">&#x27;t), loop.</span></span><br><span class="hljs-string"><span class="hljs-params">spin:</span></span><br><span class="hljs-string"><span class="hljs-params">jmp     spin</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params"># Bootstrap GDT</span></span><br><span class="hljs-string"><span class="hljs-params">.p2align 2# force 4 byte alignment</span></span><br><span class="hljs-string"><span class="hljs-params">gdt:</span></span><br><span class="hljs-string"><span class="hljs-params">SEG_NULL# null seg</span></span><br><span class="hljs-string"><span class="hljs-params">SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span></span><br><span class="hljs-string"><span class="hljs-params">SEG(STA_W, 0x0, 0xffffffff)# data seg</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params">gdtdesc:</span></span><br><span class="hljs-string"><span class="hljs-params">.word   0x17# sizeof(gdt) - 1</span></span><br><span class="hljs-string"><span class="hljs-params">.long   MPBOOTPHYS(gdt)# address gdt</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br><span class="hljs-string"><span class="hljs-params">.globl mpentry_end</span></span><br><span class="hljs-string"><span class="hljs-params">mpentry_end:</span></span><br><span class="hljs-string"><span class="hljs-params">nop</span></span><br><span class="hljs-string"><span class="hljs-params"></span></span><br></code></pre></td></tr></table></figure><blockquote><p>mp_main():这个函数的动作</p><ul><li>加载cr3寄存器值为kern_pgdir</li><li>初始化LAPIC</li><li>加载GDTR寄存器</li><li>每个cpu都有自己的TSS描述符和对应的TSS结构，然后将栈存入到TSS的ss0和esp0中</li><li>然后执行一个env</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Setup code for APs  //这个函数调用在mpentry.S中，会初始化每个cpu的寄存器，页目录表地址，gdtr寄存器，idtr，tr等</span><br><span class="hljs-comment">// 我们需要注意的是，在进入mpentry.s后，就相当于多个cpu开始执行内核代码了，这就会导致资源竞争的问题，比如空间竞争等。</span><br><span class="hljs-comment">// 所以我们需要使用锁来将多个cpu进行同步</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">mp_main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// We are in high EIP now, safe to switch to kern_pgdir </span><br>lcr3(PADDR(kern_pgdir));<br>cprintf(<span class="hljs-string">&quot;SMP: CPU %d starting\n&quot;</span>, cpunum());<br><br>lapic_init();<br>env_init_percpu();<br>trap_init_percpu();<br>xchg(&amp;thiscpu-&gt;cpu_status, CPU_STARTED); <span class="hljs-comment">// tell boot_aps() we&#x27;re up</span><br><br><span class="hljs-comment">// Now that we have finished some basic setup, call sched_yield()</span><br><span class="hljs-comment">// to start running processes on this CPU.  But make sure that</span><br><span class="hljs-comment">// only one CPU can enter the scheduler at a time!</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Your code here:</span><br>lock_kernel();<br><br><span class="hljs-comment">//这里每个cpu最开始的时候会运行这个函数，以获取一个env进行运行，所以必须要获取锁，envs属于各个cpu的公共资源，所以需要加锁</span><br><span class="hljs-comment">//并不是所有cpu陷入内核都需要锁？因为每个cpu都有自己的栈空间，所以不是可以同时两个cpu陷入内核态</span><br>sched_yield();<br><span class="hljs-comment">// // Remove this after you finish Exercise 6</span><br><span class="hljs-comment">// for (;;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>现在我们知道了会有多个cpu会去访问内核代码，从而导致分配内存空间等等操作，这样就会出现竞争资源的现象，还会出现资源错乱的现象，因此我们需要将各个cpu访问内核代码时同步，也就是上锁。</p><p>这里是采用了一个全局的大锁，当进程从用户态进入内核态的时候就必须先获取这个锁，退出内核的时候释放锁。这样才会保证只有一个cpu访问内核代码，从而实现一个cpu来操作共享资源。这样就会出先当一个cpu指向内核代码的时候，另个cpu想要执行内核代码必须等待。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>jos采用的是自旋锁，什么是自旋锁呢？就是去请求锁的时候，如果请求不到，会一直尝试请求，直到获取到锁，这个会导致cpu一直处于工作状态，锁的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br><span class="hljs-type">unsigned</span> locked;       <span class="hljs-comment">// Is the lock held?</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来看看实现自旋锁的原理，根据我们上面对自旋锁的描述，就是不断的循环去请求：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-type">void</span><br><span class="hljs-number">2</span> acquire(<span class="hljs-keyword">struct</span> spinlock *lk)<br><span class="hljs-number">3</span> &#123;<br><span class="hljs-number">4</span>    <span class="hljs-keyword">for</span>(;;) &#123;<br><span class="hljs-number">5</span>      <span class="hljs-keyword">if</span>(!lk-&gt;locked) &#123;<br><span class="hljs-number">6</span>          lk-&gt;locked = <span class="hljs-number">1</span>;<br><span class="hljs-number">7</span>          <span class="hljs-keyword">break</span>;<br><span class="hljs-number">8</span>      &#125;<br><span class="hljs-number">9</span>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是这个代码还是会出现问题的，假如执行到第5行时进入了if语句，但是还没有将locked改为1，另一个cpu也检测到了locked为0，也进入到了if语句，这样就导致了两个cpu同时获取到了锁，那和没加锁有什么区别。所以上述的代码不行，我们需要接触硬件的特点来进行加锁和解锁。</p><p>在kern/spinlock.c文件中，提供了上锁和解锁的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br><span class="hljs-comment">// The xchg is atomic.</span><br><span class="hljs-comment">// It also serializes, so that reads after acquire are not</span><br><span class="hljs-comment">// reordered before it. </span><br><span class="hljs-keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>)<span class="hljs-comment">//原理见：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf  chapter 4</span><br><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;pause&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">spin_unlock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> spinlock *lk)</span><br>&#123;<br><span class="hljs-comment">// The xchg instruction is atomic (i.e. uses the &quot;lock&quot; prefix) with</span><br><span class="hljs-comment">// respect to any other instruction which references the same memory.</span><br><span class="hljs-comment">// x86 CPUs will not reorder loads/stores across locked instructions</span><br><span class="hljs-comment">// (vol 3, 8.2.2). Because xchg() is implemented using asm volatile,</span><br><span class="hljs-comment">// gcc will not reorder C statements across the xchg.</span><br>xchg(&amp;lk-&gt;locked, <span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">uint32_t</span><br><span class="hljs-title function_">xchg</span><span class="hljs-params">(<span class="hljs-keyword">volatile</span> <span class="hljs-type">uint32_t</span> *addr, <span class="hljs-type">uint32_t</span> newval)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> result;<br>    <span class="hljs-comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;lock; xchgl %0, %1&quot;</span></span><br><span class="hljs-params">         : <span class="hljs-string">&quot;+m&quot;</span> (*addr), <span class="hljs-string">&quot;=a&quot;</span> (result)</span><br><span class="hljs-params">         : <span class="hljs-string">&quot;1&quot;</span> (newval)</span><br><span class="hljs-params">         : <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>这里使用了xchgl指令，它可以一步完成两个地址内容之间的交换</strong></p><p><code>while (xchg(&amp;lk-&gt;locked, 1) != 0)</code>这个会将全局变量lk-&gt;locked和1交换，如果交互回来的值为0，说明上锁成功，如果交换回来的值为1，说明已经被别的cpu给上锁。这个指令相当于前面第5步和第6步的结合了，这里只需要一步，所以不会出现共同拥有锁的现象了。解锁操作很简单就是<code>xchg(&amp;lk-&gt;locked, 0);</code>和0交换就行了。</p><p>在上面我们看到在获取锁失败后，会使用pause指令，这个指令相当于一个延迟的noop空指令一样，主要是为了减少cpu的消耗。</p><h5 id="在哪里上锁"><a href="#在哪里上锁" class="headerlink" title="在哪里上锁"></a>在哪里上锁</h5><p>有了获取锁和释放锁的函数，我们看下哪些地方需要加锁，和释放锁：</p><ol><li>i386_init()中，BSP唤醒其它AP前需要获取内核锁。</li><li>mp_main()中，AP需要在执行sched_yield()前获取内核锁。</li><li>trap()中，需要获取内核锁，因为这是用户态进入内核的唯一入口。</li><li>env_run()中，需要释放内核锁，因为该函数使用iret指令，从内核返回用户态。</li></ol><p><strong>对于3和4是因为只能有一个cpu可以进入内核态，对于1和2来说，因为每个cpu都可以调度env，但是一个env只能运行在一个cpu上，因此在调度的时候，我们要加锁，保证只有一个cpu在调度env，防止一个env被多个cpu同时选择。</strong></p><h3 id="进程调度–-轮询调度算法"><a href="#进程调度–-轮询调度算法" class="headerlink" title="进程调度– 轮询调度算法"></a>进程调度– 轮询调度算法</h3><p>这个是实现将cpu调度和运行用户进程，一个进程同时只能在一个cpu上运行。目前采用的是抢占式的轮询调度算法，让进程主动的让出cpu给下一个进程使用。通过sched_yield()函数，当前cpu会在envs数组中选择一个离自己索引后面最近的RUNNABLE一个env去运行，全局变量curenv可以获取这个cpu正在运行的env。</p><ul><li><strong>非抢占式调度算法</strong>挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情。</li><li><strong>抢占式调度算法</strong>挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。这种抢占式调度处理，需要在时间间隔的末端发生<strong>时钟中断</strong>，以便把 CPU 控制返回给调度程序进行调度，也就是常说的<strong>时间片机制</strong>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">idle</span>;</span><br><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><br><span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> next;<br><span class="hljs-keyword">if</span> (curenv) &#123;<br>start = ENVX(curenv-&gt;env_id) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; NENV; i++) &#123;<br>next = (start + i) % NENV;<br><span class="hljs-comment">//遍历所有的env数组，选择一个RUNNABLE的去运行</span><br><span class="hljs-keyword">if</span> (envs[next].env_status == ENV_RUNNABLE) &#123;<br>env_run(&amp;envs[next]); <span class="hljs-comment">// 运行这个进程，具体做法就是恢复这个进程的tf，并加载这个进程的页表</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// //这里保证的是如果上面没有找到可执行的env，那就继续执行自己，</span><br><span class="hljs-comment">// 但是这个时候要看一下这个env运行的cpu是不是就是此cpu，不能一个env运行在不同的cpu上</span><br><span class="hljs-keyword">if</span> (curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING) &#123;<br>env_run(curenv);<br>&#125;<br><br><span class="hljs-comment">// sched_halt never returns</span><br>sched_halt();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建进程的系统调用fork"><a href="#创建进程的系统调用fork" class="headerlink" title="创建进程的系统调用fork"></a>创建进程的系统调用fork</h3><p>现在jos可以同时运行多个进程了，且处理器之间可以在多个进程之间切换。不过现在运行的进程都是由内核创建的，用户进程自己无法创建额外的进程。也就是说，我们马上就要实现fork这个系统调用了，这个fork是用来干嘛的？</p><blockquote><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。</p><p><strong>上面的话通俗理解就是:</strong> fork是复制进程的函数，程序一开始就会产生一个进程，当这个进程(代码)执行到fork()时，fork就会复制一份原来的进程即就是创建一个新进程,我们称子进程，而原来的进程我们称为父进程，此时父子进程是共存的，他们一起向下执行代码。</p></blockquote><p>jos将fork函数作为一个用户函数来实现，而非系统调用。只不过fork里面还是会调用系统调用，只不过这样做，我们就可以实现不同形式的fork函数了。</p><blockquote><p>我们需要实现以下的系统调用：</p></blockquote><ul><li><p>sys_exofork()</p><p>这个系统调用是用来创建一个新的进程，申请一个env和页目录表，并把这个进程设置为不可运行状态，tf结构和父进程一致，在父进程的sys_exofork()函数中返回1，而在子进程中返回0（这个非常关键）</p></li><li><p>sys_env_set_status:</p><p>给一个进程设置成ENV_RUNNABLE 或者ENV_NOT_RUNNABLE</p></li><li><p>sys_page_alloc：为特定进程分配一个物理页，然后映射指定的虚拟地址到该物理页，比如映射异常栈空间</p></li><li><p>sys_page_map:</p><p>这个相当于拷贝页表，使得两个进程（父子）有相同的页表结构。</p></li><li><p>sys_page_unmap:</p><p>解除页映射关系。本质上就是修改进程的页目录表和页表</p></li></ul><blockquote><p>接下来我们就先实现这些系统调用：</p></blockquote><h4 id="sys-exofork-void"><a href="#sys-exofork-void" class="headerlink" title="sys_exofork(void)"></a>sys_exofork(void)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建一个新的env，并返回子进程的id</span><br><span class="hljs-type">static</span> <span class="hljs-type">envid_t</span><br><span class="hljs-title function_">sys_exofork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// Create the new environment with env_alloc(), from kern/env.c.</span><br><span class="hljs-comment">// It should be left as env_alloc created it, except that</span><br><span class="hljs-comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span><br><span class="hljs-comment">// from the current environment -- but tweaked so sys_exofork</span><br><span class="hljs-comment">// will appear to return 0.</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-type">int</span> ret;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br><span class="hljs-comment">//在envs中获取一个env，并申请一个页表给新的env，初始化这个env的页表地址等</span><br>ret = env_alloc(&amp;env,sys_getenvid());<br><span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-comment">//设置这个env的状态 为不可运行</span><br>env-&gt;env_status = ENV_NOT_RUNNABLE;<br><span class="hljs-comment">//设置父进程的Trapflame为子进程的tf，比如eip，esp等子进程的tf中的eip指向父进程调用int时的下一个指令，就是return ret</span><br>env-&gt;env_tf = curenv-&gt;env_tf;<br>env-&gt;env_tf.tf_regs.reg_eax =<span class="hljs-number">0</span>;<span class="hljs-comment">//新的进程从sys_exofork()的返回值应该为0</span><br><span class="hljs-comment">//创建完成返回子进程的id</span><br><span class="hljs-keyword">return</span> env-&gt;env_id;<br><span class="hljs-comment">// panic(&quot;sys_exofork not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数实现了申请一个新的env结构，并将他的tf设置成父进程的tf，并这个env申请一个页目录表，这里面有一个很重要<code>env-&gt;env_tf.tf_regs.reg_eax =0</code>这个是将子进程的tf中的eax寄存器设置为0，这个也是后面保证在子进程执行完sys_exofork()函数后获得为0，用来区分子进程和父进程，因为父进程会返回子进程id.</p><p>我们来解释一下子进程返回0，父进程返回子进程id：</p><p>在父进程中，我们使用fork函数，来创建一个子进程，这个时候会触发中断，然后进入这个sys_exofork中，然后创建了子进程，这个时候并没有立刻运行子进程，而是设置为不可运行，然后就返回了，返回的为子进程id，<strong>然后继续执行接下来父进程fork函数里的程序</strong>。子进程后面会被cpu调度执行，因为fork函数是创建的子进程启动后执行的第一条语句就是当时父进程进入中断的后的一条语句，也就是将eax寄存器中的值放到ret中，然后返回到fork函数，<strong>子进程是不需要继续执行fork函数剩下的部分的</strong>，所以就判断是不是0，然后直接退出这个fork函数，继续执行接下来的父进程的程序。如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">envid_t</span> envid = sys_exofork(); <span class="hljs-comment">//系统调用，只是简单创建一个Env结构，并返回子进程id复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立</span><br><span class="hljs-keyword">if</span>(envid ==<span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">//子进程走这里</span><br><span class="hljs-comment">// 子进程是怎么启动的？就是被正常调度起来的，然后调度到它之后，执行env_run，然后通过tf恢复eip，esp，等等寄存器，直接开始执行sys_exofork（这个是lib里面的）里面的int后面那条语句</span><br><span class="hljs-comment">// 然后进入这里了。</span><br>thisenv = &amp;envs[ENVX(sys_getenvid())]; <span class="hljs-comment">//获取这个env结构</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个才能实现真正的fork函数。</p><h4 id="sys-env-set-status"><a href="#sys-env-set-status" class="headerlink" title="sys_env_set_status"></a>sys_env_set_status</h4><p>这个函数是给某个env的状态设置为对应的status</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//将envid对应的进程状态设置成status  ENV_NOT_RUNNABLE或者ENV_RUNNABLE</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_env_set_status</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">int</span> status)</span><br>&#123;<br><span class="hljs-comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span><br><span class="hljs-comment">// envid to a struct Env.</span><br><span class="hljs-comment">// You should set envid2env&#x27;s third argument to 1, which will</span><br><span class="hljs-comment">// check whether the current environment has permission to set</span><br><span class="hljs-comment">// envid&#x27;s status.</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-keyword">if</span>(status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_RUNNABLE)<br><span class="hljs-keyword">return</span> -E_INVAL;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br><span class="hljs-type">int</span> ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span> )&#123;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>env-&gt;env_status = status;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// panic(&quot;sys_env_set_status not implemented&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="sys-page-alloc"><a href="#sys-page-alloc" class="headerlink" title="sys_page_alloc"></a>sys_page_alloc</h4><p>这个函数是给某个进程申请一个页，并在页表中完成映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//给某个进程申请一个页，并在页表中建立完成页表映射，这个虚拟地址va从哪里来的？</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_page_alloc</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Hint: This function is a wrapper around page_alloc() and</span><br><span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><br><span class="hljs-comment">//   Most of the new code you write should be to check the</span><br><span class="hljs-comment">//   parameters for correctness.</span><br><span class="hljs-comment">//   If page_insert() fails, remember to free the page you</span><br><span class="hljs-comment">//   allocated!</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br><span class="hljs-type">int</span> ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> -E_BAD_ENV;<br>&#125;<br><span class="hljs-comment">//判断虚拟地址是否超过UTOP，判断地址是否是页对齐的</span><br><span class="hljs-keyword">if</span>((va &gt;= (<span class="hljs-type">void</span> *)UTOP) ||(ROUNDDOWN(va, PGSIZE) != va))<br><span class="hljs-keyword">return</span> -E_INVAL;<br><span class="hljs-type">int</span> flag = PTE_U | PTE_P;<br><span class="hljs-comment">//判断权限是否正常</span><br><span class="hljs-keyword">if</span>((perm &amp; flag) != flag) <span class="hljs-keyword">return</span> E_INVAL;<br><span class="hljs-comment">//申请一页内存</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> =</span> page_alloc(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//判断页面是否申请成功</span><br><span class="hljs-keyword">if</span>(!pg) <span class="hljs-keyword">return</span> -E_NO_MEM;<br><span class="hljs-comment">//插入到自己的页表中,也就是做好虚拟地址和物理地址的映射</span><br>ret = page_insert(env-&gt;env_pgdir,pg,va,perm);<br><span class="hljs-keyword">if</span>(ret)&#123;<br><span class="hljs-comment">//进入这里表示建立映射失败，需要将刚才申请的页给释放掉</span><br>page_free(pg);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// panic(&quot;sys_page_alloc not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys-page-map"><a href="#sys-page-map" class="headerlink" title="sys_page_map"></a>sys_page_map</h4><p>这个函数是将源srcenv的虚拟地址srcva对应的物理页 给映射到目的dstenv的虚拟地址dstva上去。</p><p>也就是这两个进程的srcva和dstva都在各自的进程中映射到了相同的物理页上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_page_map</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> srcenvid, <span class="hljs-type">void</span> *srcva,</span><br><span class="hljs-params">     <span class="hljs-type">envid_t</span> dstenvid, <span class="hljs-type">void</span> *dstva, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Hint: This function is a wrapper around page_lookup() and</span><br><span class="hljs-comment">//   page_insert() from kern/pmap.c.</span><br><span class="hljs-comment">//   Again, most of the new code you write should be to check the</span><br><span class="hljs-comment">//   parameters for correctness.</span><br><span class="hljs-comment">//   Use the third argument to page_lookup() to</span><br><span class="hljs-comment">//   check the current permissions on the page.</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">se</span>, *<span class="hljs-title">de</span>;</span><br><span class="hljs-type">int</span> ret = envid2env(srcenvid,&amp;se,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(ret) <span class="hljs-keyword">return</span> ret;<br>ret = envid2env(dstenvid,&amp;de,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(ret) <span class="hljs-keyword">return</span> ret;<br><span class="hljs-comment">//判断虚拟地址是否超过了UTOP，判断srcva和dstva是否是页对其的</span><br><span class="hljs-keyword">if</span>(srcva &gt;=(<span class="hljs-type">void</span> *)UTOP || dstva &gt;= (<span class="hljs-type">void</span> *)UTOP ||<br>ROUNDDOWN(srcva,PGSIZE) != srcva|| ROUNDDOWN(dstva,PGSIZE) !=dstva)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-comment">//这个函数是返回虚拟地址srcva对应的实际物理页，保存在pte指向的地址中</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pg</span> =</span> page_lookup(se-&gt;env_pgdir,srcva,&amp;pte);<br><span class="hljs-comment">//这个是判断src进程对应的虚拟地址是否有物理页存在（是否完成映射，因为后面要将dst的虚拟地址映射到这个物理地址）</span><br><span class="hljs-keyword">if</span>(!pg)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-type">int</span> flag = PTE_U|PTE_P;<br><span class="hljs-comment">//判断权限是否正确</span><br><span class="hljs-keyword">if</span>((perm &amp; flag) !=flag) <span class="hljs-keyword">return</span> -E_INVAL;<br><span class="hljs-comment">//判断这个页面是否可写，srcva对应的页面一般read_only</span><br><span class="hljs-comment">//将子进程的页表中的对应的父进程的页的权限都改成只读的（权限设置在页表项的低12位）----这个很重要，因为这样在子进程想要修改父进程的页的时候，就会触发pagefault</span><br><span class="hljs-keyword">if</span>((*pte &amp; PTE_W) == <span class="hljs-number">0</span> &amp;&amp; (perm &amp; PTE_W)) <span class="hljs-keyword">return</span> -E_INVAL;<br><br><span class="hljs-comment">//经过上面的一些列判断后，我们将de进程的虚拟地址dstva映射到srcva对应的物理地址去</span><br>ret = page_insert(de-&gt;env_pgdir,pg,dstva,perm);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// panic(&quot;sys_page_map not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sys-page-unmap"><a href="#sys-page-unmap" class="headerlink" title="sys_page_unmap"></a>sys_page_unmap</h4><p>这个函数用来将一个进程的va对应的物理页关系给删除掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_page_unmap</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">void</span> *va)</span><br>&#123;<br><span class="hljs-comment">// Hint: This function is a wrapper around page_remove().</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br><span class="hljs-type">int</span> ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(ret)&#123;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-keyword">if</span>(va &gt;= (<span class="hljs-type">void</span> *)UTOP || ROUNDDOWN(va,PGSIZE) != va)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>page_remove(env-&gt;env_pgdir,va);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// panic(&quot;sys_page_unmap not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Copy-On-Write-写时拷贝"><a href="#Copy-On-Write-写时拷贝" class="headerlink" title="Copy On Write 写时拷贝"></a>Copy On Write 写时拷贝</h4><p>实现fork的方式有很多种，一种是将父进程的内容全部都copy一遍，这样的话子进程和父进程就能够做到进程隔离，但是这个十分的浪费时间和空间。</p><p>另一个方式就是写时拷贝的技术，这个方式就是父进程在创建子进程的时候，只会讲自己的页目录和页表复制给子进程，这样父进程和子进程既可以访问相同的内容。只有当一方指向写操作时，才会复制这一目录页。这样既能够做到地址空间的隔离，又能省区大量的拷贝</p><h5 id="用户级别页异常"><a href="#用户级别页异常" class="headerlink" title="用户级别页异常"></a>用户级别页异常</h5><p>这里实现了，我们可以在用户级别来处理由用户进程产生的page_fault，那我们需要注册页错误处理函数，需要实现一个sys_env_set_pgfault_upcall()系统调用提供支持。这个系统调用是在内核态操作某个env结构，然后将这个env结构中的页错误处理函数指针指向我们提供的统一页错误处理函数入口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个函数是设置用户自己的pagefault处理函数，这个func就是_pgfault_upcall，就是缺页中断的总入口，位于pfentry.S文件中</span><br><span class="hljs-comment">//也就是这个函数设置进程缺页异常的入口</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_env_set_pgfault_upcall</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">void</span> *func)</span><br>&#123;<br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br><span class="hljs-type">int</span> ret;<br>ret = envid2env(envid,&amp;env,<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(ret &lt;<span class="hljs-number">0</span> )&#123;<br><span class="hljs-keyword">return</span> -E_BAD_ENV;<br>&#125;<br><span class="hljs-comment">//这个是执行用户进程自己的处理函数,所以设置成用户提供的函数func</span><br><span class="hljs-comment">//最后就是在这里设置了用户缺页入口程序</span><br>env-&gt;env_pgfault_upcall = func;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="page-fault-handler"><a href="#page-fault-handler" class="headerlink" title="page_fault_handler"></a>page_fault_handler</h5><p>这个函数就是在cpu发生页错误的时候，就会触发中断，从而进入trap（），然后调用这个page_fault_handler函数，处理页错误。我们上面说了我们会把页错误处理交给用户操作，那么如何实现的呢？</p><p>首先我们先介绍以下异常栈：就是用户进程执行异常函数的时候所使用的栈，这个栈的虚拟地址为UXSTACKTOP，<strong>也就是当正在处于用户态的程序发生页错误，会进入内核态，然后在内核中设置env的一些esp和eip之后重启这个进程，让他运行页错误处理程序，使用的栈是异常栈。</strong></p><p><strong>那么如何从异常栈继续恢复到原来的栈，我们这里维护了一个UTrapframe结构，它就是用来保存发生页错误时的esp和eip等寄存器的值。然后在用户页错误处理完成之后，恢复错误之前的esp和eip值。这个不需要再进入到内核态。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UTrapframe</span> &#123;</span><br><span class="hljs-comment">/* information about the fault */</span><br><span class="hljs-type">uint32_t</span> utf_fault_va;<span class="hljs-comment">/* va for T_PGFLT, 0 otherwise */</span><br><span class="hljs-type">uint32_t</span> utf_err;<br><span class="hljs-comment">/* trap-time return state */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PushRegs</span> <span class="hljs-title">utf_regs</span>;</span><br><span class="hljs-type">uintptr_t</span> utf_eip;<br><span class="hljs-type">uint32_t</span> utf_eflags;<br><span class="hljs-comment">/* the trap-time stack to return to */</span><br><span class="hljs-type">uintptr_t</span> utf_esp;<br>&#125; __attribute__((packed));<br></code></pre></td></tr></table></figure><blockquote><p>page_fault_handler()</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//这个tf是在内核栈中的，保存了一些进程进入中断时的一些信息</span><br><span class="hljs-comment">//这个函数时页面异常处理程序，好像是通过UTrapframe进行直接中断返回，而不是从Tramframe回去的（这一点需要关注）</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> fault_va;<br><br><span class="hljs-comment">// Read processor&#x27;s CR2 register to find the faulting address</span><br><span class="hljs-comment">//cr2寄存器是用来存储发生page fault 时的线性地址</span><br>fault_va = rcr2();<br><span class="hljs-comment">// panic(&quot;page_fault in kernel mode, fault address %d\n&quot;, fault_va);</span><br><span class="hljs-comment">// Handle kernel-mode page faults.</span><br><br><span class="hljs-comment">// LAB 3: Your code here. //这个是判断是不是内核程序发生的页错误</span><br><span class="hljs-keyword">if</span>((tf-&gt;tf_cs &amp; <span class="hljs-number">0x3</span>) == <span class="hljs-number">0</span>) &#123;<br>        panic(<span class="hljs-string">&quot;page_fault in kernel mode, fault address %d\n&quot;</span>, fault_va);<br>    &#125;<br><span class="hljs-comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span><br><span class="hljs-comment">// the page fault happened in user mode.</span><br><br><br><span class="hljs-comment">// Hints:</span><br><span class="hljs-comment">//   user_mem_assert() and env_run() are useful here.</span><br><span class="hljs-comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span><br><span class="hljs-comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UTrapframe</span> *<span class="hljs-title">utf</span>;</span><br><span class="hljs-keyword">if</span>(curenv-&gt;env_pgfault_upcall)&#123;<br><span class="hljs-comment">//这一步是判断是不是之前已经在异常栈中了，（也就是上面说的递归陷入了）</span><br><span class="hljs-comment">//如果之前没有在异常栈中，那么UTrapframe结构从UXSTACKTOP这里开始</span><br><span class="hljs-comment">//如果之前在异常栈中，那么就紧接着一个UTrapframe 再加一字节空位 开始</span><br><span class="hljs-comment">//也就是这里的stacktop位置</span><br><span class="hljs-keyword">if</span> (UXSTACKTOP - PGSIZE &lt;= tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt;= UXSTACKTOP - <span class="hljs-number">1</span>)<br>            utf = (<span class="hljs-keyword">struct</span> UTrapframe *)(tf-&gt;tf_esp - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UTrapframe) - <span class="hljs-number">4</span>);<br>        <span class="hljs-keyword">else</span><br>            utf = (<span class="hljs-keyword">struct</span> UTrapframe *)(UXSTACKTOP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UTrapframe));<br>user_mem_assert(curenv, (<span class="hljs-type">void</span> *)utf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> UTrapframe), PTE_U | PTE_W);<br><br><span class="hljs-comment">//初始化这个异常栈，直接从这里回去了用户模式(虽然是内核态，但是这个页表依然是env的页表，因为只有在env进程切换的时候才会更新cr3,每个env页表都复制了内核的页表)，这个utf就是为了恢复回到发生异常时候的环境，</span><br>                 <span class="hljs-comment">// 所以要用tf中的值来初始化utf</span><br>utf-&gt;utf_fault_va = fault_va;<br>utf-&gt;utf_err = tf-&gt;tf_err;<br>utf-&gt;utf_regs = tf-&gt;tf_regs;<br>utf-&gt;utf_eflags = tf-&gt;tf_eflags;<br>utf-&gt;utf_eip = tf-&gt;tf_eip;   <span class="hljs-comment">//这个tf_eip应该是用户程序发生中断时的eip</span><br>utf-&gt;utf_esp = tf-&gt;tf_esp;   <span class="hljs-comment">//这个tf_esp应该是用户的用户栈esp          ////UXSTACKTOP栈上需要保存发生缺页异常时的%esp和%eip</span><br><br><span class="hljs-comment">//设置进程eip指向页异常用户处理程序，当从内核态返回到用户态的时候，直接执行异常处理程序，使用的栈是异常栈，不过这个映射都是在env的页表中</span><br>tf-&gt;tf_eip = (<span class="hljs-type">uint32_t</span>)curenv-&gt;env_pgfault_upcall;  <span class="hljs-comment">//这个会在执行env_pop_tf这个函数的时候，开开始执行这个函数，在pfentry.S文件</span><br><span class="hljs-comment">//使用的栈就是UXSTACKTOP，从utf下面开始，</span><br>tf-&gt;tf_esp = (<span class="hljs-type">uint32_t</span>)utf;<br><span class="hljs-comment">//回到用户模式，经过一系列的pop，记忆最后的iret命令，到了env_pgfault_upcall这里，并且此时栈变成了异常栈utf（并不是用户栈，所以这里完成了从内核栈-&gt;异常栈的转换）</span><br>env_run(curenv); <span class="hljs-comment">//此时的栈还是内核栈，后面env_pop_tf的pop都是pop的Trapframe结构，然后完成内核栈-&gt;异常栈，并执行pgfault_upcall函数(在用户模式下执行异常处理程序，使用的栈是异常栈)</span><br>&#125;<br><span class="hljs-comment">// Destroy the environment that caused the fault.</span><br>cprintf(<span class="hljs-string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,<br>curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);<br>print_trapframe(tf);<br>env_destroy(curenv);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当发生页错误的时候，进入到内核态进入这个函数，这个函数将utf压入到异常栈的地方UXSTACKTOP处，然后设置tf的esp为异常栈处之下的一个UTrapframe处，然后将tf-&gt;eip设置为env_pgfault_upcall这个地址处的函数，也就是pfentry.S文件中的那个函数，之前都设置好了，然后env_run(curenv);这个时候就会回到用户态然后开始指向页错误处理函数，并使用异常栈。</strong></p><p>现在我们就将目光转到<code>pfentry.S</code>文件，这个是内核提供的库函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 现在都是在用户态下运行程序</span><br>.text<br>.globl _pgfault_upcall  <span class="hljs-comment">//这个函数是从异常栈转换为用户栈，执行env_run()函数的时候，有一个env_pop_tf()函数将eip设置成这个函数入口，栈变成异常栈</span><br>_pgfault_upcall:        <span class="hljs-comment">//1. 现在我们是在异常栈下，并且是用户态</span><br><span class="hljs-comment">// Call the C page fault handler.</span><br>pushl %esp<span class="hljs-comment">// function argument: pointer to UTF</span><br>movl _pgfault_handler, %eax   <span class="hljs-comment">//这个_pgfault_handler函数就是用户自定义的函数，也是实际的缺页异常处理函数</span><br>call *%eax           <span class="hljs-comment">//调用页处理函数</span><br>addl $<span class="hljs-number">4</span>, %esp<span class="hljs-comment">// pop function argument</span><br><br>        <br><span class="hljs-comment">//下面就是从异常栈切换到用户栈</span><br><br><span class="hljs-comment">//参考这个https://blog.csdn.net/wysiwygo/article/details/104459969</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>movl <span class="hljs-number">48</span>(%esp), %ebp<br>    subl $<span class="hljs-number">4</span>, %ebp<br>    movl %ebp, <span class="hljs-number">48</span>(%esp) <span class="hljs-comment">// 前面三步就是完成旧的esp-4，为了放旧的eip</span><br>    movl <span class="hljs-number">40</span>(%esp), %eax <span class="hljs-comment">// 将旧的eip放到旧的esp-4处，为了后面使用ret指令</span><br>    movl %eax, (%ebp)<br><br><br><span class="hljs-comment">// Restore the trap-time registers.  After you do this, you</span><br><span class="hljs-comment">// can no longer modify any general-purpose registers.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>addl $<span class="hljs-number">8</span>,%esp<br>popal<br><span class="hljs-comment">// Restore eflags from the stack.  After you do this, you can</span><br><span class="hljs-comment">// no longer use arithmetic operations or anything else that</span><br><span class="hljs-comment">// modifies eflags.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>addl $<span class="hljs-number">4</span>,%esp<br>popfl<br><span class="hljs-comment">// Switch back to the adjusted trap-time stack.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>popl %esp <span class="hljs-comment">//现在这个esp中指向的就是旧的esp-4的位置，这里存放的是旧的eip</span><br><span class="hljs-comment">// Return to re-execute the instruction that faulted.</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br>ret  <span class="hljs-comment">//这里十分巧妙， ret会读取esp指向的第一个内容， 也就是我们前面写入的旧的eip（也就是异常发生的位置），（ret相当于pop %eip，会自动将esp+0x4）</span><br><br></code></pre></td></tr></table></figure><p>可以看到会调用_pgfault_handler函数，这个函数就是真正的页错误处理函数，它是一个全局变量，前面在</p><p><code>sys_env_set_pgfault_upcall(envid_t envid, void *func)</code>这个函数中进行设置的。然后处理完页错误之后，接下来就是恢复进程继续执行之前发生页错误地方的程序，并将esp指向原来的栈。怎么恢复呢？</p><p>我们都知道在异常栈我们压入了一个UTrapframe结构，保存了之前的esp和eip，现在esp指向异常栈，我们可以先将utf中的esp（旧esp）减4，用来存储旧的eip，然后将旧的eip存在旧栈中，然后让esp指向旧esp-4</p><p>的地方，然后执行ret指令，就会跳转到eip处指令，并恢复esp。</p><blockquote><p>那个函数完成的异常处理函数注册的？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//参数是一个函数指针，这个函数的参数是个UTrapframe  这个传入的参数就是在pfentry.S中的_pgfault_handler()函数</span><br><span class="hljs-comment">//这个函数在用户程序中调用</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">set_pgfault_handler</span><span class="hljs-params">(<span class="hljs-type">void</span> (*handler)(<span class="hljs-keyword">struct</span> UTrapframe *utf))</span><br>&#123;<br><span class="hljs-type">int</span> r;<br><br><span class="hljs-keyword">if</span> (_pgfault_handler == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// First time through!</span><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-comment">//分配一个异常栈</span><br><span class="hljs-comment">// First time through!</span><br><span class="hljs-comment">//如果是第一次进入这个函数，那么我们先申请一个异常页作为我们的异常栈</span><br><span class="hljs-keyword">if</span> ((r = sys_page_alloc(thisenv-&gt;env_id, (<span class="hljs-type">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="hljs-number">0</span>)<br>panic(<span class="hljs-string">&quot;set_pgfault_handler: %e&quot;</span>, r);<br><span class="hljs-comment">//申请完成异常页之后，我们设置这个env的缺页异常处理函数入口，也就是pfentry.S中的那个函数（他会去调用真正的缺页处理函数--也就是上面那个参数handler）</span><br>sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall);<br><span class="hljs-comment">// if(r&lt;0)&#123;</span><br><span class="hljs-comment">// panic(&quot;set_pgfault_handler: sys_env_set_pgfault_upcall() failed&quot;);</span><br><span class="hljs-comment">// &#125;</span><br>&#125;<br><span class="hljs-comment">// Save handler pointer for assembly to call.</span><br><span class="hljs-comment">//真正处理缺页异常的函数</span><br>_pgfault_handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>整理以下这个页错误处理过程</strong></p></blockquote><ol><li><p>发生异常前，用户已经向内核注册自定义的页面处理程序，并为自己的异常栈分配一页物理页面</p></li><li><p>用户态发生页面错误，走正常的中断处理程序，陷入内核态切换到内核栈、进入<code>trap()</code></p></li><li><p>根据中断号发现是页面错误，调用<code>page_fault_handler()</code>进行处理</p></li><li><p>检测trap frame的<code>tf_cs</code>发现是用户态发生的错误</p></li><li><p>判断是否有用户自定义页面异常处理程序：如果没有，销毁环境</p></li><li><p>如果有，准备转向用户态处理异常：</p><ul><li><p>检查tf_esp，若在[UXSTACKTOP-PGSIZE, UXSTACKTOP)范围内说明是在用户的页面处理程序内发生了异常，则将当前的栈指针视为栈顶，压栈前检查栈是否越界：利用user_mem_assert()，根据memlayout.h所示USTACKTOP到UXSTACKTOP-PGSIZE之间有一段Empty Memory，用户无权读写。先压入4个空字节再压入UTrapframe结构的各寄存器参数</p></li><li><p>如果不在，则将<code>UXSTACKTOP</code>视为栈顶，压入<code>UTrapframe</code>结构，<strong>保存env-&gt;tf中的eip和esp</strong></p></li><li><p>设置当前用户栈指针<code>tf-&gt;tf_esp</code>指向异常栈压入<code>UTrapframe</code>后的栈顶</p></li><li><p>设置当前用户下一条执行代码<code>tf-&gt;tf_eip</code>为用户异常处理程序<code>env_pgfault_upcall</code></p></li></ul></li></ol><p>最后重启这个env，就会去执行页错误处理程序去了，执行完之后就会恢复原来的状态。</p><p>![JOS缺页异常处理逻辑](mit 6.828.assets/lab4_4_缺页异常处理逻辑.png)</p><h5 id="实现写时拷贝的fork"><a href="#实现写时拷贝的fork" class="headerlink" title="实现写时拷贝的fork"></a>实现写时拷贝的fork</h5><p>我们先分析一下fork的流程：</p><ol><li>首先我们先调用**set_pgfault_handler()**，将pgfault()设置为页面错误处理函数以及设置父进程env的页错误处理函数入口地址</li><li>然后父进程调用sys_exofork函数，创建一个env子进程，并为子进程申请一个页表并初始化UTOP上的映射关系（内核的映射关系），然后将父进程的tf复制到子进程的tf中，但是要把子进程的tf的eax设置为0，标志这个是个子进程，这个很关键</li><li>创建完成子进程之后，我们要将父进程的页目录表和页表的映射关系给复制到子进程的页目录表和页表中。也就是我们对任意有写权限和cow（copy on write）的USTACKTOP一下的页面，父进程调用duppage()函数将其映射到子进程地址空间，并将父进程和子进程页表中的权限改为只读和cow标志<ul><li>为什么只读，因为采用的是cow方式，当父进程和子进程同时映射一块物理内存的时候，如果这个时候有一个进程想写，就必须触发页错误，这个错误是由处理器产生的。</li><li><strong>我们必须先将子进程的页表中的权限设置为PTE_COW，然后再设置父进程的，为什么？</strong><ul><li><a href="https://ypl.coffee/6-828-2018-lab4/">https://ypl.coffee/6-828-2018-lab4/</a></li><li>因为设置子进程页表项权限是在父进程设置的，会写栈，如果提前设置cow，那么就会触发页错误而申请新的空间当作栈，并设置为可写的，但是后面再去映射子进程的时候，会把这个物理页在子进程中设置为cow，他俩就不一致了，出现错误。</li></ul></li><li>子进程的异常栈需要单独设置，因为异常栈是就是用来处理页错误异常的，不能标志位cow，不然就会一直错误下去。</li></ul></li><li>然后再父进程中设置子进程的env的页错误处理程序入口地址</li><li>然后父进程设置子进程的装填为RUNNABLE，这样子进程就可以被cpu调度到了。</li></ol><h5 id="实际页错误处理函数"><a href="#实际页错误处理函数" class="headerlink" title="实际页错误处理函数"></a>实际页错误处理函数</h5><p>也就是发生页错误的时候（往cow或只读的页面写操作时，就会发生）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">pgfault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> UTrapframe *utf)</span><br>&#123;<br><span class="hljs-type">void</span> *addr = (<span class="hljs-type">void</span> *) utf-&gt;utf_fault_va;    <span class="hljs-comment">//发生异常的时候的地址</span><br><span class="hljs-type">uint32_t</span> err = utf-&gt;utf_err;<br><span class="hljs-type">int</span> r;<br><br><span class="hljs-comment">// Check that the faulting access was (1) a write, and (2) to a</span><br><span class="hljs-comment">// copy-on-write page.  If not, panic.</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//   Use the read-only page table mappings at uvpt</span><br><span class="hljs-comment">//   (see &lt;inc/memlayout.h&gt;).</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-comment">//通过这个uvpt能够取得这个虚拟地址对应的页表项，这个页表项的后12位是用来标记它指定的页的权限</span><br><span class="hljs-comment">//https://blog.csdn.net/weixin_43344725/article/details/89382013</span><br><span class="hljs-keyword">if</span>((err &amp; FEC_WR)==<span class="hljs-number">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW)==<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;pgfault: it&#x27;s not writable or attempt to access a non-cow page!&quot;</span>);<br>&#125;<br><span class="hljs-comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span><br><span class="hljs-comment">// copy the data from the old page to the new page, then move the new</span><br><span class="hljs-comment">// page to the old page&#x27;s address.</span><br><span class="hljs-comment">// Hint:</span><br><span class="hljs-comment">//   You should make three system calls.</span><br><br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-comment">//获取这个进程的id</span><br><span class="hljs-type">envid_t</span> envid = sys_getenvid();<br><span class="hljs-comment">//申请一个页面，然后将物理地址映射到PFTEMP去了</span><br><span class="hljs-keyword">if</span>((r = sys_page_alloc(envid,(<span class="hljs-type">void</span> *)PFTEMP,PTE_P|PTE_W|PTE_U))&lt;<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;pgfault: page allocation failed %e&quot;</span>, r);<br>&#125;<br><span class="hljs-comment">//addr就是发生缺页中断时的地址，将这个addr取整，获取到这个页的地址</span><br>addr = ROUNDDOWN(addr,PGSIZE);<br><span class="hljs-comment">//然后将这个页的内容复制到刚才申请的PFTEMP中去</span><br>memmove(PFTEMP,addr,PGSIZE);<br><span class="hljs-comment">//解除这个addr和指定物理地址的映射</span><br><span class="hljs-keyword">if</span>((r - sys_page_unmap(envid,addr))&lt;<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;pgfault: page unmap failed %e&quot;</span>, r);<br>&#125;<br><span class="hljs-comment">//因为上面我们解除了addr和物理页面的映射，现在我们想将addr映射到PFTEMP对应的物理地址去，这样下次再访问addr是，找到的物理地址就是新的物理地址</span><br><span class="hljs-comment">//并且这个新的物理页可读可写了已经，之前访问的都是父进程的，可读不可写</span><br><span class="hljs-keyword">if</span>((r = sys_page_map(envid,PFTEMP,envid,addr,PTE_P|PTE_W|PTE_U))&lt;<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;pgfault: page map failed %e&quot;</span>, r);<br>&#125;<br><span class="hljs-comment">//经过上面，我们现在有两块虚拟页映射到了同一块新申请的物理地址</span><br><span class="hljs-comment">//接下来我们将解除PFTEMP虚拟地址和物理地址的映射关系</span><br><span class="hljs-keyword">if</span>((r = sys_page_unmap(envid,PFTEMP))&lt;<span class="hljs-number">0</span>)&#123;<br>panic(<span class="hljs-string">&quot;pgfault: page unmap failed %e&quot;</span>, r);<br>&#125;<br><span class="hljs-comment">//这样我们就完成了缺页异常处理的全部功能：就是将父进程的物理页内容重新赋值一份出来，然后更改子进程的页表映射关系，将子进程相同的虚拟地址映射</span><br><span class="hljs-comment">//到不同的物理页面上，这样就完成了子进程和父进程的隔离</span><br><br><span class="hljs-comment">// panic(&quot;pgfault not implemented&quot;);</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>基本步骤如下：</strong></p><p>当发生页错误的时候，就会到这里来。</p><ul><li>首先检测是不是写页面时发生的错误（错误码为FEC_WR）且页面被标记为PTE_COW，如果不是这种情况，就会直接panic</li><li>然后处理进程的页错误，首先是我们会重新申请一块物理内存并将他映射到虚拟地址PFTEMP处，将映射关系存放在这个进程的页表中，并将这个PDE和PTE的权限改成可写权限。然后再将发生页错误的物理地址的内容复制到刚申请的物理内存去，并在这个进程的页表中解除发生页错误的虚拟地址和物理地址之间的映射（如果这个物理地址的引用为0，就会被释放，如果没有就继续存在）</li><li>父子进程都会做上面的动作，在对被标志了cow页面进行写操作时。最后那个最开始的页面就会被释放掉了。</li></ul><blockquote><p>先fork映射页表关系</p></blockquote><p>![image-20230309115148597](mit 6.828.assets/image-20230309115148597.png)</p><blockquote><p>发生页错误</p></blockquote><p>![image-20230309115731416](mit 6.828.assets/image-20230309115731416.png)</p><h3 id="抢占式任务处理"><a href="#抢占式任务处理" class="headerlink" title="抢占式任务处理"></a>抢占式任务处理</h3><h4 id="时钟中断和抢占"><a href="#时钟中断和抢占" class="headerlink" title="时钟中断和抢占"></a>时钟中断和抢占</h4><p>到目前为止，我们采用的协同式多任务机制，采用的是用户自己调用sys_yield去主动的让出cpu，但是这种方式会带来其他任务无法获得cpu的机会，因此我们借助硬件来完成中断式的抢占任务。</p><p>我们基于cpu的时钟中断，在我们的中断表中安装相应的外部中断描述符，然后设置好对应的始终中断处理程序，在trap.c的init中处理。</p><p>外部中断（即设备中断），总共有16中可能的外部中断，``picirq.c<code>中的</code>pic_init<code>映射了编号0-15的外部中断到IDT表中，其表项索引为</code>IRQ_OFFSET～IRQ_OFFSET+15（32-47）。也就是当0-15的外部中断发生后，就会被cpu给转到IDT的32-47中断索引对应的中断处理程序上去。（在这个过程，也需要特权级的检测），我们这里使用的了<strong>32号的时钟中断</strong>。</p><p>我们在jos中对xv6进行了简化，在内核态的时候禁用外部中断（也就是进入内核态就将中断使能关闭了）。我们如何控制了？外部中断的控制在<code>寄存器elfags</code>的FL_IF标志位，这个位置为1的时候表示开启中断，即在进入内核态的时候置为0，离开内核态的时候置为1.</p><p>我们在bootloader的时候关闭了中断，因为内核在启动的时候是不允许开中断的，使用cli关闭了中断。</p><p>我们需要在<code>kern/env.c env_alloc()</code>中添加一句<code>e-&gt;env_tf.tf_eflags |= FL_IF</code>这个保存在tf中，会在恢复用户天的时候设置中断开启（很关键的一步）</p><p>但是我们还要注意在中断表的描述符设置的时候，我们需要将其设置为<code>中断门</code>，不能设置为<code>陷阱门</code>,我们可以看SETGATE上面的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">An interrupt that vectors through an interrupt gate resets IF, thereby preventing other interrupts from interfering with the current interrupt handler<br>  An interrupt through a trap gate does not change IF.<br></code></pre></td></tr></table></figure><p>也就是说中断门会给IF标志位设为0（屏蔽了外部中断，这样就不会发生嵌套的中断），而陷阱门不会。</p><p>如果我们允许一些中断可以相互嵌套，那么就可以将这个设置为1，也就是将他设置为陷阱门</p><p><strong>当我们进入时钟中断时，他的处理逻辑就是响应中断，然后调用sched_yield()这个函数主动让出cpu</strong></p><h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h3><p>IPC–inter-process conmmunication</p><p>先在每个进程已经处于独立运行的状态了，进程间的通信还没有实现,我们这里实现一个简单的IPC机制，像pipe管道这种方式我们等会也要去了解和分析。</p><p>在jos中我们增加了两个系统调用来供用户进程之间的通信。<code>sys_ipc_recv</code>和<code>sys_ipc_send</code>。</p><p>在用户进程之间的传递消息主要包含两个：</p><ol><li>一个32为的值value</li><li>一个页面的映射</li></ol><p>允许一个页面的映射是保证一次通信可以传递更多的内容。</p><h4 id="单个value传递"><a href="#单个value传递" class="headerlink" title="单个value传递"></a>单个value传递</h4><p>调用者会调用sys_ipc_recv来接受消息，这个函数会进入中断，然后设置自己的env为等待接收消息状态，在等待进程消息状态，任何一个进程都可以向这个进程发送消息，然后让出cpu，等待消息</p><p>发送者会调用sys_ipc_send函数，并将接收者的进程id和消息作为参数，向指定的进程发送消息。然后去envs数组中找到这个env就将消息给他，并唤醒这个env，返回0.</p><h4 id="页面传递"><a href="#页面传递" class="headerlink" title="页面传递"></a>页面传递</h4><p>接收进程会调用一个sys_ipc_recv函数并提供一个有效的地址dstva（&lt;UTOP) 这个地址是用来当它接收到一个物理页的时候，将这个虚拟地址映射到这个接收的物理页上。并将之前的映射关系给去除了</p><p>发送进程会调用sys_ipc_send函数，并提供一个有效地址srcva（&lt;UTOP）这个地址就是要发送的页面的虚拟地址，根据这个地址我们找到对应的pageinfo，然后设置接收方的访问权限perm，然后在发送的系统调用中寻找指定的接收方，然后将这个page给映射到指定的env的dstva上，然后这个物理页就被两个进程的共享了。</p><h4 id="实现IPC"><a href="#实现IPC" class="headerlink" title="实现IPC"></a>实现IPC</h4><p><code>sys_ipc_recv</code>：挂起等待接收消息</p><ul><li>判断是否要接收一个页面：dstva &lt; UTOP<ul><li>如果dstva &lt; UTOP但dstva没有4K对齐，返回-E_INVAL异常退出</li><li>如果dstva &gt;= UTOP表明不想收到一个页面！！！</li></ul></li><li><strong>设置当前进程的env_ipc_recving和env_ipc_dstva</strong></li><li>挂起当前进程（env_status设置为ENV_NOT_RUNNABLE），切换到其他环境运行</li><li>sys_ipc_recv本身永不返回，但调用者能收到0作为正确返回值，这里和fork原理一样，<strong>由sys_ipc_try_send设置接收者寄存器eax的值实现</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_ipc_recv</span><span class="hljs-params">(<span class="hljs-type">void</span> *dstva)</span><br>&#123;<br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-comment">//看看这个dstva是不是小于UTOP，如果小于，则是希望接受一个页，并且dstva必须是起始页地址（页对齐）</span><br><span class="hljs-keyword">if</span>(dstva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; dstva != ROUNDDOWN(dstva,PGSIZE))&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>curenv-&gt;env_ipc_recving = <span class="hljs-literal">true</span>; <span class="hljs-comment">//设置正在接受数据</span><br>curenv-&gt;env_ipc_dstva = dstva; <span class="hljs-comment">//设置接受页的虚拟地址</span><br>curenv-&gt;env_status = ENV_NOT_RUNNABLE;<span class="hljs-comment">//设置不可运行状态</span><br>curenv-&gt;env_ipc_from = <span class="hljs-number">0</span>;  <span class="hljs-comment">//envid of the sender</span><br><span class="hljs-comment">// panic(&quot;sys_ipc_recv not implemented&quot;);</span><br>sched_yield();<span class="hljs-comment">//交出cpu的使用权</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sys_ipc_try_send</code>：将消息值<code>value</code>发送到id为<code>envid</code>的进程</p><ul><li>先经过一些列的判断</li><li>然后完成目标进程的页面映射</li><li>设置目标进程接收完成状态</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">sys_ipc_try_send</span><span class="hljs-params">(<span class="hljs-type">envid_t</span> envid, <span class="hljs-type">uint32_t</span> value, <span class="hljs-type">void</span> *srcva, <span class="hljs-type">unsigned</span> perm)</span><br>&#123;<br><span class="hljs-comment">// LAB 4: Your code here.</span><br><span class="hljs-type">int</span> r;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">pp</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span> <span class="hljs-comment">//目标进程</span><br><span class="hljs-keyword">if</span>((r = envid2env(envid,&amp;env,<span class="hljs-number">0</span>))&lt;<span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//如果不存在这个env</span><br><span class="hljs-keyword">return</span> -E_BAD_ENV;<br>&#125;<br><span class="hljs-keyword">if</span>(env-&gt;env_ipc_recving !=<span class="hljs-literal">true</span> || env-&gt;env_ipc_from != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//判读目标进程是否处于接收状态，并且之前没人发送消息给他</span><br><span class="hljs-keyword">return</span> -E_IPC_NOT_RECV;<br>&#125;<br><span class="hljs-keyword">if</span>(srcva &lt;(<span class="hljs-type">void</span> *)UTOP &amp;&amp; PGOFF(srcva))&#123;<br><span class="hljs-comment">//如果srcva&lt;UTOP，那么说明是页传送，那么srcva必须是页对齐的</span><br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-comment">//下面是表示页传送</span><br><span class="hljs-keyword">if</span>(srcva&lt; (<span class="hljs-type">void</span> *) UTOP)&#123;<br><span class="hljs-comment">//要传送的页的权限必须包含PTE_P 和PTE_U</span><br><span class="hljs-keyword">if</span>((perm &amp; PTE_P) == <span class="hljs-number">0</span> || (perm &amp; PTE_U) == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><br><span class="hljs-keyword">if</span>((perm &amp; ~(PTE_P | PTE_U | PTE_W | PTE_AVAIL)) != <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br>&#125;<br><span class="hljs-comment">//看看要传送的这个物理页是否存在</span><br><span class="hljs-keyword">if</span>(srcva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; (pp = page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte)) == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-comment">//查看这个页是不是两个同时拥有可写的权限，不能发送的页不可写，而接收方可写</span><br><span class="hljs-keyword">if</span>(srcva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; (perm &amp; PTE_W) !=<span class="hljs-number">0</span>  &amp;&amp; (*pte &amp; PTE_W) ==<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span> -E_INVAL;<br>&#125;<br><span class="hljs-comment">//如果发送的是页，并且目标进程的所要映射的地址不等于0，那么就可以将这个物理页插入到目标进程的页表中，完成映射</span><br><span class="hljs-keyword">if</span>(srcva &lt; (<span class="hljs-type">void</span> *)UTOP &amp;&amp; env-&gt;env_ipc_dstva !=<span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">if</span>(( r = page_insert(env-&gt;env_pgdir,pp,env-&gt;env_ipc_dstva,perm)) &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-comment">//表示没有足够的内存进程映射，就是无法申请新的页表之类的</span><br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><br>env-&gt;env_ipc_perm = perm;<br>&#125;<br><br><span class="hljs-comment">//上面完成了消息的发送           ======================== 全都是在发送进程中完成的</span><br><span class="hljs-comment">//接下来就是恢复目标进程的状态</span><br><br><br>env-&gt;env_ipc_from = curenv-&gt;env_id; <span class="hljs-comment">//设置进程消息来源进程id</span><br>env-&gt;env_ipc_recving = <span class="hljs-literal">false</span>;       <span class="hljs-comment">//设置目标进程不在处于接收状态</span><br>env-&gt;env_ipc_value = value;         <span class="hljs-comment">//设置这个要传送的消息---value</span><br>env-&gt;env_status = ENV_RUNNABLE;     <span class="hljs-comment">//设置进程状态为可运行状态</span><br>env-&gt;env_tf.tf_regs.reg_eax =<span class="hljs-number">0</span>;<span class="hljs-comment">// 接受进程的中断返回值</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// panic(&quot;sys_ipc_try_send not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>![JOS IPC原理](mit 6.828.assets/lab4_5_IPC原理.png)</p><h2 id="lab5"><a href="#lab5" class="headerlink" title="lab5"></a>lab5</h2><p>本lab将实现的是一个文件系统，主要包含下面4部分内容：</p><ul><li>实现一个文件系统进程（FS进程），基于进程实现文件系统，通过给这个进程的eflags寄存器的IOPL位使能，使得这个进程拥有IO读写的能力。从而避免了进入内核态，省去了较多的开销</li><li>建立RPC机制，通过进程间的通信实现文件的读写，用户进程基于进程通信和文件系统进程进行信息交流实现，通过访问文件系统进程，从而实现读写文件功能</li><li>更高级的抽象，引入了<strong>文件描述符</strong>（FD），通过这个文件描述符我们可以将控制台，pipe，普通文件等统统按照文件对待。</li><li>支持从文件中读取进程运行。</li></ul><h3 id="磁盘结构和File结构"><a href="#磁盘结构和File结构" class="headerlink" title="磁盘结构和File结构"></a>磁盘结构和File结构</h3><blockquote><p>Sector 和 Blocks</p></blockquote><p>大部分磁盘都是以Sector为粒度进行读写的，Jos中的sector是512字节，文件系统以block为单位分配和使用磁盘，一个block是4096个字节。</p><ul><li>Sector：这个是磁盘的属性，一个sector是512</li><li>block: 这个是我们操作系统的属性，一个block是4096</li></ul><blockquote><p>Superblocks – 超级块</p><p>超级块主要包含了文件系统的属性元数据，比如blocksize，disksize，根目录位置等，这些特殊的block叫做superblocks</p></blockquote><p>![磁盘结构](mit 6.828.assets/lab5_1_disk_layout.png)</p><p>结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Super</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> s_magic;       <span class="hljs-comment">// Magic number: FS_MAGIC</span><br>    <span class="hljs-type">uint32_t</span> s_nblocks;     <span class="hljs-comment">// Total number of blocks on disk</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">s_root</span>;</span>     <span class="hljs-comment">// Root directory node</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>File 元数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br>    <span class="hljs-type">char</span> f_name[MAXNAMELEN];    <span class="hljs-comment">// filename</span><br>    <span class="hljs-type">off_t</span> f_size;           <span class="hljs-comment">// file size in bytes</span><br>    <span class="hljs-type">uint32_t</span> f_type;        <span class="hljs-comment">// file type</span><br>    <span class="hljs-comment">// Block pointers.</span><br>    <span class="hljs-comment">// A block is allocated iff its value is != 0.</span><br>    <span class="hljs-type">uint32_t</span> f_direct[NDIRECT]; <span class="hljs-comment">// direct blocks</span><br>    <span class="hljs-type">uint32_t</span> f_indirect;        <span class="hljs-comment">// indirect block</span><br>    <span class="hljs-comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span><br>    <span class="hljs-comment">// fsformat on a 64-bit machine.</span><br>    <span class="hljs-type">uint8_t</span> f_pad[<span class="hljs-number">256</span> - MAXNAMELEN - <span class="hljs-number">8</span> - <span class="hljs-number">4</span>*NDIRECT - <span class="hljs-number">4</span>];<br>&#125; __attribute__((packed));  <span class="hljs-comment">// required only on some 64-bit machines</span><br><br></code></pre></td></tr></table></figure><p>这个File可以指代目录也可以指代普通文件，由这个type字段标识</p></blockquote><p>这个file结构十分的重要，它记录了这个文件的所有信息，比如文件名，文件大小，文件类型，文件存储位置等信息，在这个文件存储位置是记录了具体的block号，有一个直接索引的长度为10个int大小的数组，记录了这个文件存储的位置，还有一个间接索引的字段，记录了一个block，这个block的内容是一个个block num，记录剩余文件内容的位置，总共可以拥有1034个block</p><p>![File文件结构](mit 6.828.assets/lab5_2_file结构.PNG)</p><blockquote><p>Block Bitmap</p></blockquote><p>这个位图是记录了这个磁盘中有哪些block没有被使用，如果使用了，就将对应的位设为0，0表示使用，1表示未使用。</p><p>因此我们提供了一个block的分配器alloc_block函数，用来搜索这个bitmap数组，然后返回这个未使用的block。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//给bitmap的对用的块编号置0（已使用）</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">alloc_block</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// The bitmap consists of one or more blocks.  A single bitmap block</span><br><span class="hljs-comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span><br><span class="hljs-comment">// super-&gt;s_nblocks blocks in the disk altogether.</span><br><br><span class="hljs-comment">// LAB 5: Your code here.</span><br><span class="hljs-type">uint32_t</span> blockno;<br><span class="hljs-keyword">for</span>(blockno = <span class="hljs-number">0</span>; blockno &lt; super-&gt;s_nblocks ; blockno++)&#123;<br><span class="hljs-keyword">if</span>(block_is_free(blockno))&#123;<br>bitmap[blockno/<span class="hljs-number">32</span>] ^= <span class="hljs-number">1</span>&lt;&lt;(blockno%<span class="hljs-number">32</span>);  <span class="hljs-comment">//给这个空闲的位置0；表示已使用</span><br><span class="hljs-comment">//紧接着将bitmap同步到磁盘</span><br>flush_block(bitmap); <span class="hljs-comment">//虚拟地址和磁盘块地址都是对应好的了</span><br><span class="hljs-keyword">return</span> blockno;<br> &#125;<br>&#125;<br><span class="hljs-comment">// panic(&quot;alloc_block not implemented&quot;);</span><br><span class="hljs-keyword">return</span> -E_NO_DISK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h3><h4 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h4><blockquote><p>文件系统进程如何去访问磁盘呢？</p></blockquote><p>到目前为止内核还没有访问磁盘的能力。JOS不像其他操作系统一样在内核添加磁盘驱动，然后提供系统调用。我们实现一个文件系统进程来作为磁盘驱动。<br><strong>x86处理器使用EFLAGS寄存器的IOPL为来控制保护模式下代码是否能执行设备IO指令，比如in和out。我们希望文件系统进程能访问IO空间，其他进程不能。</strong></p><p>所以我们在创建这个文件系统进程的时候一定要将他的Trapframe字段中的eflags字段给设置一下，保证IOPL位使能，从而实现这个文件系统能够执行IO操作</p><h4 id="Block-Cache-–-加载文件到内存"><a href="#Block-Cache-–-加载文件到内存" class="headerlink" title="Block Cache – 加载文件到内存"></a>Block Cache – 加载文件到内存</h4><p>我们的文件系统最大可以支持3GB，我们是将文件系统进程的<strong>虚拟地址0x10000000-0xD0000000</strong>默认映射到3GB的磁盘空间。</p><ul><li><strong>但是我们不可能一下子将3GB磁盘缓存到内存中，而是通过一个pgfault来实现这个文件的加载进内存。</strong></li><li>当我们访问某个block对应的内存地址时出现页错误，然后将这个block加载到内存中，并映射页表关系。</li></ul><blockquote><p>bc_pgfault()函数，就是文件系统发生页错误时真正处理异常的函数</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Fault any disk block that is read in to memory by</span><br><span class="hljs-comment">// loading it from disk.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">bc_pgfault</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> UTrapframe *utf)</span><br>&#123;<br><span class="hljs-type">void</span> *addr = (<span class="hljs-type">void</span> *) utf-&gt;utf_fault_va;<span class="hljs-comment">//发生缺页中断的地方</span><br><span class="hljs-type">uint32_t</span> blockno = ((<span class="hljs-type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;  <span class="hljs-comment">//获取磁盘块编号</span><br><span class="hljs-type">int</span> r =<span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// Check that the fault was within the block cache region</span><br><span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-type">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-type">void</span>*)(DISKMAP + DISKSIZE))<br>panic(<span class="hljs-string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,<br>      utf-&gt;utf_eip, addr, utf-&gt;utf_err);<br><br><span class="hljs-comment">// Sanity check the block number.</span><br><span class="hljs-keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)<br>panic(<span class="hljs-string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);<br><br><span class="hljs-comment">// Allocate a page in the disk map region, read the contents</span><br><span class="hljs-comment">// of the block from the disk into that page.</span><br><span class="hljs-comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span><br><span class="hljs-comment">// the disk.</span><br><span class="hljs-comment">// 在内存中申请一个页用来存放从磁盘读取的一个block</span><br><span class="hljs-comment">// LAB 5: you code here:</span><br>addr = ROUNDDOWN(addr,PGSIZE);  <span class="hljs-comment">//获取发生缺页中断的页的起始地址</span><br><span class="hljs-keyword">if</span>((sys_page_alloc(<span class="hljs-number">0</span>,addr,PTE_W|PTE_U|PTE_P) &lt; <span class="hljs-number">0</span>))<span class="hljs-comment">//为文件系统进程申请一个页，并完成映射</span><br> panic(<span class="hljs-string">&quot;in bc_pgfault, sys_page_alloc: %e&quot;</span>, r);<br><span class="hljs-keyword">if</span>((r = ide_read(blockno * BLKSECTS,addr,BLKSECTS))&lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//blockno * BLKSECTS表示扇区号（一个块包含BLKSECTS个扇区）。功能是将某个扇区号开始的扇区读进来BLKSECTS个扇区到addr处</span><br>panic(<span class="hljs-string">&quot;in bc_pgfault, ide_read: %e&quot;</span>, r);<br><span class="hljs-comment">// Clear the dirty bit for the disk block page since we just read the</span><br><span class="hljs-comment">// block from disk</span><br><span class="hljs-keyword">if</span> ((r = sys_page_map(<span class="hljs-number">0</span>, addr, <span class="hljs-number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 设置PTE_D位置为0，表示不是dirty的</span><br>panic(<span class="hljs-string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);<br><br><span class="hljs-comment">// Check that the block we read was allocated. (exercise for</span><br><span class="hljs-comment">// the reader: why do we do this *after* reading the block</span><br><span class="hljs-comment">// in?)</span><br><span class="hljs-keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))<br>panic(<span class="hljs-string">&quot;reading free block %08x\n&quot;</span>, blockno);<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>flush_block这个函数是将内存中的数据写入到磁盘中</p><ul><li>通过页表项中的PTE_D位（dirty位–标识这个内存是否脏了）</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">flush_block</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> blockno = ((<span class="hljs-type">uint32_t</span>)addr - DISKMAP) / BLKSIZE;<br><br><span class="hljs-keyword">if</span> (addr &lt; (<span class="hljs-type">void</span>*)DISKMAP || addr &gt;= (<span class="hljs-type">void</span>*)(DISKMAP + DISKSIZE))<br>panic(<span class="hljs-string">&quot;flush_block of bad va %08x&quot;</span>, addr);<br><br><span class="hljs-comment">// LAB 5: Your code here.</span><br><span class="hljs-type">int</span> r =<span class="hljs-number">0</span>;<br>addr = ROUNDDOWN(addr,PGSIZE);<br><span class="hljs-comment">//脏块的判断是通过PTE_D来判断的</span><br><span class="hljs-keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;  <span class="hljs-comment">//先看这个addr有没有读进来的扇区，并且有没有被修改,如果有，那么就将这个addr对应的块同步到磁盘</span><br><span class="hljs-keyword">if</span>((r = ide_write(blockno * BLKSECTS,addr,BLKSECTS)) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//将addr地址开始的块内存写入到磁盘扇区编号为blockno * BLKSECTS地方</span><br>panic(<span class="hljs-string">&quot;in flush_block, ide_write: %e&quot;</span>, r);<br>&#125;<br><span class="hljs-keyword">if</span>((r = sys_page_map(<span class="hljs-number">0</span>,addr,<span class="hljs-number">0</span>,addr,uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//清空PTE_D位，也就是dirty，这个就是重新自映射一下，只是把perm改了一下</span><br>panic(<span class="hljs-string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);<br>&#125;<br>&#125;<br><span class="hljs-comment">// panic(&quot;flush_block not implemented&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>![JOS fs进程虚拟地址空间和磁盘关系](mit 6.828/lab5_3_fs进程虚拟地址空间和磁盘.png)</p><p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p><h3 id="File-Operations-–-文件操作"><a href="#File-Operations-–-文件操作" class="headerlink" title="File Operations – 文件操作"></a>File Operations – 文件操作</h3><blockquote><p>基本的文件操作：</p></blockquote><ol><li><code>file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</code>：查找f指向文件结构的第filebno个block的存储地址，保存到ppdiskbno中。如果f-&gt;f_indirect还没有分配，且alloc为真，那么将分配要给新的block作为该文件的f-&gt;f_indirect。类比页表管理的pgdir_walk()。</li><li><code>file_get_block(struct File *f, uint32_t filebno, char **blk)</code>：该函数查找文件第filebno个block对应的虚拟地址addr，将其保存到blk地址处。</li><li><code>walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)</code>：解析路径path，填充pdir和pf地址处的File结构。比如/aa/bb/cc.c那么pdir指向代表bb目录的File结构，pf指向代表cc.c文件的File结构。又比如/aa/bb/cc.c，但是cc.c此时还不存在，那么pdir依旧指向代表bb目录的File结构，但是pf地址处应该为0，lastelem指向的字符串应该是cc.c。</li><li><code>dir_lookup(struct File *dir, const char *name, struct File **file)</code>：该函数查找dir指向的文件内容，寻找File.name为name的File结构，并保存到file地址处。</li><li><code>dir_alloc_file(struct File *dir, struct File **file)</code>：在dir目录文件的内容中寻找一个未被使用的File结构，将其地址保存到file的地址处。</li></ol><blockquote><p>文件操作</p></blockquote><ol><li><code>file_create(const char *path, struct File **pf)</code>：创建path，如果创建成功pf指向新创建的File指针。</li><li><code>file_open(const char *path, struct File **pf)</code>：寻找path对应的File结构地址，保存到pf地址处。</li><li><code>file_read(struct File *f, void *buf, size_t count, off_t offset)</code>：从文件f中的offset字节处读取count字节到buf处。</li><li><code>file_write(struct File *f, const void *buf, size_t count, off_t offset)</code>：将buf处的count字节写到文件f的offset开始的位置。</li></ol><h3 id="File-System-interface"><a href="#File-System-interface" class="headerlink" title="File System interface"></a>File System interface</h3><p>上面我们为这个文件系统进程提供了一大堆文件操作的函数，但是这些函数只能被文件系统进程使用，而无法被其他的进程使用，因此我们需要进行进程间的通信，实现这个不同的用户进程和这个文件进程通信，通过将要操作的文件信息发送给文件进程，让他给我们操作文件。这其实是一种RPC机制。</p><p>![image-20230322210322786](mit 6.828/image-20230322210322786.png)</p><p>这个机制是如何实现的呢？</p><ul><li>首先我们的文件系统会一直处于接收状态，一直接收IPC请求，然后将对应的请求分配到对应的处理函数中去，并将结果通过IPC发送给用户进程。</li><li>对于客户端来说，我们会为一个fsipcbuf结构分配一个共享页，然后将这个共享也作为自己这个进程和文件进程的共享空间，我们利用这个共享页发送我们要对文件操作的动作（open/write/read等）和文件的一些信息（name等）。</li><li>对于文件进程来说，它会把fsipcbuf对应的那个用户进程的共享页给映射到一个指定的位置（0x0ffff000），然后就可以读取用户进程发送过来的信息，然后文件进程还可以在这个内存中写东西，供用户进程使用。</li><li>在open操作时，文件进程还会申请一个页作为FD文件描述符页并发送给用户进程，然后用户进程接收时将这个对应的物理页映射到自己当初分配至fd空间处，这个fd包含了这个文件基本内容，文件id和文件类型（是设备还是控制台还是file），通过这个我们就可以调用不同的read/write函数。（这个fd很巧妙）<ul><li>在open时，文件进程会分配一个openfile结构空间，用来记录这个打开的文件，他里面有一个File，这个就是我们操作磁盘的关键。并且在这个结构中还有一个fd指针，指向一个文件系统分配的页空间，然后将这个页空间和用户进程的fd对应的地址相映射，这样用户进程就拿到了这个在文件系统中产生的文件描述符。</li></ul></li></ul><h3 id="Spawning-Process"><a href="#Spawning-Process" class="headerlink" title="Spawning Process"></a>Spawning Process</h3><p>这个是实现一个从磁盘中读取一个进程文件，然后并运行的功能。和uinx的fork之后采取exec()动作一样。</p><p>基本流程就是：</p><ol><li>从文件系统打开prog程序文件</li><li>调用系统调用sys_exofork()创建一个新的Env结构</li><li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段（该字段包含寄存器信息）。</li><li>根据ELF文件中program herder，将用户程序以Segment读入内存，并映射到指定的线性地址处。</li><li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNNABLE。</li></ol><p>![客户端进程和FS进程交互](mit 6.828/lab5_6_fs进程实现原理.png)</p><p>更高级的抽象，引入<strong>文件描述符</strong>。通过文件描述符这一层抽象就可以将<strong>控制台，pipe，普通文件</strong>，统统按照文件来对待。文件描述符和pipe的原理总结如下：</p><p>![文件描述符和pipe原理](mit 6.828/lab5_5_文件_fd实现原理_pipe实现原理.png)</p><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2>]]></content>
    
    
    
    <tags>
      
      <tag>MIT6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
